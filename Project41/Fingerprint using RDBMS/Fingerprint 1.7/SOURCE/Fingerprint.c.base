/*
** Title:               Fingerprint.c
** SCCSid:              %W% %E% %U%
** CCid:                %W% %E% %U%
** Author:              
** Created:             Mar 06, 1999 09:14:08 AM
** Description:         Generated 'C' file.
** Comments:            Generated for project Fingerprint.1.7.3p.41.
*/

/*
**  The following is placed here to insure
**  that name "mangling" does not occur.
*/
#ifdef __cplusplus

extern "C"
{

#endif

/* Standard library includes. */
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stddef.h>

/* Used by Informix GLS routines. */
#include <ifxgls.h>

/* Include when accessing the Informix API. */
#include <mi.h>

/* This is the project include file. */
#include "Fingerprint.h"

/****************************************************************
**
** Function name:
**
**	pnt_tInput
**
** Description:
**
**	This function converts from the external representation of the
**	UDT type pnt_t to its internal representation.   The external
**	representation is a blank-separated list of values and the
**	internal representation is a 'C' structure of type pnt_t as
**	defined in the header file.
**
**	Data may be inserted into a table using an SQL insert statement:
**
**		insert into tablename values ( 'value-list' );
**
**	value-list is a space-delimited list of values.
**
** Special Comments:
**
**	Support routine for opaque type pnt_t returns pnt_t.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	pnt_t *                            The constructed UDT value.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    pnt_tInput FunctionId: 78755522-bf71-11d2-806c-204c4f4f5020
**
*****************************************************************
*/
pnt_t *
pnt_tInput
(
mi_lvarchar *           Gen_param1,        /* Pointer to the input text.         */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	gl_mchar_t *    Gen_InData;        /* Pointer to the input data.         */
	pnt_t *         Gen_OutData;       /* Pointer to the output data.        */
	mi_integer      Gen_DataLen;       /* Length of the data in bytes.       */
	pnt_t *         Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in pnt_tInput."
		*/
		DBDK_TRACE_ERROR( "pnt_tInput", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that pnt_tInput has been called.
	*/
	DBDK_TRACE_ENTER( "pnt_tInput" );

	/* Allocate memory room to build the UDT in. */
	Gen_RetVal = (pnt_t *)mi_alloc( sizeof( pnt_t ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in pnt_tInput."
		*/
		DBDK_TRACE_ERROR( "pnt_tInput", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = (gl_mchar_t *)mi_get_vardata( Gen_param1 );


	/* Point to the output data. */
	Gen_OutData = (pnt_t *)Gen_RetVal;

	/* Get the length of the input string. */
	Gen_DataLen = mi_get_varlen( Gen_param1 );

	/* Get the data value for Gen_OutData->X. */
	Gen_InData = Gen_sscanf( Gen_Con, "pnt_tInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->X );

	/* Get the data value for Gen_OutData->Y. */
	Gen_InData = Gen_sscanf( Gen_Con, "pnt_tInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Y );

	/* Get the data value for Gen_OutData->Zeta. */
	Gen_InData = Gen_sscanf( Gen_Con, "pnt_tInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Zeta );


	/*
	** Write to the trace file indicating
	** that pnt_tInput has successfully exited.
	*/
	DBDK_TRACE_EXIT( "pnt_tInput" );

	/* Close the connection. */
	mi_close( Gen_Con );

	/* Return the UDT value. */
	return Gen_RetVal;
}
/* Warning: Do not modify. pnt_tInput checksum: 158446402  */

/****************************************************************
**
** Function name:
**
**	pnt_tOutput
**
** Description:
**
**	This function converts from the internal representation of the
**	UDT type pnt_t to its external representation.   The external
**	representation is a blank-separated list of values and the
**	internal representation is a 'C' structure of type pnt_t as
**	defined in the header file.
**
**	Data may be retrieved from a table using an SQL select statement:
**
**		select * from tablename;
**
** Special Comments:
**
**	Support routine for opaque type pnt_t returns lvarchar.
**
** Parameters:
**
**	pnt_t *         Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    pnt_tOutput FunctionId: 78755523-bf71-11d2-806c-204c4f4f5020
**
*****************************************************************
*/
mi_lvarchar *
pnt_tOutput
(
pnt_t *                 Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_integer      Gen_CharLen;       /* Estimate maximum length.           */
	pnt_t *         Gen_InData;        /* Pointer to the input data.         */
	char *          Gen_OutData;       /* Pointer to the output data.        */
	mi_lvarchar *   Gen_RetVal;        /* The return result.                 */
	mi_integer      Gen_DataLen;       /* The data length.                   */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in pnt_tOutput."
		*/
		DBDK_TRACE_ERROR( "pnt_tOutput", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that pnt_tOutput has been called.
	*/
	DBDK_TRACE_ENTER( "pnt_tOutput" );

	/* Compute the maximum length of the text representation. */
	Gen_CharLen =    1;	/* Leave room for the NULL terminator. */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->X.                      */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Y.                      */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Zeta.                   */

	/* Allocate room for the output string. */
	Gen_RetVal = mi_new_var( Gen_CharLen );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in pnt_tOutput."
		*/
		DBDK_TRACE_ERROR( "pnt_tOutput", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = Gen_param1;

	/* Point to the output data. */
	Gen_OutData = mi_get_vardata( Gen_RetVal );

	/* Format the attribute value into the output string. */

	/* Format the value for Gen_InData->X. */
	sprintf( Gen_OutData, "%d ", Gen_InData->X );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the value for Gen_InData->Y. */
	sprintf( Gen_OutData, "%d ", Gen_InData->Y );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the value for Gen_InData->Zeta. */
	sprintf( Gen_OutData, "%d ", Gen_InData->Zeta );
	Gen_OutData += strlen( Gen_OutData );


	/*
	** Compute the length of the data and
	** place it in the return structure.
	*/
	Gen_DataLen = (mi_integer)(Gen_OutData - mi_get_vardata( Gen_RetVal ));
	mi_set_varlen ( Gen_RetVal, Gen_DataLen );

	/*
	** Write to the trace file indicating
	** that pnt_tOutput has successfully exited.
	*/
	DBDK_TRACE_EXIT( "pnt_tOutput" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. pnt_tOutput checksum: 143220201  */

/****************************************************************
**
** Function name:
**
**	fing_tInput
**
** Description:
**
**	This function converts from the external representation of the
**	UDT type fing_t to its internal representation.   The external
**	representation is a blank-separated list of values and the
**	internal representation is a 'C' structure of type fing_t as
**	defined in the header file.
**
**	Data may be inserted into a table using an SQL insert statement:
**
**		insert into tablename values ( 'value-list' );
**
**	value-list is a space-delimited list of values.
**
** Special Comments:
**
**	Support routine for opaque type fing_t returns fing_t.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    fing_tInput FunctionId: fe73ada4-cc7b-11d2-b023-204c4f4f5020
**
*****************************************************************
*/
mi_lvarchar *
fing_tInput
(
mi_lvarchar *           Gen_param1,        /* Pointer to the input text.         */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	gl_mchar_t *    Gen_InData;        /* Pointer to the input data.         */
	fing_t *        Gen_OutData;       /* Pointer to the output data.        */
	mi_integer      Gen_DataLen;       /* Length of the data in bytes.       */
	mi_lvarchar *   Gen_RetVal;        /* The return value.                  */
	mi_integer      Gen_vl_nitems;     /* Number of variable length items.   */
	mi_integer      Gen_vl_itemno;     /* Index through the items.           */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in fing_tInput."
		*/
		DBDK_TRACE_ERROR( "fing_tInput", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that fing_tInput has been called.
	*/
	DBDK_TRACE_ENTER( "fing_tInput" );

	/* Point to the input data. */
	Gen_InData = (gl_mchar_t *)mi_get_vardata( Gen_param1 );


	/* Compute the number of repetitions in the variable length input. */
	Gen_vl_nitems =
		(Gen_nstrwords( Gen_InData, mi_get_varlen( (mi_lvarchar *)Gen_param1 ) ) - 0 )/3;


	/* Compute the amount of memory required for the data. */
	Gen_DataLen = sizeof( fing_t ) +
			(Gen_vl_nitems - 1) * sizeof( Gen_OutData->data );

	/* Allocate sufficient memory to build the UDT in. */
	Gen_RetVal = mi_new_var( Gen_DataLen );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in fing_tInput."
		*/
		DBDK_TRACE_ERROR( "fing_tInput", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the output data. */
	Gen_OutData = (fing_t *)mi_get_vardata( Gen_RetVal );

	/* Handle the fixed part of the UDT. */


	/* Handle the variable part of the UDT. */
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		/* Get the data value for Gen_OutData->data[Gen_vl_itemno].X. */
		Gen_InData = Gen_sscanf( Gen_Con, "fing_tInput", Gen_InData,
					mi_get_varlen( Gen_param1 ), 0,
					"%d %n",
					(char *)&Gen_OutData->data[Gen_vl_itemno].X );

		/* Get the data value for Gen_OutData->data[Gen_vl_itemno].Y. */
		Gen_InData = Gen_sscanf( Gen_Con, "fing_tInput", Gen_InData,
					mi_get_varlen( Gen_param1 ), 0,
					"%d %n",
					(char *)&Gen_OutData->data[Gen_vl_itemno].Y );

		/* Get the data value for Gen_OutData->data[Gen_vl_itemno].Zeta. */
		Gen_InData = Gen_sscanf( Gen_Con, "fing_tInput", Gen_InData,
					mi_get_varlen( Gen_param1 ), 0,
					"%d %n",
					(char *)&Gen_OutData->data[Gen_vl_itemno].Zeta );

	}


	/*
	** Write to the trace file indicating
	** that fing_tInput has successfully exited.
	*/
	DBDK_TRACE_EXIT( "fing_tInput" );

	/* Close the connection. */
	mi_close( Gen_Con );

	/* Return the UDT value. */
	return Gen_RetVal;
}
/* Warning: Do not modify. fing_tInput checksum: 509530242  */

/****************************************************************
**
** Function name:
**
**	fing_tOutput
**
** Description:
**
**	This function converts from the internal representation of the
**	UDT type fing_t to its external representation.   The external
**	representation is a blank-separated list of values and the
**	internal representation is a 'C' structure of type fing_t as
**	defined in the header file.
**
**	Data may be retrieved from a table using an SQL select statement:
**
**		select * from tablename;
**
** Special Comments:
**
**	Support routine for opaque type fing_t returns lvarchar.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    fing_tOutput FunctionId: fe73ada3-cc7b-11d2-b023-204c4f4f5020
**
*****************************************************************
*/
mi_lvarchar *
fing_tOutput
(
mi_lvarchar *           Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_integer      Gen_CharLen;       /* Estimate maximum length.           */
	fing_t *        Gen_InData;        /* Pointer to the input data.         */
	char *          Gen_OutData;       /* Pointer to the output data.        */
	mi_lvarchar *   Gen_RetVal;        /* The return result.                 */
	mi_integer      Gen_vl_nitems;     /* Number of items.                   */
	mi_integer      Gen_vl_itemno;     /* Dummy index.                       */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in fing_tOutput."
		*/
		DBDK_TRACE_ERROR( "fing_tOutput", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that fing_tOutput has been called.
	*/
	DBDK_TRACE_ENTER( "fing_tOutput" );

	/* Compute the number of variable length items. */
	Gen_vl_nitems =
		(mi_get_varlen( (mi_lvarchar *)Gen_param1 ) - sizeof( fing_t ) + sizeof( Gen_InData->data ))
		/ sizeof( Gen_InData->data );


	/* Compute the maximum length of the text representation. */
	Gen_CharLen =    1;	/* Leave room for the NULL terminator. */
	
	/* Compute the text length for the variable part. */
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		Gen_CharLen +=  12;	/* Add the length for Gen_OutData->data[Gen_vl_itemno].X.  */
		Gen_CharLen +=  12;	/* Add the length for Gen_OutData->data[Gen_vl_itemno].Y.  */
		Gen_CharLen +=  12;	/* Add the length for Gen_OutData->data[Gen_vl_itemno].Zeta. */

	}

	/* Allocate room for the output string. */
	Gen_RetVal = mi_new_var( Gen_CharLen );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in fing_tOutput."
		*/
		DBDK_TRACE_ERROR( "fing_tOutput", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = (fing_t *)mi_get_vardata( Gen_param1 );

	/* Point to the output data. */
	Gen_OutData = mi_get_vardata( Gen_RetVal );

	/* Transfer the fixed part of the UDT. */


	/* Handle the variable part of the UDT. */
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		/* Format the value for Gen_InData->data[Gen_vl_itemno].X. */
		sprintf( Gen_OutData, "%d ", Gen_InData->data[Gen_vl_itemno].X );
		Gen_OutData += strlen( Gen_OutData );

		/* Format the value for Gen_InData->data[Gen_vl_itemno].Y. */
		sprintf( Gen_OutData, "%d ", Gen_InData->data[Gen_vl_itemno].Y );
		Gen_OutData += strlen( Gen_OutData );

		/* Format the value for Gen_InData->data[Gen_vl_itemno].Zeta. */
		sprintf( Gen_OutData, "%d ", Gen_InData->data[Gen_vl_itemno].Zeta );
		Gen_OutData += strlen( Gen_OutData );

	}

	/*
	** Compute the length of the data and
	** place it in the return structure.
	*/
	mi_set_varlen ( Gen_RetVal,
		(mi_integer)(Gen_OutData - mi_get_vardata( Gen_RetVal )) );

	/*
	** Write to the trace file indicating
	** that fing_tOutput has successfully exited.
	*/
	DBDK_TRACE_EXIT( "fing_tOutput" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. fing_tOutput checksum: 425952578  */

/****************************************************************
**
** Function name:
**
**	fing_tSend
**
** Description:
**
**	The binary send function is used to convert an instance of a
**	data type between its internal representation on the server and
**	on the client.
**
** Special Comments:
**
**	Support routine for opaque type fing_t returns sendrecv.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    fing_tSend FunctionId: fe73ada6-cc7b-11d2-b023-204c4f4f5020
**
*****************************************************************
*/
mi_sendrecv *
fing_tSend
(
mi_bitvarying *         Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_sendrecv *   Gen_RetVal;        /* The return packet value.           */
	mi_integer      Gen_vl_nitems;     /* Number of items.                   */
	mi_integer      Gen_vl_itemno;     /* Dummy index.                       */
	fing_t *        Gen_InData;        /* Pointer to the UDT value.          */
	fing_t *        Gen_OutData;       /* Pointer to the packet.             */
	mi_integer      Gen_tempval;       /* Used to transfer mi_smallint-s.    */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in fing_tSend."
		*/
		DBDK_TRACE_ERROR( "fing_tSend", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that fing_tSend has been called.
	*/
	DBDK_TRACE_ENTER( "fing_tSend" );

	Gen_InData = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

	/* Compute the maximum expected length. */
	Gen_vl_nitems =
			(mi_get_varlen((mi_lvarchar *)Gen_param1) - offsetof( fing_t, data ))
				/ sizeof( Gen_InData->data );

	/* Allocate a new return value. */
	Gen_RetVal = (mi_sendrecv *)mi_new_var( sizeof( fing_t ) +
			(Gen_vl_nitems - 1) *
			sizeof( Gen_InData->data ));
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in fing_tSend."
		*/
		DBDK_TRACE_ERROR( "fing_tSend", ERRORMESG2, 10 );

		/* not reached */
	}

	/*
	** Get a pointer to the data so that the
	** attribute values may be set into it.
	*/
	Gen_OutData = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );


	/* Place the UDT's variable attribute value(s) into the packet. */
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		/* Prepare the value for Gen_OutData->data[Gen_vl_itemno].X. */
		mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->data[Gen_vl_itemno].X, Gen_InData->data[Gen_vl_itemno].X );

		/* Prepare the value for Gen_OutData->data[Gen_vl_itemno].Y. */
		mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->data[Gen_vl_itemno].Y, Gen_InData->data[Gen_vl_itemno].Y );

		/* Prepare the value for Gen_OutData->data[Gen_vl_itemno].Zeta. */
		mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->data[Gen_vl_itemno].Zeta, Gen_InData->data[Gen_vl_itemno].Zeta );

	}


	/*
	** Write to the trace file indicating
	** that fing_tSend has successfully exited.
	*/
	DBDK_TRACE_EXIT( "fing_tSend" );

	/* Close the connection. */
	mi_close( Gen_Con );

	/* Return the UDT for transmission. */
	return Gen_RetVal;
}
/* Warning: Do not modify. fing_tSend checksum: 281234996  */

/****************************************************************
**
** Function name:
**
**	fing_tReceive
**
** Description:
**
**	The binary receive function is used to convert an instance of a
**	data type between its internal representation on the server and
**	on the client.
**
** Special Comments:
**
**	Support routine for opaque type fing_t returns fing_t.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    fing_tReceive FunctionId: fe73ada5-cc7b-11d2-b023-204c4f4f5020
**
*****************************************************************
*/
mi_bitvarying *
fing_tReceive
(
mi_sendrecv *           Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_bitvarying * Gen_RetVal;        /* The return value.                  */
	fing_t *        Gen_InData;        /* Packet data.                       */
	fing_t *        Gen_OutData;       /* Output UDT value.                  */
	mi_integer      Gen_DataLen;       /* The data length.                   */
	mi_integer      Gen_vl_nitems;     /* Number of data items.              */
	mi_integer      Gen_vl_itemno;     /* Index thru the items.              */
	mi_integer      Gen_vl_len;        /* The length.                        */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in fing_tReceive."
		*/
		DBDK_TRACE_ERROR( "fing_tReceive", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that fing_tReceive has been called.
	*/
	DBDK_TRACE_ENTER( "fing_tReceive" );

	/* Point to the input data. */
	Gen_InData = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

	/* Get the length of the data to follow. */
	Gen_vl_len = mi_get_varlen( (mi_lvarchar *)Gen_param1 );

	/* Compute the number of items in the variable length list. */
	Gen_vl_nitems = (Gen_vl_len - offsetof( fing_t, data )) /
					sizeof( Gen_OutData->data );

	/* Allocate room for the UDT. */
	Gen_RetVal = (mi_bitvarying *)mi_new_var(
					sizeof( fing_t ) +
					  (Gen_vl_nitems - 1) *
					  sizeof( Gen_OutData->data ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in fing_tReceive."
		*/
		DBDK_TRACE_ERROR( "fing_tReceive", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the output data. */
	Gen_OutData = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

	/* Copy the attribute value(s) from the transmission parcel. */

	/* Retrieve the UDT's variable attribute value(s) from the packet. */
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		/* Prepare the value for Gen_InData->data[Gen_vl_itemno].X. */
		mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->data[Gen_vl_itemno].X, &Gen_OutData->data[Gen_vl_itemno].X );

		/* Prepare the value for Gen_InData->data[Gen_vl_itemno].Y. */
		mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->data[Gen_vl_itemno].Y, &Gen_OutData->data[Gen_vl_itemno].Y );

		/* Prepare the value for Gen_InData->data[Gen_vl_itemno].Zeta. */
		mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->data[Gen_vl_itemno].Zeta, &Gen_OutData->data[Gen_vl_itemno].Zeta );

	}


	/*
	** Write to the trace file indicating
	** that fing_tReceive has successfully exited.
	*/
	DBDK_TRACE_EXIT( "fing_tReceive" );

	/* Return the transmitted UDT value. */
	return Gen_RetVal;
}
/* Warning: Do not modify. fing_tReceive checksum: 234524797  */

/****************************************************************
**
** Function name:
**
**	fing_tImportText
**
** Description:
**
**	The import function enables bulk copy for user-defined types.
**	When the  LOAD statement is  used from  dbaccess to copy data
**	from a file  into the database, the  server calls the  import
**	function to convert the  incoming  value  to the data  type's
**	internal format.
**
** Special Comments:
**
**	Support routine for opaque type fing_t returns fing_t.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	fing_t *                           The constructed UDT value.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    fing_tImportText FunctionId: fe73ada7-cc7b-11d2-b023-204c4f4f5020
**
*****************************************************************
*/
mi_bitvarying *
fing_tImportText
(
mi_impexp *             Gen_param1,        /* The import text.                   */
MI_FPARAM *             Gen_fparam         /* Std info - see DBDK docs.          */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	gl_mchar_t *    Gen_InData;        /* Pointer to the data.               */
	fing_t *        Gen_OutData;       /* Pointer to output data.            */
	mi_integer      Gen_DataLen;       /* Length of the data in bytes.       */
	mi_bitvarying * Gen_RetVal;        /* The return value.                  */
	mi_integer      Gen_vl_nitems;     /* Number of items.                   */
	mi_integer      Gen_vl_itemno;     /* Index thru the items.              */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in fing_tImportText."
		*/
		DBDK_TRACE_ERROR( "fing_tImportText", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that fing_tImportText has been called.
	*/
	DBDK_TRACE_ENTER( "fing_tImportText" );

	/* Point to the input data. */
	Gen_InData =  (gl_mchar_t *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );


	/* Compute the number of repetitions in the variable length input. */
	Gen_vl_nitems =
		(Gen_nstrwords( Gen_InData, mi_get_varlen( (mi_lvarchar *)Gen_param1 ) ) - 0 )/3;


	/* Compute the amount of memory required for the data. */
	Gen_DataLen = sizeof( fing_t ) +
			(Gen_vl_nitems - 1) * sizeof( Gen_OutData->data );

	/* Allocate sufficient memory for the return UDT. */
	Gen_RetVal = (mi_bitvarying *)mi_new_var( Gen_DataLen );
	if( Gen_RetVal == 0)
	{
		/*
		**	Memory allocation has failed so issue
		**	the following message and quit.
		**
		**	"Memory allocation has failed in fing_tImportText."
		*/
		DBDK_TRACE_ERROR( "fing_tImportText", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the output data. */
	Gen_OutData = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );


	/* Handle the variable part of the UDT. */
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		/* Fill the UDT with its value. */
		Gen_InData = Gen_sscanf( Gen_Con, "fing_tImportText", Gen_InData,
					mi_get_varlen( (mi_lvarchar *)Gen_param1 ), 0,
					"%d %n",
					(char *)&Gen_OutData->data[Gen_vl_itemno].X );

		/* Fill the UDT with its value. */
		Gen_InData = Gen_sscanf( Gen_Con, "fing_tImportText", Gen_InData,
					mi_get_varlen( (mi_lvarchar *)Gen_param1 ), 0,
					"%d %n",
					(char *)&Gen_OutData->data[Gen_vl_itemno].Y );

		/* Fill the UDT with its value. */
		Gen_InData = Gen_sscanf( Gen_Con, "fing_tImportText", Gen_InData,
					mi_get_varlen( (mi_lvarchar *)Gen_param1 ), 0,
					"%d %n",
					(char *)&Gen_OutData->data[Gen_vl_itemno].Zeta );

	}


	/*
	** Write to the trace file indicating
	** that fing_tImportText has successfully exited.
	*/
	DBDK_TRACE_EXIT( "fing_tImportText" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. fing_tImportText checksum: 949804374  */

/****************************************************************
**
** Function name:
**
**	fing_tExportText
**
** Description:
**
**	The export function enables bulk copy for user-defined types.
**	When the UNLOAD statement is used from  dbaccess to copy data
**	from  the  database to a  file, the  server calls the  export
**	function  to convert the outcoming  value to the data  type's
**	external format.
**
** Special Comments:
**
**	Support routine for opaque type fing_t returns impexp.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	fing_t *                           The constructed UDT value.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    fing_tExportText FunctionId: fe73ada8-cc7b-11d2-b023-204c4f4f5020
**
*****************************************************************
*/
mi_impexp *
fing_tExportText
(
mi_bitvarying *         Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam                       /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_integer      Gen_CharLen;       /* Maximum character length.          */
	mi_impexp *     Gen_RetVal;        /* The return result.                 */
	fing_t *        Gen_InData;        /* Pointer to the input data.         */
	char *          Gen_OutData;       /* Pointer to the output data.        */
	mi_integer      Gen_DataLen;       /* The final length.                  */
	mi_integer      Gen_vl_nitems;     /* Number of variable length items.   */
	mi_integer      Gen_vl_itemno;     /* Index thru the var length items.   */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in fing_tExportText."
		*/
		DBDK_TRACE_ERROR( "fing_tExportText", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that fing_tExportText has been called.
	*/
	DBDK_TRACE_ENTER( "fing_tExportText" );

	/* Compute the maximum length of the text representation. */
	Gen_CharLen =    1;	/* Leave room for the NULL terminator. */
	/* Compute the number of variable length items. */
	Gen_vl_nitems =
		(mi_get_varlen( (mi_lvarchar *)Gen_param1 ) - sizeof( fing_t ) + sizeof( Gen_InData->data ))
		/ sizeof( Gen_InData->data );


	/* Handle the variable part of the UDT. */
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		Gen_CharLen +=  12;	/* Add the length for Gen_OutData->data[Gen_vl_itemno].X.  */
		Gen_CharLen +=  12;	/* Add the length for Gen_OutData->data[Gen_vl_itemno].Y.  */
		Gen_CharLen +=  12;	/* Add the length for Gen_OutData->data[Gen_vl_itemno].Zeta. */
	}


	Gen_RetVal = (mi_impexp *)mi_new_var( Gen_CharLen );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in fing_tExportText."
		*/
		DBDK_TRACE_ERROR( "fing_tExportText", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

	/* Get a pointer to where our data will be copied to. */
	Gen_OutData = mi_get_vardata( (mi_lvarchar *)Gen_RetVal );


	/* Handle the variable part of the UDT. */
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		/* Format the output value for Gen_InData->data[Gen_vl_itemno].X. */
		sprintf( Gen_OutData, "%d ", Gen_InData->data[Gen_vl_itemno].X );
		Gen_OutData += strlen( Gen_OutData );

		/* Format the output value for Gen_InData->data[Gen_vl_itemno].Y. */
		sprintf( Gen_OutData, "%d ", Gen_InData->data[Gen_vl_itemno].Y );
		Gen_OutData += strlen( Gen_OutData );

		/* Format the output value for Gen_InData->data[Gen_vl_itemno].Zeta. */
		sprintf( Gen_OutData, "%d ", Gen_InData->data[Gen_vl_itemno].Zeta );
		Gen_OutData += strlen( Gen_OutData );

	}


	/*
	** Compute the length of the data and
	** place it in the return structure.
	*/
	Gen_DataLen = (mi_integer)(Gen_OutData - mi_get_vardata( (mi_lvarchar *)Gen_RetVal ));
	mi_set_varlen( (mi_lvarchar *)Gen_RetVal,  Gen_DataLen );

	/*
	** Write to the trace file indicating
	** that fing_tExportText has successfully exited.
	*/
	DBDK_TRACE_EXIT( "fing_tExportText" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. fing_tExportText checksum: 881577260  */

/****************************************************************
**
** Function name:
**
**	fing_tImportBinary
**
** Description:
**
**	The  importbinary  function is  used to  support  bulk copy of
**	binary data. This function is the same as the import function,
**	except that it  operates  on internal  representations of  the
**	data type.  This function is  usually only  provided for large
**	object  data types and is called by the LOAD BINARY command of
**	dbaccess.
**
** Special Comments:
**
**	Support routine for opaque type fing_t returns fing_t.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	fing_t *                           The constructed UDT value.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    fing_tImportBinary FunctionId: fe73ada1-cc7b-11d2-b023-204c4f4f5020
**
*****************************************************************
*/
mi_bitvarying *
fing_tImportBinary
(
mi_bitvarying *         Gen_param1,        /* The input value.                   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_bitvarying * Gen_RetVal;        /* The return result.                 */
	fing_t *        Gen_InData;        /* The UDT input value.               */
	fing_t *        Gen_OutData;       /* The transfer data.                 */
	mi_integer      Gen_vl_nitems;     /* Number of var length items.        */
	mi_integer      Gen_vl_itemno;     /* Index into the var length list.    */
	mi_integer      Gen_vl_len;        /* Length of the var len UDT.         */

	/* Get the current connection. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in fing_tImportBinary."
		*/
		DBDK_TRACE_ERROR( "fing_tImportBinary", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that fing_tImportBinary has been called.
	*/
	DBDK_TRACE_ENTER( "fing_tImportBinary" );

	/* Get the length of the data to follow. */
	Gen_vl_len = mi_get_varlen( (mi_lvarchar *)Gen_param1 );

	/* Compute the number of items in the variable length list. */
	Gen_vl_nitems = (Gen_vl_len - offsetof( fing_t, data )) /
					sizeof( Gen_OutData->data );

	/* Allocate a new UDT for the return result. */
	Gen_RetVal =(mi_bitvarying *) mi_new_var(
					sizeof(fing_t ) +
					(Gen_vl_nitems - 1) *
					sizeof( Gen_OutData->data) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in fing_tImportBinary."
		*/
		DBDK_TRACE_ERROR( "fing_tImportBinary", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the transfer data. */
	Gen_InData = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

	/* Point to the output data. */
	Gen_OutData = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );


	/* Handle the variable part of the UDT. */
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		/* Transfer the data value for Gen_InData->data[Gen_vl_itemno].X. */
		mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->data[Gen_vl_itemno].X, &Gen_OutData->data[Gen_vl_itemno].X );

		/* Transfer the data value for Gen_InData->data[Gen_vl_itemno].Y. */
		mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->data[Gen_vl_itemno].Y, &Gen_OutData->data[Gen_vl_itemno].Y );

		/* Transfer the data value for Gen_InData->data[Gen_vl_itemno].Zeta. */
		mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->data[Gen_vl_itemno].Zeta, &Gen_OutData->data[Gen_vl_itemno].Zeta );

	}

	/*
	** Write to the trace file indicating
	** that fing_tImportBinary has successfully exited.
	*/
	DBDK_TRACE_EXIT( "fing_tImportBinary" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. fing_tImportBinary checksum: 962097104  */

/****************************************************************
**
** Function name:
**
**	fing_tExportBinary
**
** Description:
**
**	The  exportbinary  function  is  used  to  support  bulk  copy  of
**	binary  data.  This function is the same as  the export  function,
**	except that it  operates on  internal  representations of the data
**	type.  This  function is usually only  provided  for large  object
**	data types and is called by the UNLOAD BINARY command of dbaccess.
**
** Special Comments:
**
**	Support routine for opaque type fing_t returns impexpbin.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	fing_t *                           The constructed UDT value.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    fing_tExportBinary FunctionId: fe73ada2-cc7b-11d2-b023-204c4f4f5020
**
*****************************************************************
*/
mi_bitvarying *
fing_tExportBinary
(
mi_bitvarying *         Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_bitvarying * Gen_RetVal;        /* The return value.                  */
	fing_t *        Gen_InData;        /* The transfer data.                 */
	fing_t *        Gen_OutData;       /* The output data.                   */
	mi_integer      Gen_vl_nitems;     /* Number of var length items.        */
	mi_integer      Gen_vl_itemno;     /* Index into the var length input.   */

	/* Get the current connection. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in fing_tExportBinary."
		*/
		DBDK_TRACE_ERROR( "fing_tExportBinary", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that fing_tExportBinary has been called.
	*/
	DBDK_TRACE_ENTER( "fing_tExportBinary" );

	/* Point to the input. */
	Gen_InData = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

	/* Compute the number of variable length items. */
	Gen_vl_nitems =
			(mi_get_varlen( (mi_lvarchar *)Gen_param1 ) - offsetof( fing_t, data )) /
			sizeof( Gen_InData->data );

	/* Allocate the output parcel. */
	Gen_RetVal = (mi_bitvarying *)mi_new_var( sizeof( fing_t ) +
				(Gen_vl_nitems - 1)*sizeof( Gen_InData->data ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in fing_tExportBinary."
		*/
		DBDK_TRACE_ERROR( "fing_tExportBinary", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Set up the output data pointer. */
	Gen_OutData = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

	/* Compute the number of variable length items. */
	Gen_vl_nitems =
		(mi_get_varlen( (mi_lvarchar *)Gen_param1 ) - sizeof( fing_t ) + sizeof( Gen_InData->data ))
		/ sizeof( Gen_InData->data );


	/* Handle the variable part of the UDT. */
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		/* Transfer the data value for Gen_OutData->data[Gen_vl_itemno].X. */
		mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->data[Gen_vl_itemno].X, Gen_InData->data[Gen_vl_itemno].X );

		/* Transfer the data value for Gen_OutData->data[Gen_vl_itemno].Y. */
		mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->data[Gen_vl_itemno].Y, Gen_InData->data[Gen_vl_itemno].Y );

		/* Transfer the data value for Gen_OutData->data[Gen_vl_itemno].Zeta. */
		mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->data[Gen_vl_itemno].Zeta, Gen_InData->data[Gen_vl_itemno].Zeta );

	}


	/*
	** Write to the trace file indicating
	** that fing_tExportBinary has successfully exited.
	*/
	DBDK_TRACE_EXIT( "fing_tExportBinary" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. fing_tExportBinary checksum: 180698909  */

/****************************************************************
**
** Function name:
**
**	fing_tCompare
**
** Description:
**
**	Perform the comparison operations required to compare two
**	UDT values.
**
** Special Comments:
**
**	Support routine for opaque type fing_t returns integer.
**
** Parameters:
**
**	fing_t *        Gen_param1;        The first UDT value to compare.
**	fing_t *        Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_integer                         The comparison result.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    fing_tCompare FunctionId: 9fac02d0-cc80-11d2-b023-204c4f4f5020
**
*****************************************************************
*/
mi_integer
fing_tCompare
(
mi_bitvarying *         Gen_param1,        /* The first UDT value to compare.    */
mi_bitvarying *         Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_integer      Gen_cc;            /* Numeric attribute difference.      */
	mi_integer      Gen_vl_nitems;     /* The number of items.               */
	mi_integer      Gen_vl_itemno;     /* Index thru the items.              */
	mi_integer      Gen_vl_lendif;     /* Data length difference.            */
	fing_t *        Gen_Value1;        /* Pointer to the first value.        */
	fing_t *        Gen_Value2;        /* Pointer to the second value.       */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in fing_tCompare."
		*/
		DBDK_TRACE_ERROR( "fing_tCompare", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that fing_tCompare has been called.
	*/
	DBDK_TRACE_ENTER( "fing_tCompare" );

	/* Point to the data values that are to be compared. */
	Gen_Value1 = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );
	Gen_Value2 = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_param2 );

	/* Compute the difference of the lengths of the two UDTs. */
	Gen_vl_lendif = mi_get_varlen( (mi_lvarchar *)Gen_param1 ) -
	                mi_get_varlen( (mi_lvarchar *)Gen_param1 );

	/* Compute the number of variable length items. */
	Gen_vl_nitems = (Gen_vl_lendif <= 0
		? ( mi_get_varlen( (mi_lvarchar *)Gen_param1) - offsetof( fing_t, data )) / sizeof( Gen_Value1->data )
		: ( mi_get_varlen( (mi_lvarchar *)Gen_param2 ) - offsetof( fing_t, data )) / sizeof( Gen_Value1->data ));


	/* Handle the variable part of the UDT. */
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		/* Compare the two values. */
		Gen_cc = Gen_Value1->data[Gen_vl_itemno].X - Gen_Value2->data[Gen_vl_itemno].X;
		if( Gen_cc )
		{
			return Gen_cc < 0 ? -1 : 1;
		}

		/* Compare the two values. */
		Gen_cc = Gen_Value1->data[Gen_vl_itemno].Y - Gen_Value2->data[Gen_vl_itemno].Y;
		if( Gen_cc )
		{
			return Gen_cc < 0 ? -1 : 1;
		}

		/* Compare the two values. */
		Gen_cc = Gen_Value1->data[Gen_vl_itemno].Zeta - Gen_Value2->data[Gen_vl_itemno].Zeta;
		if( Gen_cc )
		{
			return Gen_cc < 0 ? -1 : 1;
		}

	}
	return Gen_vl_lendif < 0 ? -1 : !Gen_vl_lendif ? 0 : 1;

}
/* Warning: Do not modify. fing_tCompare checksum: 345445121  */

/****************************************************************
**
** Function name:
**
**	fing_tEqual
**
** Description:
**
**	Determine if one UDT value is equal to another.
**
** Special Comments:
**
**	Support routine for opaque type fing_t returns boolean.
**
** Parameters:
**
**	fing_t *        Gen_param1;        The first UDT value to compare.
**	fing_t *        Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                         The comparison result.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    fing_tEqual FunctionId: 9fac02d1-cc80-11d2-b023-204c4f4f5020
**
*****************************************************************
*/
mi_boolean
fing_tEqual
(
mi_bitvarying *         Gen_param1,        /* The first UDT value to compare.    */
mi_bitvarying *         Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(0 == fing_tCompare( Gen_param1,
			Gen_param2, Gen_fparam ));
}
/* Warning: Do not modify. fing_tEqual checksum: 82417920   */

/****************************************************************
**
** Function name:
**
**	fing_tNotEqual
**
** Description:
**
**	Determine if one UDT value is not equal to another.
**
** Special Comments:
**
**	Support routine for opaque type fing_t returns boolean.
**
** Parameters:
**
**	fing_t *        Gen_param1;        The first UDT value to compare.
**	fing_t *        Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                         The comparison result.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    fing_tNotEqual FunctionId: 9fac02d2-cc80-11d2-b023-204c4f4f5020
**
*****************************************************************
*/
mi_boolean
fing_tNotEqual
(
mi_bitvarying *         Gen_param1,        /* The first UDT value to compare.    */
mi_bitvarying *         Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(0 != fing_tCompare( Gen_param1,
			Gen_param2, Gen_fparam ));
}
/* Warning: Do not modify. fing_tNotEqual checksum: 94059944   */

/****************************************************************
**
** Function name:
**
**	HoughIdxInput
**
** Description:
**
**	This function converts from the external representation of the
**	UDT type HoughIdx to its internal representation.   The external
**	representation is a blank-separated list of values and the
**	internal representation is a 'C' structure of type HoughIdx as
**	defined in the header file.
**
**	Data may be inserted into a table using an SQL insert statement:
**
**		insert into tablename values ( 'value-list' );
**
**	value-list is a space-delimited list of values.
**
** Special Comments:
**
**	Support routine for opaque type HoughIdx returns HoughIdx.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	HoughIdx *                         The constructed UDT value.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    HoughIdxInput FunctionId: 1ab5ef50-ce02-11d2-b02a-204c4f4f5020
**
*****************************************************************
*/
HoughIdx *
HoughIdxInput
(
mi_lvarchar *           Gen_param1,        /* Pointer to the input text.         */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	gl_mchar_t *    Gen_InData;        /* Pointer to the input data.         */
	HoughIdx *      Gen_OutData;       /* Pointer to the output data.        */
	mi_integer      Gen_DataLen;       /* Length of the data in bytes.       */
	HoughIdx *      Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in HoughIdxInput."
		*/
		DBDK_TRACE_ERROR( "HoughIdxInput", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that HoughIdxInput has been called.
	*/
	DBDK_TRACE_ENTER( "HoughIdxInput" );

	/* Allocate memory room to build the UDT in. */
	Gen_RetVal = (HoughIdx *)mi_alloc( sizeof( HoughIdx ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in HoughIdxInput."
		*/
		DBDK_TRACE_ERROR( "HoughIdxInput", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = (gl_mchar_t *)mi_get_vardata( Gen_param1 );


	/* Point to the output data. */
	Gen_OutData = (HoughIdx *)Gen_RetVal;

	/* Get the length of the input string. */
	Gen_DataLen = mi_get_varlen( Gen_param1 );

	/* Get the data value for Gen_OutData->S. */
	Gen_InData = Gen_sscanf( Gen_Con, "HoughIdxInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->S );

	/* Get the data value for Gen_OutData->Z. */
	Gen_InData = Gen_sscanf( Gen_Con, "HoughIdxInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Z );

	/* Get the data value for Gen_OutData->X. */
	Gen_InData = Gen_sscanf( Gen_Con, "HoughIdxInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->X );

	/* Get the data value for Gen_OutData->Y. */
	Gen_InData = Gen_sscanf( Gen_Con, "HoughIdxInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Y );


	/*
	** Write to the trace file indicating
	** that HoughIdxInput has successfully exited.
	*/
	DBDK_TRACE_EXIT( "HoughIdxInput" );

	/* Close the connection. */
	mi_close( Gen_Con );

	/* Return the UDT value. */
	return Gen_RetVal;
}
/* Warning: Do not modify. HoughIdxInput checksum: 423219747  */

/****************************************************************
**
** Function name:
**
**	HoughIdxOutput
**
** Description:
**
**	This function converts from the internal representation of the
**	UDT type HoughIdx to its external representation.   The external
**	representation is a blank-separated list of values and the
**	internal representation is a 'C' structure of type HoughIdx as
**	defined in the header file.
**
**	Data may be retrieved from a table using an SQL select statement:
**
**		select * from tablename;
**
** Special Comments:
**
**	Support routine for opaque type HoughIdx returns lvarchar.
**
** Parameters:
**
**	HoughIdx *                         Gen_param1;   Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    HoughIdxOutput FunctionId: 1ab5ef51-ce02-11d2-b02a-204c4f4f5020
**
*****************************************************************
*/
mi_lvarchar *
HoughIdxOutput
(
HoughIdx *              Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_integer      Gen_CharLen;       /* Estimate maximum length.           */
	HoughIdx *      Gen_InData;        /* Pointer to the input data.         */
	char *          Gen_OutData;       /* Pointer to the output data.        */
	mi_lvarchar *   Gen_RetVal;        /* The return result.                 */
	mi_integer      Gen_DataLen;       /* The data length.                   */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in HoughIdxOutput."
		*/
		DBDK_TRACE_ERROR( "HoughIdxOutput", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that HoughIdxOutput has been called.
	*/
	DBDK_TRACE_ENTER( "HoughIdxOutput" );

	/* Compute the maximum length of the text representation. */
	Gen_CharLen =    1;	/* Leave room for the NULL terminator. */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->S.                      */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Z.                      */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->X.                      */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Y.                      */

	/* Allocate room for the output string. */
	Gen_RetVal = mi_new_var( Gen_CharLen );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in HoughIdxOutput."
		*/
		DBDK_TRACE_ERROR( "HoughIdxOutput", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = Gen_param1;

	/* Point to the output data. */
	Gen_OutData = mi_get_vardata( Gen_RetVal );

	/* Format the attribute value into the output string. */

	/* Format the value for Gen_InData->S. */
	sprintf( Gen_OutData, "%d ", Gen_InData->S );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the value for Gen_InData->Z. */
	sprintf( Gen_OutData, "%d ", Gen_InData->Z );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the value for Gen_InData->X. */
	sprintf( Gen_OutData, "%d ", Gen_InData->X );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the value for Gen_InData->Y. */
	sprintf( Gen_OutData, "%d ", Gen_InData->Y );
	Gen_OutData += strlen( Gen_OutData );


	/*
	** Compute the length of the data and
	** place it in the return structure.
	*/
	Gen_DataLen = (mi_integer)(Gen_OutData - mi_get_vardata( Gen_RetVal ));
	mi_set_varlen ( Gen_RetVal, Gen_DataLen );

	/*
	** Write to the trace file indicating
	** that HoughIdxOutput has successfully exited.
	*/
	DBDK_TRACE_EXIT( "HoughIdxOutput" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. HoughIdxOutput checksum: 202687289  */

/****************************************************************
**
** Function name:
**
**	box
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine Box (fing_t) returns HoughIdx.
**
** Parameters:
**
** Return value:
**
**	HoughIdx *
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    box FunctionId: b38ed351-d118-11d2-b037-204c4f4f5020
**
*****************************************************************
*/
HoughIdx *
box
(
mi_bitvarying *	Arg1,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle.             */
	HoughIdx *      Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in box."
		*/
		DBDK_TRACE_ERROR( "box", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that box has been called.
	*/
	DBDK_TRACE_ENTER( "box" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this function.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Function box has not been implemented." );

	/*
	** TO DO: Compute and store your value into Gen_RetVal.
	**        The call to mi_fp_setreturnisnull informs the
	**        server that the return value is NULL.
	*/
	mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
	Gen_RetVal = 0;

	/*
	** Write to the trace file indicating
	** that box has successfully exited.
	*/
	DBDK_TRACE_EXIT( "box" );

	return Gen_RetVal;
}
/* Warning: Do not modify. box checksum: 356381376  */

/****************************************************************
**
** Function name:
**
**	Hough1
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine Hough1 (fing_t,fing_t) returns HoughIdx.
**
** Parameters:
**
** Return value:
**
**	HoughIdx *
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    Hough1 FunctionId: 23468d10-cdf5-11d2-b02a-204c4f4f5020
**
*****************************************************************
*/
HoughIdx *
Hough1
(
mi_bitvarying *	Arg1,
mi_bitvarying *	Arg2,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle.             */
	HoughIdx *      Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in Hough1."
		*/
		DBDK_TRACE_ERROR( "Hough1", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that Hough1 has been called.
	*/
	DBDK_TRACE_ENTER( "Hough1" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this function.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Function Hough1 has not been implemented." );

	/*
	** TO DO: Compute and store your value into Gen_RetVal.
	**        The call to mi_fp_setreturnisnull informs the
	**        server that the return value is NULL.
	*/
	mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
	Gen_RetVal = 0;

	/*
	** Write to the trace file indicating
	** that Hough1 has successfully exited.
	*/
	DBDK_TRACE_EXIT( "Hough1" );

	return Gen_RetVal;
}
/* Warning: Do not modify. Hough1 checksum: 165599318  */

/****************************************************************
**
** Function name:
**
**	score2
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine score2 (fing_t,fing_t) returns double precision.
**
** Parameters:
**
** Return value:
**
**	mi_double_precision *
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    score2 FunctionId: 203c7d20-d36a-11d2-b042-204c4f4f5020
**
*****************************************************************
*/
mi_double_precision *
score2
(
mi_bitvarying *	Arg1,
mi_bitvarying *	Arg2,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	mi_double_precision *              Gen_RetVal;   /* The return value. */
	MI_CONNECTION * Gen_Con;           /* The connection handle. */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in score2."
		*/
		DBDK_TRACE_ERROR( "score2", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that score2 has been called.
	*/
	DBDK_TRACE_ENTER( "score2" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this function.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Function score2 has not been implemented." );

	/*
	** Allocate the return value.  It must be
	** allocated if it is a UDT or type whose
	** size is greater than 4 bytes.
	*/
	Gen_RetVal = (mi_double_precision *)mi_alloc( sizeof( mi_double_precision * ) );
	if( Gen_RetVal == 0)
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in score2."
		*/
		DBDK_TRACE_ERROR( "score2", ERRORMESG2, 10 );

		/* not reached */
	}

	/* TO DO: Compute and store your value into Gen_RetVal. */
	*Gen_RetVal = 0;

	/*
	** Write to the trace file indicating
	** that score2 has successfully exited.
	*/
	DBDK_TRACE_EXIT( "score2" );

	return Gen_RetVal;
}
/* Warning: Do not modify. score2 checksum: 716255067  */

/****************************************************************
**
** Function name:
**
**	Hough2
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine Hough2 (fing_t,fing_t) returns fing_t.
**
** Parameters:
**
** Return value:
**
**	mi_bitvarying *
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    Hough2 FunctionId: 23468d11-cdf5-11d2-b02a-204c4f4f5020
**
*****************************************************************
*/
mi_bitvarying *
Hough2
(
mi_bitvarying *	Arg11,
mi_bitvarying *	Arg22,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle.             */
	mi_bitvarying * Gen_RetVal;        /* The return value wrapper.          */
	fing_t *        Gen_OutData;       /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in Hough2."
		*/
		DBDK_TRACE_ERROR( "Hough2", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that Hough2 has been called.
	*/
	DBDK_TRACE_ENTER( "Hough2" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this function.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Function Hough2 has not been implemented." );

	/*
	** Allocate the return value.  It must be  allo-
	** cated if it is a variable length UDT.
	**
	** N.B.:  The amount of memory that is allocated
	**        here by default may be insufficient to
	**        hold the contents of the return value.
	**        This  size  may  need to  be adjusted.
	**
	** TO DO: Adjust the amount  of memory  required
	**        for the return value.
	*/
	Gen_RetVal = (mi_bitvarying *)mi_new_var( sizeof( fing_t ) );
	if( Gen_RetVal == 0)
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in Hough2."
		*/
		DBDK_TRACE_ERROR( "Hough2", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to where the return value is to be placed. */
	Gen_OutData = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

	/*
	**	TO DO: Replace this line with code that
	**	       computes the return value.
	*/
	*(char *)Gen_OutData = 0;

	/*
	** Write to the trace file indicating
	** that Hough2 has successfully exited.
	*/
	DBDK_TRACE_EXIT( "Hough2" );

	return Gen_RetVal;
}
/* Warning: Do not modify. Hough2 checksum: 105441219  */

/****************************************************************
**
** Function name:
**
**	score
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine score (fing_t,fing_t) returns double precision.
**
** Parameters:
**
** Return value:
**
**	mi_double_precision *
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    score FunctionId: bafa51d0-c0a0-11d2-806f-204c4f4f5020
**
*****************************************************************
*/
mi_double_precision *
score
(
mi_bitvarying *	query,
mi_bitvarying *	reference,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	mi_double_precision *              Gen_RetVal;   /* The return value. */
	MI_CONNECTION * Gen_Con;           /* The connection handle. */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in score."
		*/
		DBDK_TRACE_ERROR( "score", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that score has been called.
	*/
	DBDK_TRACE_ENTER( "score" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this function.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Function score has not been implemented." );

	/*
	** Allocate the return value.  It must be
	** allocated if it is a UDT or type whose
	** size is greater than 4 bytes.
	*/
	Gen_RetVal = (mi_double_precision *)mi_alloc( sizeof( mi_double_precision * ) );
	if( Gen_RetVal == 0)
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in score."
		*/
		DBDK_TRACE_ERROR( "score", ERRORMESG2, 10 );

		/* not reached */
	}

	/* TO DO: Compute and store your value into Gen_RetVal. */
	*Gen_RetVal = 0;

	/*
	** Write to the trace file indicating
	** that score has successfully exited.
	*/
	DBDK_TRACE_EXIT( "score" );

	return Gen_RetVal;
}
/* Warning: Do not modify. score checksum: 214934375  */

/****************************************************************
**
** Function name:
**
**	Hough1_1
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine Hough1_1 (fing_t,fing_t) returns HoughIdx.
**
** Parameters:
**
** Return value:
**
**	HoughIdx *
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    Hough1_1 FunctionId: 42671e00-d055-11d2-b035-204c4f4f5020
**
*****************************************************************
*/
HoughIdx *
Hough1_1
(
mi_bitvarying *	Arg1,
mi_bitvarying *	Arg2,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle.             */
	HoughIdx *      Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in Hough1_1."
		*/
		DBDK_TRACE_ERROR( "Hough1_1", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that Hough1_1 has been called.
	*/
	DBDK_TRACE_ENTER( "Hough1_1" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this function.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Function Hough1_1 has not been implemented." );

	/*
	** TO DO: Compute and store your value into Gen_RetVal.
	**        The call to mi_fp_setreturnisnull informs the
	**        server that the return value is NULL.
	*/
	mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
	Gen_RetVal = 0;

	/*
	** Write to the trace file indicating
	** that Hough1_1 has successfully exited.
	*/
	DBDK_TRACE_EXIT( "Hough1_1" );

	return Gen_RetVal;
}
/* Warning: Do not modify. Hough1_1 checksum: 569250325  */

/*****************************************************************
**
** Function name:
**
**	Gen_sscanf
**
** Description:
**
**	This function converts formatted values.  The types converted are:
**
**		Type                    Format
**		==============================
**		gl_mchar_t                %C
**		mi_boolean                %b
**		mi_char                   %c
**		mi_date                   %D
**		mi_datetime               %T
**		mi_decimal/mi_numeric     %N
**		mi_double_precision       %lf
**		mi_int8                   %8
**		mi_integer                %d
**		mi_interval               %I
**		mi_long                   %ld
**		mi_money                  %m
**		mi_real                   %f
**		mi_unsigned_integer       %x
**
**	Conversion is performed from GLS text to the corresponding binary
**	representation.  The GLS text is assumed to be in the server locale.
**
**	Addition information about these data types may be found in
**	The Informix Guide to SQL: Syntax - Version 9.01.
**
** Parameters:
**
**	MI_CONNECTION * Gen_Con            The database connection.
**	char *          Gen_Caller         Name of the calling function.
**	gl_mchar_t *    Gen_InData         The input string data.
**	mi_integer      Gen_InDataLen      The length of Gen_InData.
**	mi_integer      Gen_Width          Max length if data is text.
**	char *          Gen_Format         The data's format.
**	char *          Gen_Result         Place the result here.
**
** Return value:
**
**	gl_mchar_t *                       The new scan position.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    Gen_sscanf FunctionId: 3AC0E360-5A81-11d0-A2E7-00AA0009BF87
**
******************************************************************
*/
gl_mchar_t *
Gen_sscanf
(
MI_CONNECTION *         Gen_Con,           /* The database connection.           */
char *                  Gen_Caller,        /* Name of the calling function.      */
gl_mchar_t *            Gen_InData,        /* The input string data.             */
mi_integer              Gen_InDataLen,     /* The length of Gen_InData.          */
mi_integer              Gen_Width,         /* Max length if data is text.        */
char *                  Gen_Format,        /* The data's format.                 */
char *                  Gen_Result         /* Place the result here.             */
)
{
	gl_mchar_t *    Gen_In;            /* Scanning ptr.                      */
	gl_mchar_t *    Gen_SaveIn;        /* Save Gen_In here.                  */
	gl_mchar_t      Gen_NextChar;      /* Get the next char here.            */
	char *          Gen_InStart;       /* Gen_In before advancement.         */
	gl_mchar_t *    Gen_Out;           /* Place the GLS result here.         */
	mi_integer      Gen_ByteCount;     /* The number of bytes.               */

	Gen_In        = Gen_InData;
	Gen_Out       = (gl_mchar_t *)Gen_Result;
	Gen_ByteCount = 0;

	/* Scan past non-format characters. */
	while( *Gen_Format && *Gen_In )
	{
		/* Scan past and ignore white space in the data. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-blank. */
			if( !ifx_gl_ismblank( Gen_In, 4 ) )
			{
				break;
			}

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );
		}

		/* Check for the format character. */
		if( *Gen_Format == '%' )
		{
			break;
		}

		/*
		**	The format character and the input string
		**	must match up to the format character.
		**	If not, issue a message.
		*/
		if( *(char *)Gen_In != *Gen_Format )
		{
			goto parse_error;
		}

		/* Keep track of how far we've advanced. */
		Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

		/* Advance to the next character. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/* Advance to the next character. */
		++Gen_Format;
	}

	/*	Check for no input data string. */
	if( *(char *)Gen_In == '\0' )
	{
		goto parse_error;
	}

	/* The following code now handles the various format types. */

	if( !strncmp( Gen_Format, "%s %n", 5 ) && Gen_Width )
	{
		if( '"' != *Gen_In )
		{
			/*
			** Input parsing has failed so issue
			** the following message and quit.
			**
			** 	"Double-quoted string expected
			**	 in input in <Gen_Caller>."
			*/
			DBDK_TRACE_ERROR( Gen_Caller, ERRORMESG7, 10 );

			/* not reached */
		}

		/* Advance past the leading quote. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/* Copy while there's sufficient room. */
		while( Gen_Width )
		{
			Gen_InStart = (char *)Gen_In;

			switch( *Gen_In )
			{
				/*
				** If '"' is seen, check to see
				** if the next character is also
				** a '"'. If so, '"' is embedded.
				** Otherwise, it is EOS.
				*/
				case '"':
					Gen_SaveIn = Gen_In;
					Gen_NextChar = *ifx_gl_mbsnext( Gen_In, 4 );
					Gen_In = Gen_SaveIn;
					if( Gen_NextChar == '"' )
					{
						*Gen_Out++ = '"';

						/* Advance past the first quote. */
						Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

						/* Advance past the second space. */
						Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

						break;
					}

					*Gen_Out = (char)'\0';

					/* Advance past the trailing quote. */
					Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

					/* Advance past the trailing space. */
					Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

					return Gen_In;

				case '\0':
					/*
					** Input parsing has failed so issue
					** the following message and quit.
					**
					** 	"Input string is not terminated with double-quote
					**	 in <Gen_Caller>."
					*/
					DBDK_TRACE_ERROR( Gen_Caller, ERRORMESG9, 10 );

					/* not reached */

				default:
					*Gen_Out++ = *Gen_In;
					Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
					Gen_Width -= (char *)Gen_In - Gen_InStart;

					break;
			}
		}

		/*
		** Input parsing has failed so issue
		** the following message and quit.
		**
		** 	"Input string is too long in <Gen_Caller>."
		*/
		DBDK_TRACE_ERROR( Gen_Caller, ERRORMESG10, 10 );

		/* not reached */
	}

	/* Check for an mi_integer. */
	else if( !strncmp( Gen_Format, "%d %n", 5 ) )
	{
		mi_decimal   Gen_dec_number;  /* Store an mi_decimal value here. */

		/* Convert the GLS string to a decimal value. */
		if( ifx_gl_convert_number( &Gen_dec_number, (char *)Gen_In, "%d" ) == -1 )
		{
			goto parse_error;
		}

		/* Convert the decimal to a 'C' integer. */
		if( dectoint( &Gen_dec_number, (int *)Gen_Result ) != 0 )
		{
			goto parse_error;
		}

		/* Scan past the mi_integer value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'                ||
				 *Gen_In == 'E'                ||
				 *Gen_In == '.'                ||
				 *Gen_In == '+'                ||
				 *Gen_In == '-')               )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for a double value. */
	else if( !strncmp( Gen_Format, "%lf %n", 6 ) )
	{
		mi_decimal   Gen_dec_number;  /* Store an mi_decimal value here. */

		/* Convert the GLS string to a decimal value. */
		if( ifx_gl_convert_number( &Gen_dec_number, (char *)Gen_In, "%e" ) == -1 )
		{
			goto parse_error;
		}

		/* Convert the decimal to a 'C' double. */
		if( dectodbl( &Gen_dec_number, (double *)Gen_Result ) != 0 )
		{
			goto parse_error;
		}

		/* Scan past the number. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'                ||
				 *Gen_In == 'E'                ||
				 *Gen_In == '.'                ||
				 *Gen_In == '+'                ||
				 *Gen_In == '-')               )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 6;
	}

	/* Check for a float value. */
	else if( !strncmp( Gen_Format, "%f %n", 5 ) )
	{
		mi_double_precision Gen_dbl_number; /* Store an mi_float value here.   */
		mi_decimal          Gen_dec_number; /* Store an mi_decimal value here. */

		/* Convert the GLS string to a decimal value. */
		if( ifx_gl_convert_number( &Gen_dec_number, (char *)Gen_In, "%e" ) == -1 )
		{
			goto parse_error;
		}

		/* Convert the decimal to a 'C' float. */
		if( dectodbl( &Gen_dec_number, &Gen_dbl_number ) != 0 )
		{
			goto parse_error;
		}
		*(float *)Gen_Result = (float)Gen_dbl_number;

		/* Scan past the float value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'                ||
				 *Gen_In == 'E'                ||
				 *Gen_In == '.'                ||
				 *Gen_In == '+'                ||
				 *Gen_In == '-')               )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for a long value. */
	else if( !strncmp( Gen_Format, "%ld %n", 6 ) )
	{
		mi_decimal   Gen_dec_number;  /* Store an mi_decimal value here. */

		/* Convert the GLS string to a decimal value. */
		if( ifx_gl_convert_number( &Gen_dec_number, (char *)Gen_In, "%d" ) == -1 )
		{
			goto parse_error;
		}

		/* Convert the decimal to a 'C' long. */
		if( dectolong( &Gen_dec_number, (long *)Gen_Result ) != 0 )
		{
			goto parse_error;
		}

		/* Scan past the long value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'                ||
				 *Gen_In == 'E'                ||
				 *Gen_In == '.'                ||
				 *Gen_In == '+'                ||
				 *Gen_In == '-')               )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 6;
	}

	/* Check for an int8 value. */
	else if( !strncmp( Gen_Format, "%8 %n", 5 ) )
	{
		gl_mchar_t * Gen_Int8Ptr;     /* Scanning pointer.             */
		gl_mchar_t * Gen_Int8Ptr2;    /* Scanning pointer.             */
		mi_integer   Gen_Int8Index;   /* Keep track of the length.     */
		mi_integer   Gen_Int8Ret;     /* ifx_int8cvasc return value.   */
		char         Gen_Int8Str[80]; /* Hold the mi_int8 string here. */

		/*
		** Transfer the data value to a NULL terminated
		** buffer for conversion by ifx_int8cvasc.
		*/
		for( Gen_Int8Ptr   = (gl_mchar_t *)Gen_Int8Str,
			 Gen_Int8Ptr2  = Gen_In,
			 Gen_Int8Index = 0;
				Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_Int8Index;
			++Gen_ByteCount;
		}

		/* Copy the string and terminate. */
		ifx_gl_mbscpy( (gl_mchar_t *)Gen_Int8Str, Gen_Int8Ptr2,
				(int)(Gen_InData - Gen_Int8Ptr2) );
		Gen_Int8Str[Gen_InData - Gen_Int8Ptr2] = (char)'\0';

		/* Check for an empty string. */
		if( Gen_Int8Index == 0 )
		{
			goto parse_error;
		}

		/* Convert the mi_int8 value from text to internal format. */
		Gen_Int8Ret = ifx_int8cvasc( Gen_Int8Str, strlen( Gen_Int8Str ),
		                             (ifx_int8_t *)&Gen_Result );
		if( Gen_Int8Ret )
		{
			goto parse_error;
		}

		/* Scan past the int8 value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'                ||
				 *Gen_In == 'E'                ||
				 *Gen_In == '.'                ||
				 *Gen_In == '+'                ||
				 *Gen_In == '-')               )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/*
	** Check for a boolean value.  Only 'T' or 't'
	** (for True) and  'F' or 'f' (for False)  are
	** accepted.
	*/
	else if( !strncmp( Gen_Format, "%b %n", 5 ) )
	{
		if( *(char *)Gen_In == 'T' || *(char *)Gen_In == 't' )
		{
			*(char *)Gen_Result = 1;
		}
		else if( *(char *)Gen_In == 'F' || *(char *)Gen_In == 'f' )
		{
			*(char *)Gen_Result = 0;
		}
		else
		{
			goto parse_error;
		}

		Gen_ByteCount += sizeof(char);

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an unsigned int value. */
	else if( !strncmp( Gen_Format, "%x %n", 5 ) )
	{
		mi_decimal Gen_dec_number; /* Store an mi_decimal value here. */

		/* Convert the GLS string to a decimal value. */
		if( ifx_gl_convert_number( &Gen_dec_number, (char *)Gen_In, "%u" ) == -1 )
		{
			goto parse_error;
		}

		/* Convert the decimal to a 'C' unsigned integer. */
		if( dectoint( &Gen_dec_number, (int *)Gen_Result ) != 0 )
		{
			goto parse_error;
		}

		/* Scan past the unsigned int value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'                ||
				 *Gen_In == 'E'                ||
				 *Gen_In == '.'                ||
				 *Gen_In == '+'                ||
				 *Gen_In == '-')               )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for a multibyte character. */
	else if( !strncmp( Gen_Format, "%C %n", 5 ) )
	{
		/* Copy the entire multibyte character. */
		Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );
		memcpy( Gen_Result, Gen_In, Gen_ByteCount );

		/* Scan to trailing white space. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-blank. */
			if( !ifx_gl_ismblank( Gen_In, 4 ) )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_money value. */
	else if( !strncmp( Gen_Format, "%m %n", 5 ) )
	{
		gl_mchar_t *   Gen_MoneyPtr;     /* Scanning pointer.                */
		gl_mchar_t *   Gen_MoneyPtr2;    /* Scanning pointer.                */
		mi_lvarchar *  Gen_MoneyLV;      /* mi_lvarchar ptr to Gen_MoneyStr. */
		mi_money *     Gen_MoneyVal;     /* The binary money value.          */
		mi_integer     Gen_MoneyIndex;   /* Keep track of the length.        */
		char           Gen_MoneyStr[80]; /* Hold the mi_money string here.   */

		/*
		** Transfer the data value to a NULL terminated
		** buffer for conversion by mi_money_to_binary.
		*/
		for( Gen_MoneyPtr   = (gl_mchar_t *)Gen_MoneyStr,
			 Gen_MoneyPtr2  = Gen_In,
			 Gen_MoneyIndex = 0;
				Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_MoneyIndex;
			++Gen_ByteCount;
		}

		/* Copy the string and terminate. */
		ifx_gl_mbscpy( (gl_mchar_t *)Gen_MoneyStr, Gen_MoneyPtr2,
					(int)(Gen_In - Gen_MoneyPtr2) );
		Gen_MoneyStr[Gen_In - Gen_MoneyPtr2] = (char)'\0';

		/* Check for an empty string. */
		if( Gen_MoneyIndex == 0 )
		{
			goto parse_error;
		}

		/* Convert the money string to mi_lvarchar. */
		Gen_MoneyLV = mi_string_to_lvarchar( Gen_MoneyStr );

		/* Check for an error in conversion. */
		if( Gen_MoneyLV == 0 )
		{
			goto parse_error;
		}

		/* Convert the money string to internal format. */
		Gen_MoneyVal = mi_money_to_binary( Gen_MoneyLV );

		/* Check for an error in conversion. */
		if( Gen_MoneyVal == NULL )
		{
			goto parse_error;
		}

		/* Copy to the UDT data area. */
		memcpy( Gen_Result, Gen_MoneyVal, sizeof(mi_money) );

		/* ... and free the temporary money data values. */
		mi_free( Gen_MoneyLV );
		mi_free( Gen_MoneyVal );

		/* Scan past the money value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'                ||
				 *Gen_In == 'E'                ||
				 *Gen_In == '.'                ||
				 *Gen_In == '+'                ||
				 *Gen_In == '-')               )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_numeric/mi_decimal value. */
	else if( !strncmp( Gen_Format, "%N %n", 5 ) )
	{
		gl_mchar_t * Gen_DecPtr;     /* Scanning pointer.                */
		gl_mchar_t * Gen_DecPtr2;    /* Scanning pointer.                */
		mi_decimal   Gen_DecVal;     /* The binary decimal value.        */
		mi_integer   Gen_DecIndex;   /* Keep track of the length.        */
		mi_integer   Gen_DecRet;     /* deccvasc return value.           */
		char         Gen_DecStr[80]; /* Hold the mi_decimal string here. */

		/*
		** Transfer the data value to a NULL terminated
		** buffer for conversion by deccvasc.
		*/
		for( Gen_DecPtr   = (gl_mchar_t *)Gen_DecStr,
			 Gen_DecPtr2  = Gen_In,
			 Gen_DecIndex = 0;
				Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_DecIndex;
			++Gen_ByteCount;
		}

		/* Copy the string and terminate. */
		ifx_gl_mbscpy( (gl_mchar_t *)Gen_DecStr, Gen_DecPtr2,
					(int)(Gen_In - Gen_DecPtr2) );
		Gen_DecStr[Gen_In - Gen_DecPtr2] = (char)'\0';

		/* Check for an empty string. */
		if( Gen_DecIndex == 0 )
		{
			goto parse_error;
		}

		/* Convert the mi_decimal value from text to internal format. */
		Gen_DecRet = deccvasc( Gen_DecStr, strlen( Gen_DecStr ), &Gen_DecVal );

		/* Check for an error in conversion. */
		if( Gen_DecRet )
		{
			goto parse_error;
		}

		/* Copy to the UDT data area. */
		memcpy( Gen_Result, &Gen_DecVal, sizeof(mi_decimal) );

		/* Scan past the decimal value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'                ||
				 *Gen_In == 'E'                ||
				 *Gen_In == '.'                ||
				 *Gen_In == '+'                ||
				 *Gen_In == '-')               )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_date value. */
	else if( !strncmp( Gen_Format, "%D %n", 5 ) )
	{
		gl_mchar_t * Gen_DatePtr;     /* Scanning pointer.             */
		gl_mchar_t * Gen_DatePtr2;    /* Scanning pointer.             */
		long         Gen_DateVal;     /* The binary date value.        */
		mi_integer   Gen_DateIndex;   /* Keep track of the length.     */
		mi_integer   Gen_RstrdateRet; /* rstrdate return value.        */
		char         Gen_DateStr[80]; /* Hold the mi_date string here. */

		/*
		** Transfer the data value to a NULL terminated
		** buffer for conversion by rstrdate.
		*/
		for( Gen_DatePtr   = (gl_mchar_t *)Gen_DateStr,
			 Gen_DatePtr2  = Gen_In,
			 Gen_DateIndex = 0;
				Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_DateIndex;
			++Gen_ByteCount;
		}

		/* Copy the string and terminate. */
		ifx_gl_mbscpy( (gl_mchar_t *)Gen_DateStr, Gen_DatePtr2,
					(int)(Gen_In - Gen_DatePtr2) );
		Gen_DateStr[Gen_In - Gen_DatePtr2] = (char)'\0';

		/* Check for an empty string. */
		if( Gen_DateIndex == 0 )
		{
			goto parse_error;
		}

		/* Convert the date string to internal format. */
		Gen_RstrdateRet = rstrdate( Gen_DateStr, &Gen_DateVal );

		/* Check for an error in conversion. */
		if( Gen_RstrdateRet )
		{
			goto parse_error;
		}

		/* Copy to the UDT data area. */
		memcpy( Gen_Result, &Gen_DateVal, sizeof(mi_date) );

		/* Scan past the date string. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !ifx_gl_ismdigit( Gen_In, 4 ) )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_datetime value. */
	else if( !strncmp( Gen_Format, "%T %n", 5 ) )
	{
		gl_mchar_t * Gen_DTPtr;      /* Scanning pointer.             */
		gl_mchar_t * Gen_DTPtr2;     /* Scanning pointer.             */
		mi_datetime  Gen_DTVal;      /* The binary date value.        */
		mi_integer   Gen_DTIndex;    /* Keep track of the length.     */
		int          Gen_Blanks;     /* Number of blanks scanned.     */
		int          Gen_DtcvascRet; /* dtcvasc return value.         */
		char         Gen_DTStr[80];  /* Hold the mi_date string here. */

		/*
		** Transfer the data value to a NULL terminated
		** buffer for conversion by dtcvasc.
		*/
		for( Gen_DTPtr   = (gl_mchar_t *)Gen_DTStr,
			 Gen_DTPtr2  = Gen_In,
			 Gen_Blanks  = 0,
			 Gen_DTIndex = 0;
				Gen_In < Gen_InData + Gen_InDataLen; )
		{
			/* Stop at the second blank. */
			if( ifx_gl_ismblank( Gen_In, 4 ) && ++Gen_Blanks == 2 )
			{
				break;
			}

			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_DTIndex;
			++Gen_ByteCount;
		}

		/* Copy the string and terminate. */
		ifx_gl_mbscpy( (gl_mchar_t *)Gen_DTStr, Gen_DTPtr2,
					(int)(Gen_In - Gen_DTPtr2) );
		Gen_DTStr[Gen_In - Gen_DTPtr2] = (char)'\0';

		/* Check for an empty string. */
		if( Gen_DTIndex == 0 )
		{
			goto parse_error;
		}

		/*
		** Set the  mi_datetime  qualifier.   It is
		** copied from the return value's qualifier.
		*/
		Gen_DTVal.dt_qual = ((mi_datetime *)Gen_Result)->dt_qual;

		/* Convert the mi_datetime value to internal format. */
		Gen_DtcvascRet = dtcvasc( Gen_DTStr, &Gen_DTVal );

		/* Check to insure that the conversion was successful. */
		if( Gen_DtcvascRet )
		{
			goto parse_error;
		}

		/* Copy to the UDT data area. */
		memcpy( Gen_Result, &Gen_DTVal, sizeof(mi_datetime) );

		/* Scan past the datetime string. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !ifx_gl_ismdigit( Gen_In, 4 ) )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Handle all other types using sscanf. */
	else if( 1 != sscanf( (char *)Gen_In, Gen_Format, Gen_Out, &Gen_ByteCount ) )
	{
		goto parse_error;
	}

	/* Satisfy any remaining non-format characters in the format string. */
	while( *Gen_Format && *Gen_In )
	{
		/* Scan past trailing white space in the data. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-blank. */
			if( !ifx_gl_ismblank( Gen_In, 4 ) )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Check for the format character. */
		if( *Gen_Format != *(char *)Gen_In )
		{
			break;
		}

		/*
		**	The non-format character and the input data
		**	must match. If not, issue a message.
		*/
		if( *(char *)Gen_In != *Gen_Format )
		{
			goto parse_error;
		}

		/* Keep track of how far we've advanced. */
		Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

		/* Advance to the next character. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/* Advance to the next character. */
		++Gen_Format;
	}

	/*	** Finally, scan past trailing spaces
	** and non-format characters.
	*/

	/* Scan past trailing white space in the data. */
	while( Gen_In < Gen_InData + Gen_InDataLen )
	{
		/* Stop at the first non-blank. */
		if( !ifx_gl_ismblank( Gen_In, 4 ) )
		{
			break;
		}

		/* Keep track of how far we've advanced. */
		Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

		/* Advance to the next character. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
	}

	return Gen_InData + Gen_ByteCount;

parse_error:

	/*
	** Input parsing has failed so issue
	** the following message and quit.
	**
	** 	"Input data format error in <Gen_Caller>."
	*/
	DBDK_TRACE_ERROR( Gen_Caller, ERRORMESG11, 10 );

	/* not reached */
}
/* Warning: Do not modify. Gen_sscanf checksum: 90927202   */

/********************************************************************
**
** Function name:
**
**	Gen_nstrwords
**
** Description:
**
**	This function counts the number of values in a formatted string.
**
** Parameters:
**
**	gl_mchar_t *    Gen_InData         The data to scan.
**	mi_integer      Gen_InDataLen      Length of the data.
**
** Return value:
**
**	mi_integer                         The new scan position.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    Gen_nstrwords FunctionId: 3AC0E361-5A81-11d0-A2E7-00AA0009BF87
**
*********************************************************************
*/
mi_integer
Gen_nstrwords
(
gl_mchar_t *            Gen_InData,        /* The data to scan.                  */
mi_integer              Gen_InDataLen      /* Length of the data.                */
)
{
	mi_integer      Gen_WordCount;     /* The number of words present.       */
	gl_mchar_t *    Gen_In;            /* Scanning pointer.                  */
	char *          Gen_DataCopy;      /* A NULL terminated copy.            */
	enum
	{
		DBDK_QUOTE,
		DBDK_ESCAPE,
		DBDK_WORD,
		DBDK_SPACE
	} Gen_state;    /* Parsing state.	*/

	/* Copy the data and NULL terminate it. */
	Gen_DataCopy = (char *)mi_alloc(Gen_InDataLen + 1);
	memcpy(Gen_DataCopy, Gen_InData, Gen_InDataLen);
	Gen_DataCopy[Gen_InDataLen] = (char)'\0';
	Gen_InData = (gl_mchar_t *)Gen_DataCopy;

	/* Begin counting the words. */
	Gen_WordCount = 0;

	/* Set the initial state. */
	Gen_state = DBDK_SPACE;

	/* Point to the beginning of the input text. */
	Gen_In = Gen_InData;

	do
	{
		switch ( Gen_state )
		{
			case DBDK_ESCAPE:
				Gen_state = DBDK_QUOTE;
				break;

			case DBDK_QUOTE:
				if( '"' == *Gen_In )
				{
					Gen_state = DBDK_SPACE;
				}
				break;

			case DBDK_WORD:
				if( '"' == *Gen_In )
				{
					Gen_WordCount++, Gen_state = DBDK_QUOTE;
				}
				else if( ifx_gl_ismspace( Gen_In, 4 ) )
				{
					Gen_state = DBDK_SPACE;
				}
				break;

			case DBDK_SPACE:
				if( '"' == *Gen_In )
				{
					Gen_WordCount++, Gen_state = DBDK_QUOTE;
				}
				else if( !ifx_gl_ismspace( Gen_In, 4 ) )
				{
					Gen_WordCount++, Gen_state = DBDK_WORD;
				}
				break;
		}

		/* Advance the pointer. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
	}
	while( *Gen_In != '\0' );

	/* Free the copy of the data. */
	mi_free(Gen_DataCopy);

	return Gen_WordCount;
}
/* Warning: Do not modify. Gen_nstrwords checksum: 992950442  */

/*************************************************************************
**
** Function name:
**
**	Gen_Trace
**
** Description:
**
**	This function writes trace information to the trace file.
**
**	Complete information about tracing may be found in
**	the INFORMIX-DataBlade API, User's Guide, Version 9.0.
**
**	To enable tracing, you must first create a trace class
**	by inserting a record into the systraceclasses system
**	catalog:
**
**		insert into informix.systraceclasses(name)
**		values('Fingerprint');
**
**	The name of the trace file must be set. If the file name
**	is not set, the server uses a default file name:
**	the session id followed by ".trc" in the /tmp directory.
**	Use "onstat -g ses" to get the session id.
**
**	The following code snippet may be used to set the name
**	of the output trace file from within your code.
**
**		mi_tracefile_set( "/yourpath/yourfile.trc" );
**
**	Alternately, the TraceSet_Fingerpri procedure may be
**	used from SQL to set the trace file name and trace threshold
**	level.  See this procedure for more details.
**
**	To insure that tracing text  actually  appears in the
**	output trace file, SERVER_LOCALE, CLIENT_LOCALE,  and
**	DB_LOCALE must be set in the environment to the
**	appropriate locale (e.g., "en_us.1252").
**
** Parameters:
**
**	MI_CONNECTION * Gen_Con            The database connection.
**	char *          Gen_Caller         Call originated from this routine.
**	char *          Gen_FileName       Call originated in this file.
**	mi_integer      Gen_LineNo         Call originated on this line.
**	char *          Gen_MsgNo          ERRORMESG number.
**	char *          Gen_Class          Tracing class.
**	mi_integer      Gen_Threshold      Tracing threshold.
**	mi_integer      Gen_MsgType        MI_SQL | MI_MESSAGE | DBDK_TRACE.
**
** Return value:
**
**	None.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    Gen_Trace FunctionId: 59DEDB71-760B-11d0-A2EC-00AA0009BF87
**
*************************************************************************
*/
void
Gen_Trace
(
MI_CONNECTION *         Gen_Con,           /* The database connection.           */
char *                  Gen_Caller,        /* Call originated from this routine. */
char *                  Gen_FileName,      /* Call originated in this file.      */
mi_integer              Gen_LineNo,        /* Call originated on this line.      */
char *                  Gen_MsgNo,         /* ERRORMESG number.                  */
char *                  Gen_Class,         /* Tracing class.                     */
mi_integer              Gen_Threshold,     /* Tracing threshold.                 */
mi_integer              Gen_MsgType        /* MI_SQL | MI_MESSAGE | DBDK_TRACE.  */
)
{
	/* Route the message to the trace file? */
	if( Gen_MsgType & DBDK_TRACE )
	{
		/* Write the message to the trace file. */
		GL_DPRINTF( Gen_Class,
		            Gen_Threshold,
		            (
		                Gen_MsgNo,
		                "FUNCTION%s", Gen_Caller,      /* Substitute the caller here.    */
		                "FILENAME%s", Gen_FileName,    /* Substitute the file name here. */
		                "LINENO%d",   Gen_LineNo,      /* Substitute the line info here. */
		                MI_LIST_END                    /* Terminate the list!!           */
		            )
		          );
	}

	/* Mask off the mi_db_error_raise flags. */
	Gen_MsgType &= 0xffff;

	/* Route the message back to the user? */
	if( Gen_MsgType )
	{
		/* If requested, also write the message to the user. */
		mi_db_error_raise( Gen_Con,                    /* This is the connection handle. */
		                   Gen_MsgType,                /* Route to the user.             */
		                   Gen_MsgNo,                  /* Print this message.            */
		                   "FUNCTION%s", Gen_Caller,   /* Substitute the caller here.    */
		                   (char *)NULL );             /* Terminator.                    */

		/*
		** mi_db_error_raise may not return
		** and this line may not be reached.
		*/
	}
}
/* Warning: Do not modify. Gen_Trace checksum: 386315048  */

#ifdef __cplusplus

}

#endif
