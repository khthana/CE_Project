/*
** Title:               Fingerprint.c
** SCCSid:              %W% %E% %U%
** CCid:                %W% %E% %U%
** Author:              
** Created:             Feb 27, 1999 10:35:33 AM
** Description:         Generated 'C' file.
** Comments:            Generated for project Fingerprint.1.7.3p.41.
*/

/*
**  The following is placed here to insure
**  that name "mangling" does not occur.
*/
#ifdef __cplusplus

extern "C"
{

#endif

/* Standard library includes. */
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stddef.h>

/* Used by Informix GLS routines. */
#include <ifxgls.h>

/* Include when accessing the Informix API. */
#include <mi.h>

/* This is the project include file. */
#include "Fingerprint.h"
#include "math.h"

#define		MAX_S	11	/* 0.5 - 1.5*/
#define		MAX_Z	91	/* -45 - 45 */
#define		MAX_X	128
#define		MAX_Y	128
#define		SCALE	10
#define		ROTATE	90
#define		MAX_PIC	256
#define		BOUND	2
#define		PI		3.1415926535
#define		MARK	-999

/****************************************************************
**
** Function name:
**
**	pnt_tInput
**
** Description:
**
**	This function converts from the external representation of the
**	UDT type pnt_t to its internal representation.   The external
**	representation is a blank-separated list of values and the
**	internal representation is a 'C' structure of type pnt_t as
**	defined in the header file.
**
**	Data may be inserted into a table using an SQL insert statement:
**
**		insert into tablename values ( 'value-list' );
**
**	value-list is a space-delimited list of values.
**
** Special Comments:
**
**	Support routine for opaque type pnt_t returns pnt_t.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	pnt_t *                            The constructed UDT value.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    pnt_tInput FunctionId: 78755522-bf71-11d2-806c-204c4f4f5020
**
*****************************************************************
*/
pnt_t *
pnt_tInput
(
mi_lvarchar *           Gen_param1,        /* Pointer to the input text.         */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	gl_mchar_t *    Gen_InData;        /* Pointer to the input data.         */
	pnt_t *         Gen_OutData;       /* Pointer to the output data.        */
	mi_integer      Gen_DataLen;       /* Length of the data in bytes.       */
	pnt_t *         Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in pnt_tInput."
		*/
		DBDK_TRACE_ERROR( "pnt_tInput", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that pnt_tInput has been called.
	*/
	DBDK_TRACE_ENTER( "pnt_tInput" );

	/* Allocate memory room to build the UDT in. */
	Gen_RetVal = (pnt_t *)mi_alloc( sizeof( pnt_t ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in pnt_tInput."
		*/
		DBDK_TRACE_ERROR( "pnt_tInput", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = (gl_mchar_t *)mi_get_vardata( Gen_param1 );


	/* Point to the output data. */
	Gen_OutData = (pnt_t *)Gen_RetVal;

	/* Get the length of the input string. */
	Gen_DataLen = mi_get_varlen( Gen_param1 );

	/* Get the data value for Gen_OutData->X. */
	Gen_InData = Gen_sscanf( Gen_Con, "pnt_tInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->X );

	/* Get the data value for Gen_OutData->Y. */
	Gen_InData = Gen_sscanf( Gen_Con, "pnt_tInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Y );

	/* Get the data value for Gen_OutData->Zeta. */
	Gen_InData = Gen_sscanf( Gen_Con, "pnt_tInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Zeta );


	/*
	** Write to the trace file indicating
	** that pnt_tInput has successfully exited.
	*/
	DBDK_TRACE_EXIT( "pnt_tInput" );

	/* Close the connection. */
	mi_close( Gen_Con );

	/* Return the UDT value. */
	return Gen_RetVal;
}
/* Warning: Do not modify. pnt_tInput checksum: 158446402  */

/****************************************************************
**
** Function name:
**
**	pnt_tOutput
**
** Description:
**
**	This function converts from the internal representation of the
**	UDT type pnt_t to its external representation.   The external
**	representation is a blank-separated list of values and the
**	internal representation is a 'C' structure of type pnt_t as
**	defined in the header file.
**
**	Data may be retrieved from a table using an SQL select statement:
**
**		select * from tablename;
**
** Special Comments:
**
**	Support routine for opaque type pnt_t returns lvarchar.
**
** Parameters:
**
**	pnt_t *         Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    pnt_tOutput FunctionId: 78755523-bf71-11d2-806c-204c4f4f5020
**
*****************************************************************
*/
mi_lvarchar *
pnt_tOutput
(
pnt_t *                 Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_integer      Gen_CharLen;       /* Estimate maximum length.           */
	pnt_t *         Gen_InData;        /* Pointer to the input data.         */
	char *          Gen_OutData;       /* Pointer to the output data.        */
	mi_lvarchar *   Gen_RetVal;        /* The return result.                 */
	mi_integer      Gen_DataLen;       /* The data length.                   */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in pnt_tOutput."
		*/
		DBDK_TRACE_ERROR( "pnt_tOutput", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that pnt_tOutput has been called.
	*/
	DBDK_TRACE_ENTER( "pnt_tOutput" );

	/* Compute the maximum length of the text representation. */
	Gen_CharLen =    1;	/* Leave room for the NULL terminator. */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->X.                      */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Y.                      */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Zeta.                   */

	/* Allocate room for the output string. */
	Gen_RetVal = mi_new_var( Gen_CharLen );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in pnt_tOutput."
		*/
		DBDK_TRACE_ERROR( "pnt_tOutput", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = Gen_param1;

	/* Point to the output data. */
	Gen_OutData = mi_get_vardata( Gen_RetVal );

	/* Format the attribute value into the output string. */

	/* Format the value for Gen_InData->X. */
	sprintf( Gen_OutData, "%d ", Gen_InData->X );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the value for Gen_InData->Y. */
	sprintf( Gen_OutData, "%d ", Gen_InData->Y );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the value for Gen_InData->Zeta. */
	sprintf( Gen_OutData, "%d ", Gen_InData->Zeta );
	Gen_OutData += strlen( Gen_OutData );


	/*
	** Compute the length of the data and
	** place it in the return structure.
	*/
	Gen_DataLen = (mi_integer)(Gen_OutData - mi_get_vardata( Gen_RetVal ));
	mi_set_varlen ( Gen_RetVal, Gen_DataLen );

	/*
	** Write to the trace file indicating
	** that pnt_tOutput has successfully exited.
	*/
	DBDK_TRACE_EXIT( "pnt_tOutput" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. pnt_tOutput checksum: 143220201  */

/****************************************************************
**
** Function name:
**
**	fing_tInput
**
** Description:
**
**	This function converts from the external representation of the
**	UDT type fing_t to its internal representation.   The external
**	representation is a blank-separated list of values and the
**	internal representation is a 'C' structure of type fing_t as
**	defined in the header file.
**
**	Data may be inserted into a table using an SQL insert statement:
**
**		insert into tablename values ( 'value-list' );
**
**	value-list is a space-delimited list of values.
**
** Special Comments:
**
**	Support routine for opaque type fing_t returns fing_t.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    fing_tInput FunctionId: fe73ada4-cc7b-11d2-b023-204c4f4f5020
**
*****************************************************************
*/
mi_lvarchar *
fing_tInput
(
mi_lvarchar *           Gen_param1,        /* Pointer to the input text.         */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	gl_mchar_t *    Gen_InData;        /* Pointer to the input data.         */
	fing_t *        Gen_OutData;       /* Pointer to the output data.        */
	mi_integer      Gen_DataLen;       /* Length of the data in bytes.       */
	mi_lvarchar *   Gen_RetVal;        /* The return value.                  */
	mi_integer      Gen_vl_nitems;     /* Number of variable length items.   */
	mi_integer      Gen_vl_itemno;     /* Index through the items.           */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in fing_tInput."
		*/
		DBDK_TRACE_ERROR( "fing_tInput", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that fing_tInput has been called.
	*/
	DBDK_TRACE_ENTER( "fing_tInput" );

	/* Point to the input data. */
	Gen_InData = (gl_mchar_t *)mi_get_vardata( Gen_param1 );


	/* Compute the number of repetitions in the variable length input. */
	Gen_vl_nitems =
		(Gen_nstrwords( Gen_InData, mi_get_varlen( (mi_lvarchar *)Gen_param1 ) ) - 0 )/3;


	/* Compute the amount of memory required for the data. */
	Gen_DataLen = sizeof( fing_t ) +
			(Gen_vl_nitems - 1) * sizeof( Gen_OutData->data );

	/* Allocate sufficient memory to build the UDT in. */
	Gen_RetVal = mi_new_var( Gen_DataLen );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in fing_tInput."
		*/
		DBDK_TRACE_ERROR( "fing_tInput", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the output data. */
	Gen_OutData = (fing_t *)mi_get_vardata( Gen_RetVal );

	/* Handle the fixed part of the UDT. */


	/* Handle the variable part of the UDT. */
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		/* Get the data value for Gen_OutData->data[Gen_vl_itemno].X. */
		Gen_InData = Gen_sscanf( Gen_Con, "fing_tInput", Gen_InData,
					mi_get_varlen( Gen_param1 ), 0,
					"%d %n",
					(char *)&Gen_OutData->data[Gen_vl_itemno].X );

		/* Get the data value for Gen_OutData->data[Gen_vl_itemno].Y. */
		Gen_InData = Gen_sscanf( Gen_Con, "fing_tInput", Gen_InData,
					mi_get_varlen( Gen_param1 ), 0,
					"%d %n",
					(char *)&Gen_OutData->data[Gen_vl_itemno].Y );

		/* Get the data value for Gen_OutData->data[Gen_vl_itemno].Zeta. */
		Gen_InData = Gen_sscanf( Gen_Con, "fing_tInput", Gen_InData,
					mi_get_varlen( Gen_param1 ), 0,
					"%d %n",
					(char *)&Gen_OutData->data[Gen_vl_itemno].Zeta );

	}


	/*
	** Write to the trace file indicating
	** that fing_tInput has successfully exited.
	*/
	DBDK_TRACE_EXIT( "fing_tInput" );

	/* Close the connection. */
	mi_close( Gen_Con );

	/* Return the UDT value. */
	return Gen_RetVal;
}
/* Warning: Do not modify. fing_tInput checksum: 509530242  */

/****************************************************************
**
** Function name:
**
**	fing_tOutput
**
** Description:
**
**	This function converts from the internal representation of the
**	UDT type fing_t to its external representation.   The external
**	representation is a blank-separated list of values and the
**	internal representation is a 'C' structure of type fing_t as
**	defined in the header file.
**
**	Data may be retrieved from a table using an SQL select statement:
**
**		select * from tablename;
**
** Special Comments:
**
**	Support routine for opaque type fing_t returns lvarchar.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    fing_tOutput FunctionId: fe73ada3-cc7b-11d2-b023-204c4f4f5020
**
*****************************************************************
*/
mi_lvarchar *
fing_tOutput
(
mi_lvarchar *           Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_integer      Gen_CharLen;       /* Estimate maximum length.           */
	fing_t *        Gen_InData;        /* Pointer to the input data.         */
	char *          Gen_OutData;       /* Pointer to the output data.        */
	mi_lvarchar *   Gen_RetVal;        /* The return result.                 */
	mi_integer      Gen_vl_nitems;     /* Number of items.                   */
	mi_integer      Gen_vl_itemno;     /* Dummy index.                       */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in fing_tOutput."
		*/
		DBDK_TRACE_ERROR( "fing_tOutput", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that fing_tOutput has been called.
	*/
	DBDK_TRACE_ENTER( "fing_tOutput" );

	/* Compute the number of variable length items. */
	Gen_vl_nitems =
		(mi_get_varlen( (mi_lvarchar *)Gen_param1 ) - sizeof( fing_t ) + sizeof( Gen_InData->data ))
		/ sizeof( Gen_InData->data );


	/* Compute the maximum length of the text representation. */
	Gen_CharLen =    1;	/* Leave room for the NULL terminator. */
	
	/* Compute the text length for the variable part. */
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		Gen_CharLen +=  12;	/* Add the length for Gen_OutData->data[Gen_vl_itemno].X.  */
		Gen_CharLen +=  12;	/* Add the length for Gen_OutData->data[Gen_vl_itemno].Y.  */
		Gen_CharLen +=  12;	/* Add the length for Gen_OutData->data[Gen_vl_itemno].Zeta. */

	}

	/* Allocate room for the output string. */
	Gen_RetVal = mi_new_var( Gen_CharLen );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in fing_tOutput."
		*/
		DBDK_TRACE_ERROR( "fing_tOutput", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = (fing_t *)mi_get_vardata( Gen_param1 );

	/* Point to the output data. */
	Gen_OutData = mi_get_vardata( Gen_RetVal );

	/* Transfer the fixed part of the UDT. */


	/* Handle the variable part of the UDT. */
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		/* Format the value for Gen_InData->data[Gen_vl_itemno].X. */
		sprintf( Gen_OutData, "%d ", Gen_InData->data[Gen_vl_itemno].X );
		Gen_OutData += strlen( Gen_OutData );

		/* Format the value for Gen_InData->data[Gen_vl_itemno].Y. */
		sprintf( Gen_OutData, "%d ", Gen_InData->data[Gen_vl_itemno].Y );
		Gen_OutData += strlen( Gen_OutData );

		/* Format the value for Gen_InData->data[Gen_vl_itemno].Zeta. */
		sprintf( Gen_OutData, "%d ", Gen_InData->data[Gen_vl_itemno].Zeta );
		Gen_OutData += strlen( Gen_OutData );

	}

	/*
	** Compute the length of the data and
	** place it in the return structure.
	*/
	mi_set_varlen ( Gen_RetVal,
		(mi_integer)(Gen_OutData - mi_get_vardata( Gen_RetVal )) );

	/*
	** Write to the trace file indicating
	** that fing_tOutput has successfully exited.
	*/
	DBDK_TRACE_EXIT( "fing_tOutput" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. fing_tOutput checksum: 425952578  */

/****************************************************************
**
** Function name:
**
**	fing_tSend
**
** Description:
**
**	The binary send function is used to convert an instance of a
**	data type between its internal representation on the server and
**	on the client.
**
** Special Comments:
**
**	Support routine for opaque type fing_t returns sendrecv.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    fing_tSend FunctionId: fe73ada6-cc7b-11d2-b023-204c4f4f5020
**
*****************************************************************
*/
mi_sendrecv *
fing_tSend
(
mi_bitvarying *         Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_sendrecv *   Gen_RetVal;        /* The return packet value.           */
	mi_integer      Gen_vl_nitems;     /* Number of items.                   */
	mi_integer      Gen_vl_itemno;     /* Dummy index.                       */
	fing_t *        Gen_InData;        /* Pointer to the UDT value.          */
	fing_t *        Gen_OutData;       /* Pointer to the packet.             */
/* by top	mi_integer      Gen_tempval;       /* Used to transfer mi_smallint-s.    */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in fing_tSend."
		*/
		DBDK_TRACE_ERROR( "fing_tSend", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that fing_tSend has been called.
	*/
	DBDK_TRACE_ENTER( "fing_tSend" );

	Gen_InData = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

	/* Compute the maximum expected length. */
	Gen_vl_nitems =
			(mi_get_varlen((mi_lvarchar *)Gen_param1) - offsetof( fing_t, data ))
				/ sizeof( Gen_InData->data );

	/* Allocate a new return value. */
	Gen_RetVal = (mi_sendrecv *)mi_new_var( sizeof( fing_t ) +
			(Gen_vl_nitems - 1) *
			sizeof( Gen_InData->data ));
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in fing_tSend."
		*/
		DBDK_TRACE_ERROR( "fing_tSend", ERRORMESG2, 10 );

		/* not reached */
	}

	/*
	** Get a pointer to the data so that the
	** attribute values may be set into it.
	*/
	Gen_OutData = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );


	/* Place the UDT's variable attribute value(s) into the packet. */
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		/* Prepare the value for Gen_OutData->data[Gen_vl_itemno].X. */
		mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->data[Gen_vl_itemno].X, Gen_InData->data[Gen_vl_itemno].X );

		/* Prepare the value for Gen_OutData->data[Gen_vl_itemno].Y. */
		mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->data[Gen_vl_itemno].Y, Gen_InData->data[Gen_vl_itemno].Y );

		/* Prepare the value for Gen_OutData->data[Gen_vl_itemno].Zeta. */
		mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->data[Gen_vl_itemno].Zeta, Gen_InData->data[Gen_vl_itemno].Zeta );

	}


	/*
	** Write to the trace file indicating
	** that fing_tSend has successfully exited.
	*/
	DBDK_TRACE_EXIT( "fing_tSend" );

	/* Close the connection. */
	mi_close( Gen_Con );

	/* Return the UDT for transmission. */
	return Gen_RetVal;
}
/* Warning: Do not modify. fing_tSend checksum: 682565129  */

/****************************************************************
**
** Function name:
**
**	fing_tReceive
**
** Description:
**
**	The binary receive function is used to convert an instance of a
**	data type between its internal representation on the server and
**	on the client.
**
** Special Comments:
**
**	Support routine for opaque type fing_t returns fing_t.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    fing_tReceive FunctionId: fe73ada5-cc7b-11d2-b023-204c4f4f5020
**
*****************************************************************
*/
mi_bitvarying *
fing_tReceive
(
mi_sendrecv *           Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_bitvarying * Gen_RetVal;        /* The return value.                  */
	fing_t *        Gen_InData;        /* Packet data.                       */
	fing_t *        Gen_OutData;       /* Output UDT value.                  */
/* by top	mi_integer      Gen_DataLen;       /* The data length.                   */
	mi_integer      Gen_vl_nitems;     /* Number of data items.              */
	mi_integer      Gen_vl_itemno;     /* Index thru the items.              */
	mi_integer      Gen_vl_len;        /* The length.                        */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in fing_tReceive."
		*/
		DBDK_TRACE_ERROR( "fing_tReceive", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that fing_tReceive has been called.
	*/
	DBDK_TRACE_ENTER( "fing_tReceive" );

	/* Point to the input data. */
	Gen_InData = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

	/* Get the length of the data to follow. */
	Gen_vl_len = mi_get_varlen( (mi_lvarchar *)Gen_param1 );

	/* Compute the number of items in the variable length list. */
	Gen_vl_nitems = (Gen_vl_len - offsetof( fing_t, data )) /
					sizeof( Gen_OutData->data );

	/* Allocate room for the UDT. */
	Gen_RetVal = (mi_bitvarying *)mi_new_var(
					sizeof( fing_t ) +
					  (Gen_vl_nitems - 1) *
					  sizeof( Gen_OutData->data ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in fing_tReceive."
		*/
		DBDK_TRACE_ERROR( "fing_tReceive", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the output data. */
	Gen_OutData = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

	/* Copy the attribute value(s) from the transmission parcel. */

	/* Retrieve the UDT's variable attribute value(s) from the packet. */
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		/* Prepare the value for Gen_InData->data[Gen_vl_itemno].X. */
		mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->data[Gen_vl_itemno].X, &Gen_OutData->data[Gen_vl_itemno].X );

		/* Prepare the value for Gen_InData->data[Gen_vl_itemno].Y. */
		mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->data[Gen_vl_itemno].Y, &Gen_OutData->data[Gen_vl_itemno].Y );

		/* Prepare the value for Gen_InData->data[Gen_vl_itemno].Zeta. */
		mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->data[Gen_vl_itemno].Zeta, &Gen_OutData->data[Gen_vl_itemno].Zeta );

	}


	/*
	** Write to the trace file indicating
	** that fing_tReceive has successfully exited.
	*/
	DBDK_TRACE_EXIT( "fing_tReceive" );

	/* Return the transmitted UDT value. */
	return Gen_RetVal;
}
/* Warning: Do not modify. fing_tReceive checksum: 635923292  */

/****************************************************************
**
** Function name:
**
**	fing_tImportText
**
** Description:
**
**	The import function enables bulk copy for user-defined types.
**	When the  LOAD statement is  used from  dbaccess to copy data
**	from a file  into the database, the  server calls the  import
**	function to convert the  incoming  value  to the data  type's
**	internal format.
**
** Special Comments:
**
**	Support routine for opaque type fing_t returns fing_t.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	fing_t *                           The constructed UDT value.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    fing_tImportText FunctionId: fe73ada7-cc7b-11d2-b023-204c4f4f5020
**
*****************************************************************
*/
mi_bitvarying *
fing_tImportText
(
mi_impexp *             Gen_param1,        /* The import text.                   */
MI_FPARAM *             Gen_fparam         /* Std info - see DBDK docs.          */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	gl_mchar_t *    Gen_InData;        /* Pointer to the data.               */
	fing_t *        Gen_OutData;       /* Pointer to output data.            */
	mi_integer      Gen_DataLen;       /* Length of the data in bytes.       */
	mi_bitvarying * Gen_RetVal;        /* The return value.                  */
	mi_integer      Gen_vl_nitems;     /* Number of items.                   */
	mi_integer      Gen_vl_itemno;     /* Index thru the items.              */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in fing_tImportText."
		*/
		DBDK_TRACE_ERROR( "fing_tImportText", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that fing_tImportText has been called.
	*/
	DBDK_TRACE_ENTER( "fing_tImportText" );

	/* Point to the input data. */
	Gen_InData =  (gl_mchar_t *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );


	/* Compute the number of repetitions in the variable length input. */
	Gen_vl_nitems =
		(Gen_nstrwords( Gen_InData, mi_get_varlen( (mi_lvarchar *)Gen_param1 ) ) - 0 )/3;


	/* Compute the amount of memory required for the data. */
	Gen_DataLen = sizeof( fing_t ) +
			(Gen_vl_nitems - 1) * sizeof( Gen_OutData->data );

	/* Allocate sufficient memory for the return UDT. */
	Gen_RetVal = (mi_bitvarying *)mi_new_var( Gen_DataLen );
	if( Gen_RetVal == 0)
	{
		/*
		**	Memory allocation has failed so issue
		**	the following message and quit.
		**
		**	"Memory allocation has failed in fing_tImportText."
		*/
		DBDK_TRACE_ERROR( "fing_tImportText", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the output data. */
	Gen_OutData = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );


	/* Handle the variable part of the UDT. */
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		/* Fill the UDT with its value. */
		Gen_InData = Gen_sscanf( Gen_Con, "fing_tImportText", Gen_InData,
					mi_get_varlen( (mi_lvarchar *)Gen_param1 ), 0,
					"%d %n",
					(char *)&Gen_OutData->data[Gen_vl_itemno].X );

		/* Fill the UDT with its value. */
		Gen_InData = Gen_sscanf( Gen_Con, "fing_tImportText", Gen_InData,
					mi_get_varlen( (mi_lvarchar *)Gen_param1 ), 0,
					"%d %n",
					(char *)&Gen_OutData->data[Gen_vl_itemno].Y );

		/* Fill the UDT with its value. */
		Gen_InData = Gen_sscanf( Gen_Con, "fing_tImportText", Gen_InData,
					mi_get_varlen( (mi_lvarchar *)Gen_param1 ), 0,
					"%d %n",
					(char *)&Gen_OutData->data[Gen_vl_itemno].Zeta );

	}


	/*
	** Write to the trace file indicating
	** that fing_tImportText has successfully exited.
	*/
	DBDK_TRACE_EXIT( "fing_tImportText" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. fing_tImportText checksum: 949804374  */

/****************************************************************
**
** Function name:
**
**	fing_tExportText
**
** Description:
**
**	The export function enables bulk copy for user-defined types.
**	When the UNLOAD statement is used from  dbaccess to copy data
**	from  the  database to a  file, the  server calls the  export
**	function  to convert the outcoming  value to the data  type's
**	external format.
**
** Special Comments:
**
**	Support routine for opaque type fing_t returns impexp.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	fing_t *                           The constructed UDT value.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    fing_tExportText FunctionId: fe73ada8-cc7b-11d2-b023-204c4f4f5020
**
*****************************************************************
*/
mi_impexp *
fing_tExportText
(
mi_bitvarying *         Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam                       /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_integer      Gen_CharLen;       /* Maximum character length.          */
	mi_impexp *     Gen_RetVal;        /* The return result.                 */
	fing_t *        Gen_InData;        /* Pointer to the input data.         */
	char *          Gen_OutData;       /* Pointer to the output data.        */
	mi_integer      Gen_DataLen;       /* The final length.                  */
	mi_integer      Gen_vl_nitems;     /* Number of variable length items.   */
	mi_integer      Gen_vl_itemno;     /* Index thru the var length items.   */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in fing_tExportText."
		*/
		DBDK_TRACE_ERROR( "fing_tExportText", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that fing_tExportText has been called.
	*/
	DBDK_TRACE_ENTER( "fing_tExportText" );

	/* Compute the maximum length of the text representation. */
	Gen_CharLen =    1;	/* Leave room for the NULL terminator. */
	/* Compute the number of variable length items. */
	Gen_vl_nitems =
		(mi_get_varlen( (mi_lvarchar *)Gen_param1 ) - sizeof( fing_t ) + sizeof( Gen_InData->data ))
		/ sizeof( Gen_InData->data );


	/* Handle the variable part of the UDT. */
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		Gen_CharLen +=  12;	/* Add the length for Gen_OutData->data[Gen_vl_itemno].X.  */
		Gen_CharLen +=  12;	/* Add the length for Gen_OutData->data[Gen_vl_itemno].Y.  */
		Gen_CharLen +=  12;	/* Add the length for Gen_OutData->data[Gen_vl_itemno].Zeta. */
	}


	Gen_RetVal = (mi_impexp *)mi_new_var( Gen_CharLen );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in fing_tExportText."
		*/
		DBDK_TRACE_ERROR( "fing_tExportText", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

	/* Get a pointer to where our data will be copied to. */
	Gen_OutData = mi_get_vardata( (mi_lvarchar *)Gen_RetVal );


	/* Handle the variable part of the UDT. */
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		/* Format the output value for Gen_InData->data[Gen_vl_itemno].X. */
		sprintf( Gen_OutData, "%d ", Gen_InData->data[Gen_vl_itemno].X );
		Gen_OutData += strlen( Gen_OutData );

		/* Format the output value for Gen_InData->data[Gen_vl_itemno].Y. */
		sprintf( Gen_OutData, "%d ", Gen_InData->data[Gen_vl_itemno].Y );
		Gen_OutData += strlen( Gen_OutData );

		/* Format the output value for Gen_InData->data[Gen_vl_itemno].Zeta. */
		sprintf( Gen_OutData, "%d ", Gen_InData->data[Gen_vl_itemno].Zeta );
		Gen_OutData += strlen( Gen_OutData );

	}


	/*
	** Compute the length of the data and
	** place it in the return structure.
	*/
	Gen_DataLen = (mi_integer)(Gen_OutData - mi_get_vardata( (mi_lvarchar *)Gen_RetVal ));
	mi_set_varlen( (mi_lvarchar *)Gen_RetVal,  Gen_DataLen );

	/*
	** Write to the trace file indicating
	** that fing_tExportText has successfully exited.
	*/
	DBDK_TRACE_EXIT( "fing_tExportText" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. fing_tExportText checksum: 881577260  */

/****************************************************************
**
** Function name:
**
**	fing_tImportBinary
**
** Description:
**
**	The  importbinary  function is  used to  support  bulk copy of
**	binary data. This function is the same as the import function,
**	except that it  operates  on internal  representations of  the
**	data type.  This function is  usually only  provided for large
**	object  data types and is called by the LOAD BINARY command of
**	dbaccess.
**
** Special Comments:
**
**	Support routine for opaque type fing_t returns fing_t.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	fing_t *                           The constructed UDT value.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    fing_tImportBinary FunctionId: fe73ada1-cc7b-11d2-b023-204c4f4f5020
**
*****************************************************************
*/
mi_bitvarying *
fing_tImportBinary
(
mi_bitvarying *         Gen_param1,        /* The input value.                   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_bitvarying * Gen_RetVal;        /* The return result.                 */
	fing_t *        Gen_InData;        /* The UDT input value.               */
	fing_t *        Gen_OutData;       /* The transfer data.                 */
	mi_integer      Gen_vl_nitems;     /* Number of var length items.        */
	mi_integer      Gen_vl_itemno;     /* Index into the var length list.    */
	mi_integer      Gen_vl_len;        /* Length of the var len UDT.         */

	/* Get the current connection. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in fing_tImportBinary."
		*/
		DBDK_TRACE_ERROR( "fing_tImportBinary", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that fing_tImportBinary has been called.
	*/
	DBDK_TRACE_ENTER( "fing_tImportBinary" );

	/* Get the length of the data to follow. */
	Gen_vl_len = mi_get_varlen( (mi_lvarchar *)Gen_param1 );

	/* Compute the number of items in the variable length list. */
	Gen_vl_nitems = (Gen_vl_len - offsetof( fing_t, data )) /
					sizeof( Gen_OutData->data );

	/* Allocate a new UDT for the return result. */
	Gen_RetVal =(mi_bitvarying *) mi_new_var(
					sizeof(fing_t ) +
					(Gen_vl_nitems - 1) *
					sizeof( Gen_OutData->data) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in fing_tImportBinary."
		*/
		DBDK_TRACE_ERROR( "fing_tImportBinary", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the transfer data. */
	Gen_InData = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

	/* Point to the output data. */
	Gen_OutData = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );


	/* Handle the variable part of the UDT. */
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		/* Transfer the data value for Gen_InData->data[Gen_vl_itemno].X. */
		mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->data[Gen_vl_itemno].X, &Gen_OutData->data[Gen_vl_itemno].X );

		/* Transfer the data value for Gen_InData->data[Gen_vl_itemno].Y. */
		mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->data[Gen_vl_itemno].Y, &Gen_OutData->data[Gen_vl_itemno].Y );

		/* Transfer the data value for Gen_InData->data[Gen_vl_itemno].Zeta. */
		mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->data[Gen_vl_itemno].Zeta, &Gen_OutData->data[Gen_vl_itemno].Zeta );

	}

	/*
	** Write to the trace file indicating
	** that fing_tImportBinary has successfully exited.
	*/
	DBDK_TRACE_EXIT( "fing_tImportBinary" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. fing_tImportBinary checksum: 962097104  */

/****************************************************************
**
** Function name:
**
**	fing_tExportBinary
**
** Description:
**
**	The  exportbinary  function  is  used  to  support  bulk  copy  of
**	binary  data.  This function is the same as  the export  function,
**	except that it  operates on  internal  representations of the data
**	type.  This  function is usually only  provided  for large  object
**	data types and is called by the UNLOAD BINARY command of dbaccess.
**
** Special Comments:
**
**	Support routine for opaque type fing_t returns impexpbin.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	fing_t *                           The constructed UDT value.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    fing_tExportBinary FunctionId: fe73ada2-cc7b-11d2-b023-204c4f4f5020
**
*****************************************************************
*/
mi_bitvarying *
fing_tExportBinary
(
mi_bitvarying *         Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_bitvarying * Gen_RetVal;        /* The return value.                  */
	fing_t *        Gen_InData;        /* The transfer data.                 */
	fing_t *        Gen_OutData;       /* The output data.                   */
	mi_integer      Gen_vl_nitems;     /* Number of var length items.        */
	mi_integer      Gen_vl_itemno;     /* Index into the var length input.   */

	/* Get the current connection. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in fing_tExportBinary."
		*/
		DBDK_TRACE_ERROR( "fing_tExportBinary", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that fing_tExportBinary has been called.
	*/
	DBDK_TRACE_ENTER( "fing_tExportBinary" );

	/* Point to the input. */
	Gen_InData = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

	/* Compute the number of variable length items. */
	Gen_vl_nitems =
			(mi_get_varlen( (mi_lvarchar *)Gen_param1 ) - offsetof( fing_t, data )) /
			sizeof( Gen_InData->data );

	/* Allocate the output parcel. */
	Gen_RetVal = (mi_bitvarying *)mi_new_var( sizeof( fing_t ) +
				(Gen_vl_nitems - 1)*sizeof( Gen_InData->data ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in fing_tExportBinary."
		*/
		DBDK_TRACE_ERROR( "fing_tExportBinary", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Set up the output data pointer. */
	Gen_OutData = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

	/* Compute the number of variable length items. */
	Gen_vl_nitems =
		(mi_get_varlen( (mi_lvarchar *)Gen_param1 ) - sizeof( fing_t ) + sizeof( Gen_InData->data ))
		/ sizeof( Gen_InData->data );


	/* Handle the variable part of the UDT. */
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		/* Transfer the data value for Gen_OutData->data[Gen_vl_itemno].X. */
		mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->data[Gen_vl_itemno].X, Gen_InData->data[Gen_vl_itemno].X );

		/* Transfer the data value for Gen_OutData->data[Gen_vl_itemno].Y. */
		mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->data[Gen_vl_itemno].Y, Gen_InData->data[Gen_vl_itemno].Y );

		/* Transfer the data value for Gen_OutData->data[Gen_vl_itemno].Zeta. */
		mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->data[Gen_vl_itemno].Zeta, Gen_InData->data[Gen_vl_itemno].Zeta );

	}


	/*
	** Write to the trace file indicating
	** that fing_tExportBinary has successfully exited.
	*/
	DBDK_TRACE_EXIT( "fing_tExportBinary" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. fing_tExportBinary checksum: 180698909  */

/****************************************************************
**
** Function name:
**
**	fing_tCompare
**
** Description:
**
**	Perform the comparison operations required to compare two
**	UDT values.
**
** Special Comments:
**
**	Support routine for opaque type fing_t returns integer.
**
** Parameters:
**
**	fing_t *        Gen_param1;        The first UDT value to compare.
**	fing_t *        Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_integer                         The comparison result.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    fing_tCompare FunctionId: 9fac02d0-cc80-11d2-b023-204c4f4f5020
**
*****************************************************************
*/
mi_integer
fing_tCompare
(
mi_bitvarying *         Gen_param1,        /* The first UDT value to compare.    */
mi_bitvarying *         Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_integer      Gen_cc;            /* Numeric attribute difference.      */
	mi_integer      Gen_vl_nitems;     /* The number of items.               */
	mi_integer      Gen_vl_itemno;     /* Index thru the items.              */
	mi_integer      Gen_vl_lendif;     /* Data length difference.            */
	fing_t *        Gen_Value1;        /* Pointer to the first value.        */
	fing_t *        Gen_Value2;        /* Pointer to the second value.       */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in fing_tCompare."
		*/
		DBDK_TRACE_ERROR( "fing_tCompare", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that fing_tCompare has been called.
	*/
	DBDK_TRACE_ENTER( "fing_tCompare" );

	/* Point to the data values that are to be compared. */
	Gen_Value1 = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );
	Gen_Value2 = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_param2 );

	/* Compute the difference of the lengths of the two UDTs. */
	Gen_vl_lendif = mi_get_varlen( (mi_lvarchar *)Gen_param1 ) -
	                mi_get_varlen( (mi_lvarchar *)Gen_param1 );

	/* Compute the number of variable length items. */
	Gen_vl_nitems = (Gen_vl_lendif <= 0
		? ( mi_get_varlen( (mi_lvarchar *)Gen_param1) - offsetof( fing_t, data )) / sizeof( Gen_Value1->data )
		: ( mi_get_varlen( (mi_lvarchar *)Gen_param2 ) - offsetof( fing_t, data )) / sizeof( Gen_Value1->data ));


	/* Handle the variable part of the UDT. */
	for( Gen_vl_itemno = 0; Gen_vl_itemno < Gen_vl_nitems; Gen_vl_itemno++ )
	{
		/* Compare the two values. */
		Gen_cc = Gen_Value1->data[Gen_vl_itemno].X - Gen_Value2->data[Gen_vl_itemno].X;
		if( Gen_cc )
		{
			return Gen_cc < 0 ? -1 : 1;
		}

		/* Compare the two values. */
		Gen_cc = Gen_Value1->data[Gen_vl_itemno].Y - Gen_Value2->data[Gen_vl_itemno].Y;
		if( Gen_cc )
		{
			return Gen_cc < 0 ? -1 : 1;
		}

		/* Compare the two values. */
		Gen_cc = Gen_Value1->data[Gen_vl_itemno].Zeta - Gen_Value2->data[Gen_vl_itemno].Zeta;
		if( Gen_cc )
		{
			return Gen_cc < 0 ? -1 : 1;
		}

	}
	return Gen_vl_lendif < 0 ? -1 : !Gen_vl_lendif ? 0 : 1;

}
/* Warning: Do not modify. fing_tCompare checksum: 345445121  */

/****************************************************************
**
** Function name:
**
**	fing_tEqual
**
** Description:
**
**	Determine if one UDT value is equal to another.
**
** Special Comments:
**
**	Support routine for opaque type fing_t returns boolean.
**
** Parameters:
**
**	fing_t *        Gen_param1;        The first UDT value to compare.
**	fing_t *        Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                         The comparison result.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    fing_tEqual FunctionId: 9fac02d1-cc80-11d2-b023-204c4f4f5020
**
*****************************************************************
*/
mi_boolean
fing_tEqual
(
mi_bitvarying *         Gen_param1,        /* The first UDT value to compare.    */
mi_bitvarying *         Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(0 == fing_tCompare( Gen_param1,
			Gen_param2, Gen_fparam ));
}
/* Warning: Do not modify. fing_tEqual checksum: 82417920   */

/****************************************************************
**
** Function name:
**
**	fing_tNotEqual
**
** Description:
**
**	Determine if one UDT value is not equal to another.
**
** Special Comments:
**
**	Support routine for opaque type fing_t returns boolean.
**
** Parameters:
**
**	fing_t *        Gen_param1;        The first UDT value to compare.
**	fing_t *        Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                         The comparison result.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    fing_tNotEqual FunctionId: 9fac02d2-cc80-11d2-b023-204c4f4f5020
**
*****************************************************************
*/
mi_boolean
fing_tNotEqual
(
mi_bitvarying *         Gen_param1,        /* The first UDT value to compare.    */
mi_bitvarying *         Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(0 != fing_tCompare( Gen_param1,
			Gen_param2, Gen_fparam ));
}
/* Warning: Do not modify. fing_tNotEqual checksum: 94059944   */

/*****************************************************************
**
** Function name:
**
**	Gen_sscanf
**
** Description:
**
**	This function converts formatted values.  The types converted are:
**
**		Type                    Format
**		==============================
**		gl_mchar_t                %C
**		mi_boolean                %b
**		mi_char                   %c
**		mi_date                   %D
**		mi_datetime               %T
**		mi_decimal/mi_numeric     %N
**		mi_double_precision       %lf
**		mi_int8                   %8
**		mi_integer                %d
**		mi_interval               %I
**		mi_long                   %ld
**		mi_money                  %m
**		mi_real                   %f
**		mi_unsigned_integer       %x
**
**	Conversion is performed from GLS text to the corresponding binary
**	representation.  The GLS text is assumed to be in the server locale.
**
**	Addition information about these data types may be found in
**	The Informix Guide to SQL: Syntax - Version 9.01.
**
** Parameters:
**
**	MI_CONNECTION * Gen_Con            The database connection.
**	char *          Gen_Caller         Name of the calling function.
**	gl_mchar_t *    Gen_InData         The input string data.
**	mi_integer      Gen_InDataLen      The length of Gen_InData.
**	mi_integer      Gen_Width          Max length if data is text.
**	char *          Gen_Format         The data's format.
**	char *          Gen_Result         Place the result here.
**
** Return value:
**
**	gl_mchar_t *                       The new scan position.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    Gen_sscanf FunctionId: 3AC0E360-5A81-11d0-A2E7-00AA0009BF87
**
******************************************************************
*/
gl_mchar_t *
Gen_sscanf
(
MI_CONNECTION *         Gen_Con,           /* The database connection.           */
char *                  Gen_Caller,        /* Name of the calling function.      */
gl_mchar_t *            Gen_InData,        /* The input string data.             */
mi_integer              Gen_InDataLen,     /* The length of Gen_InData.          */
mi_integer              Gen_Width,         /* Max length if data is text.        */
char *                  Gen_Format,        /* The data's format.                 */
char *                  Gen_Result         /* Place the result here.             */
)
{
	gl_mchar_t *    Gen_In;            /* Scanning ptr.                      */
	gl_mchar_t *    Gen_SaveIn;        /* Save Gen_In here.                  */
	gl_mchar_t      Gen_NextChar;      /* Get the next char here.            */
	char *          Gen_InStart;       /* Gen_In before advancement.         */
	gl_mchar_t *    Gen_Out;           /* Place the GLS result here.         */
	mi_integer      Gen_ByteCount;     /* The number of bytes.               */

	Gen_In        = Gen_InData;
	Gen_Out       = (gl_mchar_t *)Gen_Result;
	Gen_ByteCount = 0;

	/* Scan past non-format characters. */
	while( *Gen_Format && *Gen_In )
	{
		/* Scan past and ignore white space in the data. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-blank. */
			if( !ifx_gl_ismblank( Gen_In, 4 ) )
			{
				break;
			}

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );
		}

		/* Check for the format character. */
		if( *Gen_Format == '%' )
		{
			break;
		}

		/*
		**	The format character and the input string
		**	must match up to the format character.
		**	If not, issue a message.
		*/
		if( *(char *)Gen_In != *Gen_Format )
		{
			goto parse_error;
		}

		/* Keep track of how far we've advanced. */
		Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

		/* Advance to the next character. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/* Advance to the next character. */
		++Gen_Format;
	}

	/*	Check for no input data string. */
	if( *(char *)Gen_In == '\0' )
	{
		goto parse_error;
	}

	/* The following code now handles the various format types. */

	if( !strncmp( Gen_Format, "%s %n", 5 ) && Gen_Width )
	{
		if( '"' != *Gen_In )
		{
			/*
			** Input parsing has failed so issue
			** the following message and quit.
			**
			** 	"Double-quoted string expected
			**	 in input in <Gen_Caller>."
			*/
			DBDK_TRACE_ERROR( Gen_Caller, ERRORMESG7, 10 );

			/* not reached */
		}

		/* Advance past the leading quote. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/* Copy while there's sufficient room. */
		while( Gen_Width )
		{
			Gen_InStart = (char *)Gen_In;

			switch( *Gen_In )
			{
				/*
				** If '"' is seen, check to see
				** if the next character is also
				** a '"'. If so, '"' is embedded.
				** Otherwise, it is EOS.
				*/
				case '"':
					Gen_SaveIn = Gen_In;
					Gen_NextChar = *ifx_gl_mbsnext( Gen_In, 4 );
					Gen_In = Gen_SaveIn;
					if( Gen_NextChar == '"' )
					{
						*Gen_Out++ = '"';

						/* Advance past the first quote. */
						Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

						/* Advance past the second space. */
						Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

						break;
					}

					*Gen_Out = (char)'\0';

					/* Advance past the trailing quote. */
					Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

					/* Advance past the trailing space. */
					Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

					return Gen_In;

				case '\0':
					/*
					** Input parsing has failed so issue
					** the following message and quit.
					**
					** 	"Input string is not terminated with double-quote
					**	 in <Gen_Caller>."
					*/
					DBDK_TRACE_ERROR( Gen_Caller, ERRORMESG9, 10 );

					/* not reached */

				default:
					*Gen_Out++ = *Gen_In;
					Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
					Gen_Width -= (char *)Gen_In - Gen_InStart;

					break;
			}
		}

		/*
		** Input parsing has failed so issue
		** the following message and quit.
		**
		** 	"Input string is too long in <Gen_Caller>."
		*/
		DBDK_TRACE_ERROR( Gen_Caller, ERRORMESG10, 10 );

		/* not reached */
	}

	/* Check for an mi_integer. */
	else if( !strncmp( Gen_Format, "%d %n", 5 ) )
	{
		mi_decimal   Gen_dec_number;  /* Store an mi_decimal value here. */

		/* Convert the GLS string to a decimal value. */
		if( ifx_gl_convert_number( &Gen_dec_number, (char *)Gen_In, "%d" ) == -1 )
		{
			goto parse_error;
		}

		/* Convert the decimal to a 'C' integer. */
		if( dectoint( &Gen_dec_number, (int *)Gen_Result ) != 0 )
		{
			goto parse_error;
		}

		/* Scan past the mi_integer value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'                ||
				 *Gen_In == 'E'                ||
				 *Gen_In == '.'                ||
				 *Gen_In == '+'                ||
				 *Gen_In == '-')               )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for a double value. */
	else if( !strncmp( Gen_Format, "%lf %n", 6 ) )
	{
		mi_decimal   Gen_dec_number;  /* Store an mi_decimal value here. */

		/* Convert the GLS string to a decimal value. */
		if( ifx_gl_convert_number( &Gen_dec_number, (char *)Gen_In, "%e" ) == -1 )
		{
			goto parse_error;
		}

		/* Convert the decimal to a 'C' double. */
		if( dectodbl( &Gen_dec_number, (double *)Gen_Result ) != 0 )
		{
			goto parse_error;
		}

		/* Scan past the number. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'                ||
				 *Gen_In == 'E'                ||
				 *Gen_In == '.'                ||
				 *Gen_In == '+'                ||
				 *Gen_In == '-')               )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 6;
	}

	/* Check for a float value. */
	else if( !strncmp( Gen_Format, "%f %n", 5 ) )
	{
		mi_double_precision Gen_dbl_number; /* Store an mi_float value here.   */
		mi_decimal          Gen_dec_number; /* Store an mi_decimal value here. */

		/* Convert the GLS string to a decimal value. */
		if( ifx_gl_convert_number( &Gen_dec_number, (char *)Gen_In, "%e" ) == -1 )
		{
			goto parse_error;
		}

		/* Convert the decimal to a 'C' float. */
		if( dectodbl( &Gen_dec_number, &Gen_dbl_number ) != 0 )
		{
			goto parse_error;
		}
		*(float *)Gen_Result = (float)Gen_dbl_number;

		/* Scan past the float value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'                ||
				 *Gen_In == 'E'                ||
				 *Gen_In == '.'                ||
				 *Gen_In == '+'                ||
				 *Gen_In == '-')               )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for a long value. */
	else if( !strncmp( Gen_Format, "%ld %n", 6 ) )
	{
		mi_decimal   Gen_dec_number;  /* Store an mi_decimal value here. */

		/* Convert the GLS string to a decimal value. */
		if( ifx_gl_convert_number( &Gen_dec_number, (char *)Gen_In, "%d" ) == -1 )
		{
			goto parse_error;
		}

		/* Convert the decimal to a 'C' long. */
		if( dectolong( &Gen_dec_number, (long *)Gen_Result ) != 0 )
		{
			goto parse_error;
		}

		/* Scan past the long value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'                ||
				 *Gen_In == 'E'                ||
				 *Gen_In == '.'                ||
				 *Gen_In == '+'                ||
				 *Gen_In == '-')               )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 6;
	}

	/* Check for an int8 value. */
	else if( !strncmp( Gen_Format, "%8 %n", 5 ) )
	{
		gl_mchar_t * Gen_Int8Ptr;     /* Scanning pointer.             */
		gl_mchar_t * Gen_Int8Ptr2;    /* Scanning pointer.             */
		mi_integer   Gen_Int8Index;   /* Keep track of the length.     */
		mi_integer   Gen_Int8Ret;     /* ifx_int8cvasc return value.   */
		char         Gen_Int8Str[80]; /* Hold the mi_int8 string here. */

		/*
		** Transfer the data value to a NULL terminated
		** buffer for conversion by ifx_int8cvasc.
		*/
		for( Gen_Int8Ptr   = (gl_mchar_t *)Gen_Int8Str,
			 Gen_Int8Ptr2  = Gen_In,
			 Gen_Int8Index = 0;
				Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_Int8Index;
			++Gen_ByteCount;
		}

		/* Copy the string and terminate. */
		ifx_gl_mbscpy( (gl_mchar_t *)Gen_Int8Str, Gen_Int8Ptr2,
				(int)(Gen_InData - Gen_Int8Ptr2) );
		Gen_Int8Str[Gen_InData - Gen_Int8Ptr2] = (char)'\0';

		/* Check for an empty string. */
		if( Gen_Int8Index == 0 )
		{
			goto parse_error;
		}

		/* Convert the mi_int8 value from text to internal format. */
		Gen_Int8Ret = ifx_int8cvasc( Gen_Int8Str, strlen( Gen_Int8Str ),
		                             (ifx_int8_t *)&Gen_Result );
		if( Gen_Int8Ret )
		{
			goto parse_error;
		}

		/* Scan past the int8 value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'                ||
				 *Gen_In == 'E'                ||
				 *Gen_In == '.'                ||
				 *Gen_In == '+'                ||
				 *Gen_In == '-')               )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/*
	** Check for a boolean value.  Only 'T' or 't'
	** (for True) and  'F' or 'f' (for False)  are
	** accepted.
	*/
	else if( !strncmp( Gen_Format, "%b %n", 5 ) )
	{
		if( *(char *)Gen_In == 'T' || *(char *)Gen_In == 't' )
		{
			*(char *)Gen_Result = 1;
		}
		else if( *(char *)Gen_In == 'F' || *(char *)Gen_In == 'f' )
		{
			*(char *)Gen_Result = 0;
		}
		else
		{
			goto parse_error;
		}

		Gen_ByteCount += sizeof(char);

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an unsigned int value. */
	else if( !strncmp( Gen_Format, "%x %n", 5 ) )
	{
		mi_decimal Gen_dec_number; /* Store an mi_decimal value here. */

		/* Convert the GLS string to a decimal value. */
		if( ifx_gl_convert_number( &Gen_dec_number, (char *)Gen_In, "%u" ) == -1 )
		{
			goto parse_error;
		}

		/* Convert the decimal to a 'C' unsigned integer. */
		if( dectoint( &Gen_dec_number, (int *)Gen_Result ) != 0 )
		{
			goto parse_error;
		}

		/* Scan past the unsigned int value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'                ||
				 *Gen_In == 'E'                ||
				 *Gen_In == '.'                ||
				 *Gen_In == '+'                ||
				 *Gen_In == '-')               )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for a multibyte character. */
	else if( !strncmp( Gen_Format, "%C %n", 5 ) )
	{
		/* Copy the entire multibyte character. */
		Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );
		memcpy( Gen_Result, Gen_In, Gen_ByteCount );

		/* Scan to trailing white space. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-blank. */
			if( !ifx_gl_ismblank( Gen_In, 4 ) )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_money value. */
	else if( !strncmp( Gen_Format, "%m %n", 5 ) )
	{
		gl_mchar_t *   Gen_MoneyPtr;     /* Scanning pointer.                */
		gl_mchar_t *   Gen_MoneyPtr2;    /* Scanning pointer.                */
		mi_lvarchar *  Gen_MoneyLV;      /* mi_lvarchar ptr to Gen_MoneyStr. */
		mi_money *     Gen_MoneyVal;     /* The binary money value.          */
		mi_integer     Gen_MoneyIndex;   /* Keep track of the length.        */
		char           Gen_MoneyStr[80]; /* Hold the mi_money string here.   */

		/*
		** Transfer the data value to a NULL terminated
		** buffer for conversion by mi_money_to_binary.
		*/
		for( Gen_MoneyPtr   = (gl_mchar_t *)Gen_MoneyStr,
			 Gen_MoneyPtr2  = Gen_In,
			 Gen_MoneyIndex = 0;
				Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_MoneyIndex;
			++Gen_ByteCount;
		}

		/* Copy the string and terminate. */
		ifx_gl_mbscpy( (gl_mchar_t *)Gen_MoneyStr, Gen_MoneyPtr2,
					(int)(Gen_In - Gen_MoneyPtr2) );
		Gen_MoneyStr[Gen_In - Gen_MoneyPtr2] = (char)'\0';

		/* Check for an empty string. */
		if( Gen_MoneyIndex == 0 )
		{
			goto parse_error;
		}

		/* Convert the money string to mi_lvarchar. */
		Gen_MoneyLV = mi_string_to_lvarchar( Gen_MoneyStr );

		/* Check for an error in conversion. */
		if( Gen_MoneyLV == 0 )
		{
			goto parse_error;
		}

		/* Convert the money string to internal format. */
		Gen_MoneyVal = mi_money_to_binary( Gen_MoneyLV );

		/* Check for an error in conversion. */
		if( Gen_MoneyVal == NULL )
		{
			goto parse_error;
		}

		/* Copy to the UDT data area. */
		memcpy( Gen_Result, Gen_MoneyVal, sizeof(mi_money) );

		/* ... and free the temporary money data values. */
		mi_free( Gen_MoneyLV );
		mi_free( Gen_MoneyVal );

		/* Scan past the money value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'                ||
				 *Gen_In == 'E'                ||
				 *Gen_In == '.'                ||
				 *Gen_In == '+'                ||
				 *Gen_In == '-')               )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_numeric/mi_decimal value. */
	else if( !strncmp( Gen_Format, "%N %n", 5 ) )
	{
		gl_mchar_t * Gen_DecPtr;     /* Scanning pointer.                */
		gl_mchar_t * Gen_DecPtr2;    /* Scanning pointer.                */
		mi_decimal   Gen_DecVal;     /* The binary decimal value.        */
		mi_integer   Gen_DecIndex;   /* Keep track of the length.        */
		mi_integer   Gen_DecRet;     /* deccvasc return value.           */
		char         Gen_DecStr[80]; /* Hold the mi_decimal string here. */

		/*
		** Transfer the data value to a NULL terminated
		** buffer for conversion by deccvasc.
		*/
		for( Gen_DecPtr   = (gl_mchar_t *)Gen_DecStr,
			 Gen_DecPtr2  = Gen_In,
			 Gen_DecIndex = 0;
				Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_DecIndex;
			++Gen_ByteCount;
		}

		/* Copy the string and terminate. */
		ifx_gl_mbscpy( (gl_mchar_t *)Gen_DecStr, Gen_DecPtr2,
					(int)(Gen_In - Gen_DecPtr2) );
		Gen_DecStr[Gen_In - Gen_DecPtr2] = (char)'\0';

		/* Check for an empty string. */
		if( Gen_DecIndex == 0 )
		{
			goto parse_error;
		}

		/* Convert the mi_decimal value from text to internal format. */
		Gen_DecRet = deccvasc( Gen_DecStr, strlen( Gen_DecStr ), &Gen_DecVal );

		/* Check for an error in conversion. */
		if( Gen_DecRet )
		{
			goto parse_error;
		}

		/* Copy to the UDT data area. */
		memcpy( Gen_Result, &Gen_DecVal, sizeof(mi_decimal) );

		/* Scan past the decimal value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'                ||
				 *Gen_In == 'E'                ||
				 *Gen_In == '.'                ||
				 *Gen_In == '+'                ||
				 *Gen_In == '-')               )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_date value. */
	else if( !strncmp( Gen_Format, "%D %n", 5 ) )
	{
		gl_mchar_t * Gen_DatePtr;     /* Scanning pointer.             */
		gl_mchar_t * Gen_DatePtr2;    /* Scanning pointer.             */
		long         Gen_DateVal;     /* The binary date value.        */
		mi_integer   Gen_DateIndex;   /* Keep track of the length.     */
		mi_integer   Gen_RstrdateRet; /* rstrdate return value.        */
		char         Gen_DateStr[80]; /* Hold the mi_date string here. */

		/*
		** Transfer the data value to a NULL terminated
		** buffer for conversion by rstrdate.
		*/
		for( Gen_DatePtr   = (gl_mchar_t *)Gen_DateStr,
			 Gen_DatePtr2  = Gen_In,
			 Gen_DateIndex = 0;
				Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_DateIndex;
			++Gen_ByteCount;
		}

		/* Copy the string and terminate. */
		ifx_gl_mbscpy( (gl_mchar_t *)Gen_DateStr, Gen_DatePtr2,
					(int)(Gen_In - Gen_DatePtr2) );
		Gen_DateStr[Gen_In - Gen_DatePtr2] = (char)'\0';

		/* Check for an empty string. */
		if( Gen_DateIndex == 0 )
		{
			goto parse_error;
		}

		/* Convert the date string to internal format. */
		Gen_RstrdateRet = rstrdate( Gen_DateStr, &Gen_DateVal );

		/* Check for an error in conversion. */
		if( Gen_RstrdateRet )
		{
			goto parse_error;
		}

		/* Copy to the UDT data area. */
		memcpy( Gen_Result, &Gen_DateVal, sizeof(mi_date) );

		/* Scan past the date string. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !ifx_gl_ismdigit( Gen_In, 4 ) )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_datetime value. */
	else if( !strncmp( Gen_Format, "%T %n", 5 ) )
	{
		gl_mchar_t * Gen_DTPtr;      /* Scanning pointer.             */
		gl_mchar_t * Gen_DTPtr2;     /* Scanning pointer.             */
		mi_datetime  Gen_DTVal;      /* The binary date value.        */
		mi_integer   Gen_DTIndex;    /* Keep track of the length.     */
		int          Gen_Blanks;     /* Number of blanks scanned.     */
		int          Gen_DtcvascRet; /* dtcvasc return value.         */
		char         Gen_DTStr[80];  /* Hold the mi_date string here. */

		/*
		** Transfer the data value to a NULL terminated
		** buffer for conversion by dtcvasc.
		*/
		for( Gen_DTPtr   = (gl_mchar_t *)Gen_DTStr,
			 Gen_DTPtr2  = Gen_In,
			 Gen_Blanks  = 0,
			 Gen_DTIndex = 0;
				Gen_In < Gen_InData + Gen_InDataLen; )
		{
			/* Stop at the second blank. */
			if( ifx_gl_ismblank( Gen_In, 4 ) && ++Gen_Blanks == 2 )
			{
				break;
			}

			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_DTIndex;
			++Gen_ByteCount;
		}

		/* Copy the string and terminate. */
		ifx_gl_mbscpy( (gl_mchar_t *)Gen_DTStr, Gen_DTPtr2,
					(int)(Gen_In - Gen_DTPtr2) );
		Gen_DTStr[Gen_In - Gen_DTPtr2] = (char)'\0';

		/* Check for an empty string. */
		if( Gen_DTIndex == 0 )
		{
			goto parse_error;
		}

		/*
		** Set the  mi_datetime  qualifier.   It is
		** copied from the return value's qualifier.
		*/
		Gen_DTVal.dt_qual = ((mi_datetime *)Gen_Result)->dt_qual;

		/* Convert the mi_datetime value to internal format. */
		Gen_DtcvascRet = dtcvasc( Gen_DTStr, &Gen_DTVal );

		/* Check to insure that the conversion was successful. */
		if( Gen_DtcvascRet )
		{
			goto parse_error;
		}

		/* Copy to the UDT data area. */
		memcpy( Gen_Result, &Gen_DTVal, sizeof(mi_datetime) );

		/* Scan past the datetime string. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !ifx_gl_ismdigit( Gen_In, 4 ) )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Handle all other types using sscanf. */
	else if( 1 != sscanf( (char *)Gen_In, Gen_Format, Gen_Out, &Gen_ByteCount ) )
	{
		goto parse_error;
	}

	/* Satisfy any remaining non-format characters in the format string. */
	while( *Gen_Format && *Gen_In )
	{
		/* Scan past trailing white space in the data. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-blank. */
			if( !ifx_gl_ismblank( Gen_In, 4 ) )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Check for the format character. */
		if( *Gen_Format != *(char *)Gen_In )
		{
			break;
		}

		/*
		**	The non-format character and the input data
		**	must match. If not, issue a message.
		*/
		if( *(char *)Gen_In != *Gen_Format )
		{
			goto parse_error;
		}

		/* Keep track of how far we've advanced. */
		Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

		/* Advance to the next character. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/* Advance to the next character. */
		++Gen_Format;
	}

	/*	** Finally, scan past trailing spaces
	** and non-format characters.
	*/

	/* Scan past trailing white space in the data. */
	while( Gen_In < Gen_InData + Gen_InDataLen )
	{
		/* Stop at the first non-blank. */
		if( !ifx_gl_ismblank( Gen_In, 4 ) )
		{
			break;
		}

		/* Keep track of how far we've advanced. */
		Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

		/* Advance to the next character. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
	}

	return Gen_InData + Gen_ByteCount;

parse_error:

	/*
	** Input parsing has failed so issue
	** the following message and quit.
	**
	** 	"Input data format error in <Gen_Caller>."
	*/
	DBDK_TRACE_ERROR( Gen_Caller, ERRORMESG11, 10 );

	/* not reached */
}
/* Warning: Do not modify. Gen_sscanf checksum: 90927202   */

/********************************************************************
**
** Function name:
**
**	Gen_nstrwords
**
** Description:
**
**	This function counts the number of values in a formatted string.
**
** Parameters:
**
**	gl_mchar_t *    Gen_InData         The data to scan.
**	mi_integer      Gen_InDataLen      Length of the data.
**
** Return value:
**
**	mi_integer                         The new scan position.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    Gen_nstrwords FunctionId: 3AC0E361-5A81-11d0-A2E7-00AA0009BF87
**
*********************************************************************
*/
mi_integer
Gen_nstrwords
(
gl_mchar_t *            Gen_InData,        /* The data to scan.                  */
mi_integer              Gen_InDataLen      /* Length of the data.                */
)
{
	mi_integer      Gen_WordCount;     /* The number of words present.       */
	gl_mchar_t *    Gen_In;            /* Scanning pointer.                  */
	char *          Gen_DataCopy;      /* A NULL terminated copy.            */
	enum
	{
		DBDK_QUOTE,
		DBDK_ESCAPE,
		DBDK_WORD,
		DBDK_SPACE
	} Gen_state;    /* Parsing state.	*/

	/* Copy the data and NULL terminate it. */
	Gen_DataCopy = (char *)mi_alloc(Gen_InDataLen + 1);
	memcpy(Gen_DataCopy, Gen_InData, Gen_InDataLen);
	Gen_DataCopy[Gen_InDataLen] = (char)'\0';
	Gen_InData = (gl_mchar_t *)Gen_DataCopy;

	/* Begin counting the words. */
	Gen_WordCount = 0;

	/* Set the initial state. */
	Gen_state = DBDK_SPACE;

	/* Point to the beginning of the input text. */
	Gen_In = Gen_InData;

	do
	{
		switch ( Gen_state )
		{
			case DBDK_ESCAPE:
				Gen_state = DBDK_QUOTE;
				break;

			case DBDK_QUOTE:
				if( '"' == *Gen_In )
				{
					Gen_state = DBDK_SPACE;
				}
				break;

			case DBDK_WORD:
				if( '"' == *Gen_In )
				{
					Gen_WordCount++, Gen_state = DBDK_QUOTE;
				}
				else if( ifx_gl_ismspace( Gen_In, 4 ) )
				{
					Gen_state = DBDK_SPACE;
				}
				break;

			case DBDK_SPACE:
				if( '"' == *Gen_In )
				{
					Gen_WordCount++, Gen_state = DBDK_QUOTE;
				}
				else if( !ifx_gl_ismspace( Gen_In, 4 ) )
				{
					Gen_WordCount++, Gen_state = DBDK_WORD;
				}
				break;
		}

		/* Advance the pointer. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
	}
	while( *Gen_In != '\0' );

	/* Free the copy of the data. */
	mi_free(Gen_DataCopy);

	return Gen_WordCount;
}
/* Warning: Do not modify. Gen_nstrwords checksum: 992950442  */

/*************************************************************************
**
** Function name:
**
**	Gen_Trace
**
** Description:
**
**	This function writes trace information to the trace file.
**
**	Complete information about tracing may be found in
**	the INFORMIX-DataBlade API, User's Guide, Version 9.0.
**
**	To enable tracing, you must first create a trace class
**	by inserting a record into the systraceclasses system
**	catalog:
**
**		insert into informix.systraceclasses(name)
**		values('Fingerprint');
**
**	The name of the trace file must be set. If the file name
**	is not set, the server uses a default file name:
**	the session id followed by ".trc" in the /tmp directory.
**	Use "onstat -g ses" to get the session id.
**
**	The following code snippet may be used to set the name
**	of the output trace file from within your code.
**
**		mi_tracefile_set( "/yourpath/yourfile.trc" );
**
**	Alternately, the TraceSet_Fingerpri procedure may be
**	used from SQL to set the trace file name and trace threshold
**	level.  See this procedure for more details.
**
**	To insure that tracing text  actually  appears in the
**	output trace file, SERVER_LOCALE, CLIENT_LOCALE,  and
**	DB_LOCALE must be set in the environment to the
**	appropriate locale (e.g., "en_us.1252").
**
** Parameters:
**
**	MI_CONNECTION * Gen_Con            The database connection.
**	char *          Gen_Caller         Call originated from this routine.
**	char *          Gen_FileName       Call originated in this file.
**	mi_integer      Gen_LineNo         Call originated on this line.
**	char *          Gen_MsgNo          ERRORMESG number.
**	char *          Gen_Class          Tracing class.
**	mi_integer      Gen_Threshold      Tracing threshold.
**	mi_integer      Gen_MsgType        MI_SQL | MI_MESSAGE | DBDK_TRACE.
**
** Return value:
**
**	None.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    Gen_Trace FunctionId: 59DEDB71-760B-11d0-A2EC-00AA0009BF87
**
*************************************************************************
*/
void
Gen_Trace
(
MI_CONNECTION *         Gen_Con,           /* The database connection.           */
char *                  Gen_Caller,        /* Call originated from this routine. */
char *                  Gen_FileName,      /* Call originated in this file.      */
mi_integer              Gen_LineNo,        /* Call originated on this line.      */
char *                  Gen_MsgNo,         /* ERRORMESG number.                  */
char *                  Gen_Class,         /* Tracing class.                     */
mi_integer              Gen_Threshold,     /* Tracing threshold.                 */
mi_integer              Gen_MsgType        /* MI_SQL | MI_MESSAGE | DBDK_TRACE.  */
)
{
	/* Route the message to the trace file? */
	if( Gen_MsgType & DBDK_TRACE )
	{
		/* Write the message to the trace file. */
		GL_DPRINTF( Gen_Class,
		            Gen_Threshold,
		            (
		                Gen_MsgNo,
		                "FUNCTION%s", Gen_Caller,      /* Substitute the caller here.    */
		                "FILENAME%s", Gen_FileName,    /* Substitute the file name here. */
		                "LINENO%d",   Gen_LineNo,      /* Substitute the line info here. */
		                MI_LIST_END                    /* Terminate the list!!           */
		            )
		          );
	}

	/* Mask off the mi_db_error_raise flags. */
	Gen_MsgType &= 0xffff;

	/* Route the message back to the user? */
	if( Gen_MsgType )
	{
		/* If requested, also write the message to the user. */
		mi_db_error_raise( Gen_Con,                    /* This is the connection handle. */
		                   Gen_MsgType,                /* Route to the user.             */
		                   Gen_MsgNo,                  /* Print this message.            */
		                   "FUNCTION%s", Gen_Caller,   /* Substitute the caller here.    */
		                   (char *)NULL );             /* Terminator.                    */

		/*
		** mi_db_error_raise may not return
		** and this line may not be reached.
		*/
	}
}
/* Warning: Do not modify. Gen_Trace checksum: 386315048  */

/****************************************************************
**
** Function name:
**
**	HoughIdxInput
**
** Description:
**
**	This function converts from the external representation of the
**	UDT type HoughIdx to its internal representation.   The external
**	representation is a blank-separated list of values and the
**	internal representation is a 'C' structure of type HoughIdx as
**	defined in the header file.
**
**	Data may be inserted into a table using an SQL insert statement:
**
**		insert into tablename values ( 'value-list' );
**
**	value-list is a space-delimited list of values.
**
** Special Comments:
**
**	Support routine for opaque type HoughIdx returns HoughIdx.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	HoughIdx *                         The constructed UDT value.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    HoughIdxInput FunctionId: 1ab5ef50-ce02-11d2-b02a-204c4f4f5020
**
*****************************************************************
*/
HoughIdx *
HoughIdxInput
(
mi_lvarchar *           Gen_param1,        /* Pointer to the input text.         */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	gl_mchar_t *    Gen_InData;        /* Pointer to the input data.         */
	HoughIdx *      Gen_OutData;       /* Pointer to the output data.        */
	mi_integer      Gen_DataLen;       /* Length of the data in bytes.       */
	HoughIdx *      Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in HoughIdxInput."
		*/
		DBDK_TRACE_ERROR( "HoughIdxInput", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that HoughIdxInput has been called.
	*/
	DBDK_TRACE_ENTER( "HoughIdxInput" );

	/* Allocate memory room to build the UDT in. */
	Gen_RetVal = (HoughIdx *)mi_alloc( sizeof( HoughIdx ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in HoughIdxInput."
		*/
		DBDK_TRACE_ERROR( "HoughIdxInput", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = (gl_mchar_t *)mi_get_vardata( Gen_param1 );


	/* Point to the output data. */
	Gen_OutData = (HoughIdx *)Gen_RetVal;

	/* Get the length of the input string. */
	Gen_DataLen = mi_get_varlen( Gen_param1 );

	/* Get the data value for Gen_OutData->S. */
	Gen_InData = Gen_sscanf( Gen_Con, "HoughIdxInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->S );

	/* Get the data value for Gen_OutData->Z. */
	Gen_InData = Gen_sscanf( Gen_Con, "HoughIdxInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Z );

	/* Get the data value for Gen_OutData->X. */
	Gen_InData = Gen_sscanf( Gen_Con, "HoughIdxInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->X );

	/* Get the data value for Gen_OutData->Y. */
	Gen_InData = Gen_sscanf( Gen_Con, "HoughIdxInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Y );


	/*
	** Write to the trace file indicating
	** that HoughIdxInput has successfully exited.
	*/
	DBDK_TRACE_EXIT( "HoughIdxInput" );

	/* Close the connection. */
	mi_close( Gen_Con );

	/* Return the UDT value. */
	return Gen_RetVal;
}
/* Warning: Do not modify. HoughIdxInput checksum: 423219747  */

/****************************************************************
**
** Function name:
**
**	HoughIdxOutput
**
** Description:
**
**	This function converts from the internal representation of the
**	UDT type HoughIdx to its external representation.   The external
**	representation is a blank-separated list of values and the
**	internal representation is a 'C' structure of type HoughIdx as
**	defined in the header file.
**
**	Data may be retrieved from a table using an SQL select statement:
**
**		select * from tablename;
**
** Special Comments:
**
**	Support routine for opaque type HoughIdx returns lvarchar.
**
** Parameters:
**
**	HoughIdx *                         Gen_param1;   Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    HoughIdxOutput FunctionId: 1ab5ef51-ce02-11d2-b02a-204c4f4f5020
**
*****************************************************************
*/
mi_lvarchar *
HoughIdxOutput
(
HoughIdx *              Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_integer      Gen_CharLen;       /* Estimate maximum length.           */
	HoughIdx *      Gen_InData;        /* Pointer to the input data.         */
	char *          Gen_OutData;       /* Pointer to the output data.        */
	mi_lvarchar *   Gen_RetVal;        /* The return result.                 */
	mi_integer      Gen_DataLen;       /* The data length.                   */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in HoughIdxOutput."
		*/
		DBDK_TRACE_ERROR( "HoughIdxOutput", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that HoughIdxOutput has been called.
	*/
	DBDK_TRACE_ENTER( "HoughIdxOutput" );

	/* Compute the maximum length of the text representation. */
	Gen_CharLen =    1;	/* Leave room for the NULL terminator. */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->S.                      */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Z.                      */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->X.                      */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Y.                      */

	/* Allocate room for the output string. */
	Gen_RetVal = mi_new_var( Gen_CharLen );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in HoughIdxOutput."
		*/
		DBDK_TRACE_ERROR( "HoughIdxOutput", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = Gen_param1;

	/* Point to the output data. */
	Gen_OutData = mi_get_vardata( Gen_RetVal );

	/* Format the attribute value into the output string. */

	/* Format the value for Gen_InData->S. */
	sprintf( Gen_OutData, "%d ", Gen_InData->S );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the value for Gen_InData->Z. */
	sprintf( Gen_OutData, "%d ", Gen_InData->Z );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the value for Gen_InData->X. */
	sprintf( Gen_OutData, "%d ", Gen_InData->X );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the value for Gen_InData->Y. */
	sprintf( Gen_OutData, "%d ", Gen_InData->Y );
	Gen_OutData += strlen( Gen_OutData );


	/*
	** Compute the length of the data and
	** place it in the return structure.
	*/
	Gen_DataLen = (mi_integer)(Gen_OutData - mi_get_vardata( Gen_RetVal ));
	mi_set_varlen ( Gen_RetVal, Gen_DataLen );

	/*
	** Write to the trace file indicating
	** that HoughIdxOutput has successfully exited.
	*/
	DBDK_TRACE_EXIT( "HoughIdxOutput" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. HoughIdxOutput checksum: 202687289  */

/****************************************************************
**
** Function name:
**
**	Hough1
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine Hough1 (fing_t,fing_t) returns HoughIdx.
**
** Parameters:
**
** Return value:
**
**	HoughIdx *
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    Hough1 FunctionId: 23468d10-cdf5-11d2-b02a-204c4f4f5020
**
*****************************************************************
*/
HoughIdx *
Hough1
(
mi_bitvarying *	Arg1,
mi_bitvarying *	Arg2,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle.             */
	HoughIdx *      Get_RetVal;        /* The return value.                  */
	fing_t			*Pset,*Qset;
	mi_int1			****A;				/* array A[Sk][zeat_l][Xm][Yn] */
	mi_integer		S,zeta_d,Count,Px,Py,Qx,Qy,Xm,Yn;
	mi_integer		Q,P,Q_nitems,P_nitems;
	mi_boolean		ZZ;
	mi_double_precision			zeta_l,Sk,CosZ,SinZ;


	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in Hough1."
		*/
		DBDK_TRACE_ERROR( "Hough1", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that Hough1 has been called.
	*/
	DBDK_TRACE_ENTER( "Hough1" );
	/* Compute the number of variable length query items*/
	Q_nitems =
		(mi_get_varlen( (mi_bitvarying *)Arg1 ) - sizeof( fing_t ) + sizeof( Qset->data ))
		/ sizeof( Qset->data );
	/* Compute the number of variable length reference items*/
	P_nitems =
		(mi_get_varlen( (mi_bitvarying *)Arg2 ) - sizeof( fing_t ) + sizeof( Pset->data ))
		/ sizeof( Pset->data );
	/* Get input data to Q set and P set */
	Qset = (fing_t*)mi_get_vardata(Arg1);
	Pset = (fing_t*)mi_get_vardata(Arg2);
	/* Allocate */
	A=(mi_int1****)mi_fp_funcstate(Gen_fparam);
	if (A==(mi_int1****)NULL) 
	{
		A=(mi_int1****)mi_dalloc(MAX_S*sizeof(mi_int1*),PER_COMMAND);
		if ( A == (mi_int1****)NULL )
		{
			mi_db_error_raise(Gen_Con,MI_EXCEPTION,"memory failed in Sk axis");
			return (HoughIdx*)NULL;
		}
		for(S=0;S<MAX_S;S++)
		{
			*(A+S)=(mi_int1***)mi_dalloc(MAX_Z*sizeof(mi_int1*),PER_COMMAND);
			if( *(A+S) == (mi_int1***)NULL )
			{
				mi_db_error_raise(Gen_Con,MI_EXCEPTION,"memory failed in Zeta axis");
				return (HoughIdx*)NULL;
			}
		}
		for(S=0;S<MAX_S;S++)
			for(zeta_d=0;zeta_d<MAX_Z;zeta_d++)
			{
				*(*(A+S)+zeta_d)=(mi_int1**)mi_dalloc(MAX_X*sizeof(mi_int1*),PER_COMMAND);
				if( *(*(A+S)+zeta_d) == (mi_int1**)NULL )
				{
					mi_db_error_raise(Gen_Con,MI_EXCEPTION,"memory failed in Xm axis");
					return (HoughIdx*)NULL;
				}
			}
		for(S=0;S<MAX_S;S++)
			for(zeta_d=0;zeta_d<MAX_Z;zeta_d++)
				for(Xm=0;Xm<MAX_X;Xm++)
				{
					*(*(*(A+S)+zeta_d)+Xm)=(mi_int1*)mi_dalloc(MAX_Y*sizeof(mi_int1),PER_COMMAND);
					if( *(*(*(A+S)+zeta_d)+Xm) == (mi_int1*)NULL )
					{
						mi_db_error_raise(Gen_Con,MI_EXCEPTION,"memory failed in Yn axis");
						return (HoughIdx*)NULL;
					}
				}
		mi_fp_setfuncstate(Gen_fparam,(void****)A);
	}
	/* Hough */
	/* Step 1: Clear array all */
	for(S=0;S<MAX_S;S++)
		for(zeta_d=0;zeta_d<MAX_Z;zeta_d++)
			for(Xm=0;Xm<MAX_X;Xm++)
				for(Yn=0;Yn<MAX_Y;Yn++)
					*(*(*(*(A+S)+zeta_d)+Xm)+Yn) = 0;
	/* Step2: Compute and add evidence */
	for(P=0;P<P_nitems;P++)
		for(Q=0;Q<Q_nitems;Q++)
		{
			ZZ = MI_FALSE;
			zeta_d=0;
			while ((ZZ==MI_FALSE)&&(zeta_d<MAX_Z))
			{
				Count = zeta_d-(mi_integer)(MAX_Z-1)/2; /* -45 .. 45*/
				if(Pset->data[P].Zeta+Count==Qset->data[Q].Zeta)
				{
					ZZ=MI_TRUE;
					zeta_l = Count*PI/180;		/* degree to radians */
					CosZ=cos(zeta_l);
					SinZ=sin(zeta_l);
					Px = Pset->data[P].X;
					Py = Pset->data[P].Y;
					Qx = Qset->data[Q].X;
					Qy = Qset->data[Q].Y;
					for(S=0;S<MAX_S;S++)		/* 0.5 ... 1.5 */
					{
						Sk = ((S*1.0)+(MAX_S-1)/2)/10;
						Xm = Qx-(mi_integer)(Sk*(Px*CosZ+Py*SinZ));
						Yn = Qy-(mi_integer)(Sk*(Py*CosZ-Px*SinZ));
						Xm += (mi_integer)(MAX_X/2);	/* -64 ... +63 */
						Yn += (mi_integer)(MAX_Y/2);	/* -64 ... +63 */
						if ((Xm>=0)&&(Xm<MAX_X)&&(Yn>=0)&&(Yn<MAX_Y))
							(*(*(*(*(A+S)+zeta_d)+Xm)+Yn))++;
					}

				}
				else zeta_d++;
			}
		}
	/* Step 3:find max evidence of array A */
	Get_RetVal = (HoughIdx*) mi_zalloc(sizeof(HoughIdx));
	if (Get_RetVal == (HoughIdx*)NULL)
	{
		mi_db_error_raise(Gen_Con,MI_EXCEPTION,"Hough memory failed in Result allocate");
		return (HoughIdx*)NULL;
	} 

	Count =0;
	for(S=0;S<MAX_S;S++)
		for(zeta_d=0;zeta_d<MAX_Z;zeta_d++)
			for(Xm=0;Xm<MAX_X;Xm++)
				for(Yn=0;Yn<MAX_Y;Yn++)
					if( *(*(*(*(A+S)+zeta_d)+Xm)+Yn) > Count)
					{
						Get_RetVal->S = S+(mi_integer)(MAX_S-1)/2;
						Get_RetVal->Z = zeta_d-(mi_integer)(MAX_Z-1)/2;
						Get_RetVal->X = Xm-(mi_integer)(MAX_X/2);
						Get_RetVal->Y = Yn-(mi_integer)(MAX_Y/2);
						Count= *(*(*(*(A+S)+zeta_d)+Xm)+Yn);
					}

	/*
	** Write to the trace file indicating
	** that Hough1 has successfully exited.
	*/
	DBDK_TRACE_EXIT( "Hough1" );

	return Get_RetVal;
}
/* Warning: Do not modify. Hough1 checksum: 566424054  */

/****************************************************************
**
** Function name:
**
**	Hough1_1
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine Hough1_1 (fing_t,fing_t) returns HoughIdx.
**
** Parameters:
**
** Return value:
**
**	HoughIdx *
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    Hough1_1 FunctionId: 42671e00-d055-11d2-b035-204c4f4f5020
**
*****************************************************************
*/
HoughIdx *
Hough1_1
(
mi_bitvarying *	Arg1,
mi_bitvarying *	Arg2,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle.             */
	HoughIdx *      Gen_RetVal;        /* The return value.                  */
	mi_integer		Q_vl_nitems;		/* number items of query fingerprint*/
	mi_integer		P_vl_nitems;		/* number items of reference fingerprint*/
	mi_int1 		**A;				/* keep evidence for Xm and Ym in Hough Algorithm */
	mi_integer		S,zeta_d,minS,maxS,minZ,maxZ,Q,P,Xm,Yn,Count,Px,Py,Qx,Qy;
	mi_double_precision  zeta_l,Sk;
	fing_t 			*Q_set,*P_set;		/* Pointer to the input data */
		
	/* struct to keep static evidence at S,zeta_l,Xm,Yn */
	struct stat {
		mi_integer	x;
		mi_integer  y;
		mi_integer	evidence;
	} Ev[SCALE+1][ROTATE+1]; /* because of in C array reference is 0..n-1*/


	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in Hough1_1."
		*/
		DBDK_TRACE_ERROR( "Hough1_1", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that Hough1_1 has been called.
	*/
	DBDK_TRACE_ENTER( "Hough1_1" );
	Q_vl_nitems =
		(mi_get_varlen( (mi_bitvarying *)Arg1 ) - sizeof( fing_t ) + sizeof( Q_set->data ))
		/ sizeof( Q_set->data );
	/* Compute the number of variable length reference intems*/
	P_vl_nitems =
		(mi_get_varlen( (mi_bitvarying *)Arg2 ) - sizeof( fing_t ) + sizeof( P_set->data ))
		/ sizeof( P_set->data );
	/* Get input data to Q set and R set */
	Q_set = (fing_t*)mi_get_vardata(Arg1);
	P_set = (fing_t*)mi_get_vardata(Arg2);
	/* Get address from fp_funcstate */
	A=(mi_int1**)mi_fp_funcstate(Gen_fparam);
	
	if (A==(mi_int1**) NULL)			 /* Not Allocate or first Call */
	{
		A=(mi_int1**)mi_dalloc(MAX_X*sizeof(mi_int1*),PER_COMMAND);
		if (A==(mi_int1**)NULL) 
		{
			mi_db_error_raise(Gen_Con,MI_EXCEPTION,"A in Xm axis has failed to allocate!");
			return (mi_integer) NULL;
		}
		for (Xm=0;Xm<=MAX_X;Xm++)
		{
			*(A+Xm)=(mi_int1*)mi_dalloc(MAX_Y*sizeof(mi_int1),PER_COMMAND);
			if (*(A+Xm)==(mi_int1*)NULL)
			{
				mi_db_error_raise(Gen_Con,MI_EXCEPTION,"A in Yn axis failed to allocate!");
				return (mi_integer) NULL;
			}
		}
		mi_fp_setfuncstate(Gen_fparam,(void**)A); /* save address to fp_funcstate */
	}
	/* Hough Procedure */
	/* Step 1:Initialize all variable */
	minS=(mi_integer)SCALE/2;
	maxS=(mi_integer)SCALE+minS;	/* Sk=S/10 = 0.5 ... 1.5  SCALE =10*/
	minZ=(mi_integer)(-1)*(ROTATE/2);
	maxZ=(mi_integer)(ROTATE/2);	/* Zeta = -90 ... 90 ROTATE=180*/
	/* Setp 2: Compute and add evidence */
	for(S=minS;S<=maxS;S++) 
	{
		for(zeta_d=minZ;zeta_d<=maxZ;zeta_d++)
		{
			for(Xm=0;Xm<MAX_X;Xm++)
				for(Yn=0;Yn<MAX_Y;Yn++)
					*(*(A+Xm)+Yn) = 0;	/*clear data in Xm,Yn index to zero */
			for(P=0;P<P_vl_nitems;P++)	/* (Rx,Ry,Alpha) in reference set */
				for(Q=0;Q<Q_vl_nitems;Q++) /* (Qx,Qy,Beta) in query set */
					if(P_set->data[P].Zeta+zeta_d==Q_set->data[Q].Zeta)  /* Alpha+Zeta=Beta*/
					{
						zeta_l=zeta_d*PI/180;		/* degree to radians */
						Px = P_set->data[P].X;
						Py = P_set->data[P].Y;
						Qx = Q_set->data[Q].X;
						Qy = Q_set->data[Q].Y;
						Sk = (S*1.0)/10;
						Xm = Qx-(mi_integer)(Sk*(Px*cos(zeta_l)+Py*sin(zeta_l)));
						Yn = Qy-(mi_integer)(Sk*(Py*cos(zeta_l)-Px*sin(zeta_l)));
						Xm += (mi_integer)(MAX_X/2);	/* -64 ... +63 */
						Yn += (mi_integer)(MAX_Y/2);	/* -64 ... +63 */
						if ((Xm>=0)&&(Xm<MAX_X)&&(Yn>=0)&&(Yn<MAX_Y))
							(*(*(A+Xm)+Yn))++;
					}
			Ev[S-minS][zeta_d-minZ].evidence = 0;
			/* find MAX evidence for Xm,Yn*/
			for(Xm=0;Xm<MAX_X;Xm++)	
				for(Yn=0;Yn<MAX_Y;Yn++)
					if(*(*(A+Xm)+Yn) > Ev[S-minS][zeta_d-minZ].evidence)
					{
						Ev[S-minS][zeta_d-minZ].evidence = *(*(A+Xm)+Yn);
						Ev[S-minS][zeta_d-minZ].x=Xm;
						Ev[S-minS][zeta_d-minZ].y=Yn;
					}

		}
	}
	/* Step 3:fine max evidence */
	Gen_RetVal = (HoughIdx*) mi_zalloc(sizeof(HoughIdx));
	if (Gen_RetVal == (HoughIdx*)NULL)
	{
		mi_db_error_raise(Gen_Con,MI_EXCEPTION,"Hough memory failed in Result allocate");
		return (HoughIdx*)NULL;
	} 
	/* find MAX evidence for S,Zeta_l */
	Count =0;
	for(S=minS;S<=maxS;S++)
		for(zeta_d=minZ;zeta_d<=maxZ;zeta_d++)
			if(Ev[S-minS][zeta_d-minZ].evidence > Count)
			{
				Gen_RetVal->X = (Ev[S-minS][zeta_d-minZ].x-MAX_X/2);
				Gen_RetVal->Y = (Ev[S-minS][zeta_d-minZ].y-MAX_Y/2);
				Gen_RetVal->S = S;
				Gen_RetVal->Z = zeta_d;
				Count=Ev[S-minS][zeta_d-minZ].evidence;
			}

	/*
	** Write to the trace file indicating
	** that Hough1_1 has successfully exited.
	*/
	DBDK_TRACE_EXIT( "Hough1_1" );

	return Gen_RetVal;
}
/* Warning: Do not modify. Hough1_1 checksum: 170060365  */

/****************************************************************
**
** Function name:
**
**	Hough2
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine Hough2 (fing_t,fing_t) returns fing_t.
**
** Parameters:
**
** Return value:
**
**	mi_bitvarying *
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    Hough2 FunctionId: 23468d11-cdf5-11d2-b02a-204c4f4f5020
**
*****************************************************************
*/
mi_bitvarying *
Hough2
(
mi_bitvarying *	Arg11,
mi_bitvarying *	Arg22,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle.             */
	mi_bitvarying * Gen_RetVal;        /* The return value wrapper.          */
	fing_t *        Gen_OutData;       /* The return value.                  */
	mi_integer		P_nitems,P,zeta_d;
	fing_t			*P_set;
	HoughIdx		*Hidx;
	mi_double_precision	Sk,zeta_l,Xm,Yn,Px,Py;

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in Hough2."
		*/
		DBDK_TRACE_ERROR( "Hough2", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that Hough2 has been called.
	*/
	DBDK_TRACE_ENTER( "Hough2" );

	Hidx = Hough1_1(Arg11,Arg22,Gen_fparam);
	if(Hidx == (HoughIdx*)NULL)
	{
		mi_db_error_raise(Gen_Con,MI_EXCEPTION,"Hough Index Routine return ERROR!");
		return (mi_bitvarying*)NULL;
	}
	Sk = (Hidx->S*1.0)/10;
	zeta_d = (Hidx->Z);
	zeta_l = zeta_d*PI/180;
	Xm = (Hidx->X)*1.0;
	Yn = (Hidx->Y)*1.0;
	P_nitems = (mi_get_varlen((mi_bitvarying *)Arg22)-sizeof(fing_t)+ sizeof( P_set->data ))
		/ sizeof( P_set->data );

	Gen_RetVal = (mi_bitvarying *)mi_new_var( P_nitems*sizeof(fing_t));
	if( Gen_RetVal == 0)
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in Hough2."
		*/
		DBDK_TRACE_ERROR( "Hough2", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to where the return value is to be placed. */
	Gen_OutData = (fing_t *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );
	P_set=(fing_t*)mi_get_vardata(Arg22);
	for(P=0;P<P_nitems;P++)
	{
		Px=(P_set->data[P].X)*1.0;
		Py=(P_set->data[P].Y)*1.0;
		Gen_OutData->data[P].X = (mi_integer)(Sk*(Px*cos(zeta_l)+Py*sin(zeta_l))+Xm); 		
		Gen_OutData->data[P].Y = (mi_integer)(Sk*(Py*cos(zeta_l)-Px*sin(zeta_l))+Yn);
		Gen_OutData->data[P].Zeta = P_set->data[P].Zeta+zeta_d;
	}
	/*
	** Write to the trace file indicating
	** that Hough2 has successfully exited.
	*/
	DBDK_TRACE_EXIT( "Hough2" );

	return Gen_RetVal;
}
/* Warning: Do not modify. Hough2 checksum: 206416199  */

/****************************************************************
**
** Function name:
**
**	box
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine Box (fing_t) returns HoughIdx.
**
** Parameters:
**
** Return value:
**
**	HoughIdx *
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    box FunctionId: b38ed351-d118-11d2-b037-204c4f4f5020
**
*****************************************************************
*/
HoughIdx *
box
(
mi_bitvarying *	Arg1,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle.             */
	HoughIdx *      Gen_RetVal;        /* The return value.                  */
	fing_t			*B_set;
	mi_integer		B_nitems,Xtop,Ytop,Xbottom,Ybottom,B;

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in box."
		*/
		DBDK_TRACE_ERROR( "box", ERRORMESG1, 10 );

		/* not reached */
	}
		
	/*
	** Write to the trace file indicating
	** that box has been called.
	*/
	DBDK_TRACE_ENTER( "box" );

	B_nitems = (mi_get_varlen((mi_bitvarying *)Arg1)-sizeof(fing_t)+ sizeof( B_set->data ))
		/ sizeof( B_set->data );

	B_set=(fing_t*)mi_get_vardata(Arg1);
	Xtop=Ytop=MAX_PIC;
	Xbottom=Ybottom=0;
	for(B=0;B<B_nitems;B++)
	{
		if ((B_set->data[B].X<Xtop) && (B_set->data[B].X>=0)) Xtop = B_set->data[B].X;
		if ((B_set->data[B].Y<Ytop) && (B_set->data[B].Y>=0)) Ytop = B_set->data[B].Y;
		if ((B_set->data[B].X>Xbottom) && (B_set->data[B].X>=0))Xbottom = B_set->data[B].X;
		if ((B_set->data[B].Y>Ybottom) && (B_set->data[B].Y>=0)) Ybottom = B_set->data[B].Y;
	}
	Gen_RetVal = (HoughIdx*) mi_zalloc(sizeof(HoughIdx));
	if (Gen_RetVal == (HoughIdx*)NULL)
	{
		mi_db_error_raise(Gen_Con,MI_EXCEPTION,"Hough memory failed in Result allocate");
		return (HoughIdx*)NULL;
	}
	Gen_RetVal->S = Xtop;
	Gen_RetVal->Z = Ytop;
	Gen_RetVal->X = Xbottom;
	Gen_RetVal->Y = Ybottom;

	/*
	** Write to the trace file indicating
	** that box has successfully exited.
	*/
	DBDK_TRACE_EXIT( "box" );
	return Gen_RetVal;
}
/* Warning: Do not modify. box checksum: 157126618  */

/****************************************************************
**
** Function name:
**
**	score
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine score (fing_t,fing_t) returns double precision.
**
** Parameters:
**
** Return value:
**
**	mi_double_precision *
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    score FunctionId: bafa51d0-c0a0-11d2-806f-204c4f4f5020
**
*****************************************************************
*/
mi_double_precision *
score
(
mi_bitvarying *	query,
mi_bitvarying *	reference,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	mi_double_precision *Gen_RetVal;   /* The return value. */
	MI_CONNECTION		*Gen_Con;           /* The connection handle. */
	fing_t				*R_set,*Q_set,*P_set;
	mi_integer			R_nitems,Q_nitems,R,Q;
	mi_integer			Xtop,Ytop,Xbottom,Ybottom;
	mi_integer			QXtop,QYtop,QXbottom,QYbottom;
	mi_integer			RXtop,RYtop,RXbottom,RYbottom;
	mi_integer			Count,zeta_d,Qinbox,Rinbox;
	HoughIdx			*Hidx;
	mi_double_precision	Sk,zeta_l,Xm,Yn,Px,Py,score_fing;

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )	
		DBDK_TRACE_ERROR( "score", ERRORMESG1, 10 );
	DBDK_TRACE_ENTER( "score" );
	Gen_RetVal = (mi_double_precision *)mi_alloc( sizeof( mi_double_precision * ) );
	if( Gen_RetVal == 0) 
	{
		DBDK_TRACE_ERROR( "score", ERRORMESG2, 10 );
		return (mi_double_precision*)NULL;
	}
	/* Step 1: registration */
 	Hidx = Hough1_1(query,reference,Gen_fparam);
	if(Hidx == (HoughIdx*)NULL)
	{
		mi_db_error_raise(Gen_Con,MI_EXCEPTION,"Hough Index Routine return ERROR!");
		return (mi_double_precision *)NULL;
	}
	Sk = (Hidx->S*1.0)/10;
	zeta_d = (Hidx->Z);
	zeta_l = zeta_d*PI/180;
	Xm = (Hidx->X)*1.0;
	Yn = (Hidx->Y)*1.0;

	/* Compute number of reference fingerprint (fingerprint in database) */
	R_nitems = (mi_get_varlen((mi_bitvarying *)reference)-sizeof(fing_t)+ sizeof( R_set->data ))
		/ sizeof( R_set->data );

	/* compute number items of query fingerprint*/
	Q_nitems = (mi_get_varlen((mi_bitvarying *)query)-sizeof(fing_t)+ sizeof( Q_set->data ))
		/ sizeof( Q_set->data );

	/* Step 1.1 : Compute result fingerprint  from Hough */

	/* Point to where the return value is to be placed. */
	P_set=(fing_t*)mi_get_vardata((mi_lvarchar*)reference);
	R_set=(fing_t*)mi_zalloc(sizeof(fing_t)*R_nitems);
	for(R=0;R<R_nitems;R++)
	{
		Px=(P_set->data[R].X)*1.0;
		Py=(P_set->data[R].Y)*1.0;
		R_set->data[R].X = (mi_integer)(Sk*(Px*cos(zeta_l)+Py*sin(zeta_l))+Xm); 		
		R_set->data[R].Y = (mi_integer)(Sk*(Py*cos(zeta_l)-Px*sin(zeta_l))+Yn);
		R_set->data[R].Zeta = P_set->data[R].Zeta+zeta_d;
		/* Zeta is in 0<=Zeta<180 */
		if (R_set->data[R].Zeta >= 180)
			R_set->data[R].Zeta -= 180;
		else if (R_set->data[R].Zeta <0)
			R_set->data[R].Zeta +=180;
	}
	/* The Result from Hough transform,its may be negative in some items */
	
	/* Step 1.2 :save data to fingerprint variable */
	
	P_set=(fing_t*)mi_get_vardata((mi_lvarchar*)query);
	Q_set=(fing_t*)mi_zalloc(Q_nitems*sizeof(fing_t));
	for(Q=0;Q<Q_nitems;Q++)
	{
		Q_set->data[Q].X=P_set->data[Q].X;
		Q_set->data[Q].Y=P_set->data[Q].Y;
		Q_set->data[Q].Zeta=P_set->data[Q].Zeta;
	}

	/* Step 2: find Bounding box in each fingerprint and intersect Bounding box*/
	QXtop=QYtop=MAX_PIC;
	QXbottom=QYbottom=0;
	for(Q=0;Q<Q_nitems;Q++)
	{
		if ((Q_set->data[Q].X<QXtop) && (Q_set->data[Q].X>=0)) QXtop = Q_set->data[Q].X;
		if ((Q_set->data[Q].Y<QYtop) && (Q_set->data[Q].Y>=0)) QYtop = Q_set->data[Q].Y;
		if ((Q_set->data[Q].X>QXbottom) && (Q_set->data[Q].X>=0))QXbottom = Q_set->data[Q].X;
		if ((Q_set->data[Q].Y>QYbottom) && (Q_set->data[Q].Y>=0)) QYbottom = Q_set->data[Q].Y;
	}
	RXtop=RYtop=MAX_PIC;
	RXbottom=RYbottom=0;
	for(R=0;R<R_nitems;R++)
	{
		if ((R_set->data[R].X<RXtop) && (R_set->data[R].X>=0)) RXtop = R_set->data[R].X;
		if ((R_set->data[R].Y<RYtop) && (R_set->data[R].Y>=0)) RYtop = R_set->data[R].Y;
		if ((R_set->data[R].X>RXbottom) && (R_set->data[R].X>=0))RXbottom = R_set->data[R].X;
		if ((R_set->data[R].Y>RYbottom) && (R_set->data[R].Y>=0)) RYbottom = R_set->data[R].Y;
	}
	/* find Boundind box */
	Xtop = (QXtop > RXtop) ? QXtop : RXtop;
	Ytop = (QYtop > RYtop) ? QYtop : RYtop;
	Xbottom = (QXbottom > RXbottom) ? RXbottom : QXbottom;
	Ybottom = (QYbottom > RYbottom) ? RYbottom : QYbottom;

	/* Step 2.1: mark features not in Bounding box */
	/* if Q features not in Bounding box ,mark it not to compare */
	/* if in Bounding Box increase Qinbox */
	Qinbox=0;
	for(Q=0;Q<Q_nitems;Q++)
		if ((Q_set->data[Q].X >= Xtop) && (Q_set->data[Q].X <= Xbottom) &&
			(Q_set->data[Q].Y >= Ytop) && (Q_set->data[Q].Y <= Ybottom))
		{
			Qinbox++;
		}
		else 
		{
			Q_set->data[Q].X = (mi_integer) MARK;
			Q_set->data[Q].Y = (mi_integer) MARK;
		}
	
	/* if R features in Bounding box ,mark it not to compare */
	/* increase Rinbox */
	Rinbox =0;
	for(R=0;R<R_nitems;R++)
		if ((R_set->data[R].X >= Xtop) && (R_set->data[R].X <= Xbottom) &&
			(R_set->data[R].Y >= Ytop) && (R_set->data[R].Y <= Ybottom))
		{
			Rinbox++;
		}
		else 
		{
			R_set->data[R].X = (mi_integer) MARK;
			R_set->data[R].Y = (mi_integer) MARK;
		}
	
	/* Step 3: pair each feature of fingerprint and compute Score for each paired */
	/* if 'Oriented filed' is in Zeta +5 and -5 angle degree */
	Count = 0;
	score_fing = 0.0;
	if( (Qinbox != 0) && (Rinbox != 0) )
	{
		for (Q=0;Q<Q_nitems;Q++)
			for (R=0;R<R_nitems;R++)
				if(	(R_set->data[R].Zeta >=0) &&
					(R_set->data[R].X >=0) &&
					(R_set->data[R].Y >=0) &&
					(Q_set->data[Q].Zeta >=0) &&
					(Q_set->data[Q].X >=0) &&
					(Q_set->data[Q].Y >=0) &&
					(R_set->data[R].Zeta <= (Q_set->data[Q].Zeta+5)) &&
					(R_set->data[R].Zeta >= (Q_set->data[Q].Zeta-5)) &&	
					(R_set->data[R].X >= (Q_set->data[Q].X-BOUND)) &&
					(R_set->data[R].X <= (Q_set->data[Q].X+BOUND)) &&
					(R_set->data[R].Y >= (Q_set->data[Q].Y-BOUND)) &&
					(R_set->data[R].Y <= (Q_set->data[Q].Y+BOUND))	)
					{
						Count++;
						/* mark not paired it again */
						R_set->data[R].X = (mi_integer) MARK;
						R_set->data[R].Y = (mi_integer) MARK;
						R_set->data[R].Zeta = (mi_integer) MARK; 
					} 
		score_fing = (Count*Count*1.0)/(Qinbox*Rinbox*1.0);
	}
	mi_free(R_set);
	mi_free(Q_set);
	*Gen_RetVal = score_fing*1.0;
	DBDK_TRACE_EXIT( "score" );
	return Gen_RetVal;
}
/* Warning: Do not modify. score checksum: 815827793  */

/****************************************************************
**
** Function name:
**
**	score2
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine score2 (fing_t,fing_t) returns double precision.
**
** Parameters:
**
** Return value:
**
**	mi_double_precision *
**
** History:
**
**	Mar 06, 1999 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    score2 FunctionId: 203c7d20-d36a-11d2-b042-204c4f4f5020
**
*****************************************************************
*/
mi_double_precision *
score2
(
mi_bitvarying *	Arg1,
mi_bitvarying *	Arg2,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	mi_double_precision *Gen_RetVal;   /* The return value. */
	MI_CONNECTION		*Gen_Con;           /* The connection handle. */
	fing_t				*R_set,*Q_set,*P_set;
	mi_integer			R_nitems,Q_nitems,R,Q;
	mi_integer			Xtop,Ytop,Xbottom,Ybottom;
	mi_integer			QXtop,QYtop,QXbottom,QYbottom;
	mi_integer			RXtop,RYtop,RXbottom,RYbottom;
	mi_integer			Count,zeta_d,Qinbox,Rinbox;
	HoughIdx			*Hidx;
	mi_double_precision	Sk,zeta_l,Xm,Yn,Px,Py,score_fing;

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )	
		DBDK_TRACE_ERROR( "score2", ERRORMESG1, 10 );
	DBDK_TRACE_ENTER( "score2" );
	Gen_RetVal = (mi_double_precision *)mi_alloc( sizeof( mi_double_precision * ) );
	if( Gen_RetVal == 0) 
	{
		DBDK_TRACE_ERROR( "score2", ERRORMESG2, 10 );
		return (mi_double_precision*)NULL;
	}
	/* Step 1: registration */
 	Hidx = Hough1(Arg1,Arg2,Gen_fparam);
	if(Hidx == (HoughIdx*)NULL)
	{
		mi_db_error_raise(Gen_Con,MI_EXCEPTION,"Hough Index Routine return ERROR!");
		return (mi_double_precision *)NULL;
	}
	Sk = (Hidx->S*1.0)/10;
	zeta_d = (Hidx->Z);
	zeta_l = zeta_d*PI/180;
	Xm = (Hidx->X)*1.0;
	Yn = (Hidx->Y)*1.0;

	/* Compute number of Arg2 fingerprint (fingerprint in database) */
	R_nitems = (mi_get_varlen((mi_bitvarying *)Arg2)-sizeof(fing_t)+ sizeof( R_set->data ))
		/ sizeof( R_set->data );

	/* compute number items of Arg1 fingerprint*/
	Q_nitems = (mi_get_varlen((mi_bitvarying *)Arg1)-sizeof(fing_t)+ sizeof( Q_set->data ))
		/ sizeof( Q_set->data );

	/* Step 1.1 : Compute result fingerprint  from Hough */

	/* Point to where the return value is to be placed. */
	P_set=(fing_t*)mi_get_vardata((mi_lvarchar*)Arg2);
	R_set=(fing_t*)mi_zalloc(sizeof(fing_t)*R_nitems);
	for(R=0;R<R_nitems;R++)
	{
		Px=(P_set->data[R].X)*1.0;
		Py=(P_set->data[R].Y)*1.0;
		R_set->data[R].X = (mi_integer)(Sk*(Px*cos(zeta_l)+Py*sin(zeta_l))+Xm); 		
		R_set->data[R].Y = (mi_integer)(Sk*(Py*cos(zeta_l)-Px*sin(zeta_l))+Yn);
		R_set->data[R].Zeta = P_set->data[R].Zeta+zeta_d;
		/* Zeta is in 0<=Zeta<180 */
		if (R_set->data[R].Zeta >= 180)
			R_set->data[R].Zeta -= 180;
		else if (R_set->data[R].Zeta <0)
			R_set->data[R].Zeta +=180;
	}
	/* The Result from Hough transform,its may be negative in some items */
	
	/* Step 1.2 :save data to fingerprint variable */
	
	P_set=(fing_t*)mi_get_vardata((mi_lvarchar*)Arg1);
	Q_set=(fing_t*)mi_zalloc(Q_nitems*sizeof(fing_t));
	for(Q=0;Q<Q_nitems;Q++)
	{
		Q_set->data[Q].X=P_set->data[Q].X;
		Q_set->data[Q].Y=P_set->data[Q].Y;
		Q_set->data[Q].Zeta=P_set->data[Q].Zeta;
	}

	/* Step 2: find Bounding box in each fingerprint and intersect Bounding box*/
	QXtop=QYtop=MAX_PIC;
	QXbottom=QYbottom=0;
	for(Q=0;Q<Q_nitems;Q++)
	{
		if ((Q_set->data[Q].X<QXtop) && (Q_set->data[Q].X>=0)) QXtop = Q_set->data[Q].X;
		if ((Q_set->data[Q].Y<QYtop) && (Q_set->data[Q].Y>=0)) QYtop = Q_set->data[Q].Y;
		if ((Q_set->data[Q].X>QXbottom) && (Q_set->data[Q].X>=0))QXbottom = Q_set->data[Q].X;
		if ((Q_set->data[Q].Y>QYbottom) && (Q_set->data[Q].Y>=0)) QYbottom = Q_set->data[Q].Y;
	}
	RXtop=RYtop=MAX_PIC;
	RXbottom=RYbottom=0;
	for(R=0;R<R_nitems;R++)
	{
		if ((R_set->data[R].X<RXtop) && (R_set->data[R].X>=0)) RXtop = R_set->data[R].X;
		if ((R_set->data[R].Y<RYtop) && (R_set->data[R].Y>=0)) RYtop = R_set->data[R].Y;
		if ((R_set->data[R].X>RXbottom) && (R_set->data[R].X>=0))RXbottom = R_set->data[R].X;
		if ((R_set->data[R].Y>RYbottom) && (R_set->data[R].Y>=0)) RYbottom = R_set->data[R].Y;
	}
	/* find Boundind box */
	Xtop = (QXtop > RXtop) ? QXtop : RXtop;
	Ytop = (QYtop > RYtop) ? QYtop : RYtop;
	Xbottom = (QXbottom > RXbottom) ? RXbottom : QXbottom;
	Ybottom = (QYbottom > RYbottom) ? RYbottom : QYbottom;

	/* Step 2.1: mark features not in Bounding box */
	/* if Q features not in Bounding box ,mark it not to compare */
	/* if in Bounding Box increase Qinbox */
	Qinbox=0;
	for(Q=0;Q<Q_nitems;Q++)
		if ((Q_set->data[Q].X >= Xtop) && (Q_set->data[Q].X <= Xbottom) &&
			(Q_set->data[Q].Y >= Ytop) && (Q_set->data[Q].Y <= Ybottom))
		{
			Qinbox++;
		}
		else 
		{
			Q_set->data[Q].X = (mi_integer) MARK;
			Q_set->data[Q].Y = (mi_integer) MARK;
		}
	
	/* if R features in Bounding box ,mark it not to compare */
	/* increase Rinbox */
	Rinbox =0;
	for(R=0;R<R_nitems;R++)
		if ((R_set->data[R].X >= Xtop) && (R_set->data[R].X <= Xbottom) &&
			(R_set->data[R].Y >= Ytop) && (R_set->data[R].Y <= Ybottom))
		{
			Rinbox++;
		}
		else 
		{
			R_set->data[R].X = (mi_integer) MARK;
			R_set->data[R].Y = (mi_integer) MARK;
		}
	
	/* Step 3: pair each feature of fingerprint and compute Score for each paired */
	/* if 'Oriented filed' is in Zeta +5 and -5 angle degree */
	Count = 0;
	score_fing = 0.0;
	if( (Qinbox != 0) && (Rinbox != 0) )
	{
		for (Q=0;Q<Q_nitems;Q++)
			for (R=0;R<R_nitems;R++)
				if(	(R_set->data[R].Zeta >=0) &&
					(R_set->data[R].X >=0) &&
					(R_set->data[R].Y >=0) &&
					(Q_set->data[Q].Zeta >=0) &&
					(Q_set->data[Q].X >=0) &&
					(Q_set->data[Q].Y >=0) &&
					(R_set->data[R].Zeta <= (Q_set->data[Q].Zeta+5)) &&
					(R_set->data[R].Zeta >= (Q_set->data[Q].Zeta-5)) &&	
					(R_set->data[R].X >= (Q_set->data[Q].X-BOUND)) &&
					(R_set->data[R].X <= (Q_set->data[Q].X+BOUND)) &&
					(R_set->data[R].Y >= (Q_set->data[Q].Y-BOUND)) &&
					(R_set->data[R].Y <= (Q_set->data[Q].Y+BOUND))	)
					{
						Count++;
						/* mark not paired it again */
						R_set->data[R].X = (mi_integer) MARK;
						R_set->data[R].Y = (mi_integer) MARK;
						R_set->data[R].Zeta = (mi_integer) MARK; 
					} 
		score_fing = (Count*Count*1.0)/(Qinbox*Rinbox*1.0);
	}
	mi_free(R_set);
	mi_free(Q_set);
	*Gen_RetVal = score_fing*1.0;
	DBDK_TRACE_EXIT( "score" );
	return Gen_RetVal;
}
/* Warning: Do not modify. score2 checksum: 716255067  */

#ifdef __cplusplus

}

#endif
