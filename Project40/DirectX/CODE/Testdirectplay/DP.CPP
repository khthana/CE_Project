#include <windows.h>
#include <string.h>

#include "dp.h"

#define NUMDRIVERS	16
#define NUMSESSIONS 16
#define NUMPLAYERS	16
#define NUMMESSAGES 16

#define TIMEOUT 500		 // millisec

#define MAXBUFFERLEN 1024

typedef struct
{
	GUID guid;
	char *name;

} DPDRIVER;

typedef struct
{
	DPID dpid;
	char *friendly;
	char *formal;

} PLAYER;

typedef struct
{
	DWORD playnum;
	BYTE data[MAXBUFFERLEN];
	DWORD len;
	BOOL inuse;

} MESSAGE;

static dp_MESSAGECALLBACK *messagecallback;

static DPDRIVER dpdriver[NUMDRIVERS];
static DPSESSIONDESC dpsdesc[NUMSESSIONS];

static DWORD numdrivers;
static DWORD numsessions;
static DWORD numplayers;

static DPID dpid=(DPID)-1;

static PLAYER player[NUMPLAYERS];

static LPDIRECTPLAY lpdirplay;

static DPSESSIONDESC sdesc =
{
	0,																	//size to be filled in later by code
	{
		0x43b84ca0, 0xb806, 0x11cf, 			//This GUID was generated by the author
		{ 																//specifically for this example code
			0xbe, 0x47, 0x44, 0x45, 0x53,
			0x54, 0x0, 0x0
		}
	},
	0,																	//session identifier may as well be 0
	4,																	//maximum number of players alllowed
	0,																	//current players
	0,																	//flags to be filled in later by code
	"DirectPlay Test Session",					//name of session
	"", 																//user data
	0, 0, 															//reserved
	"", 																//password to enter session
	0, 0, 0, 0													//user data for game or session
};

/******************************************************************************
 Enumeration functions
******************************************************************************/
static BOOL PASCAL EnumPlayers(DPID dpid, LPSTR friendly, LPSTR formal,
															 DWORD flags, LPVOID context)
{
	player[numplayers].dpid = dpid;

	player[numplayers].friendly = new char[strlen(friendly) + 1];
	player[numplayers].formal 	= new char[strlen(formal) + 1];

	strcpy(player[numplayers].friendly, friendly);
	strcpy(player[numplayers].formal, formal);

	if (++numplayers == NUMPLAYERS)
	{
		return (FALSE);
	}
	else
	{
		return (TRUE);
	}
}

static BOOL PASCAL EnumSessions(LPDPSESSIONDESC lpdpsgamedesc,
																LPVOID lpcontext, LPDWORD lpdwtimeout,
																DWORD flags)
{
	if (lpdpsgamedesc == NULL)
	{
		return (FALSE); 							//timeout is the end of the road
	}

	memcpy(&dpsdesc[numsessions], lpdpsgamedesc, sizeof(dpsdesc[0]));

	if (++numsessions == NUMSESSIONS)
	{
		return (FALSE);
	}
	else
	{
		return (TRUE);
	}
}


static BOOL PASCAL EnumDrivers(LPGUID lpguid, LPSTR name, DWORD majver,
															 DWORD minver, LPVOID context)
{
	memcpy(&dpdriver[numdrivers].guid, lpguid, sizeof(dpdriver[0].guid));

	dpdriver[numdrivers].name = new char[strlen(name) + 1];
	strcpy(dpdriver[numdrivers].name, name);

	if (++numdrivers == NUMDRIVERS)
	{
		return (FALSE);
	}
	else
	{
		return (TRUE);
	}
}


/******************************************************************************
 Internal-use functions
******************************************************************************/
static void CloseDriver(void)
{
	if (lpdirplay != NULL)
	{
		lpdirplay->Release();
	}
}


static void CloseSession(void)
{
	if (lpdirplay != NULL)
	{
		lpdirplay->Close();
	}
}


static void DestroyPlayer(void)
{
	if ((lpdirplay != NULL) && (dpid != (DPID)-1))
	{
		lpdirplay->DestroyPlayer(dpid);
	}
}

/******************************************************************************
 API functions
******************************************************************************/
void dp_Update(void)
{
	static unsigned char data[MAXBUFFERLEN];
	DPMSG_ADDPLAYER *add;
	DPMSG_GENERIC *msg;
	DPID dpidfrom;
	DPID dpidto;
	HRESULT ret;
	DWORD len;
	DWORD x;

	len = MAXBUFFERLEN;

	if( lpdirplay != NULL )
	{
		ret = lpdirplay->Receive(&dpidfrom, &dpidto, DPRECEIVE_ALL, data, &len);

		if (ret == DPERR_NOMESSAGES)
		{
			return;
		}

		if (ret != DP_OK)
		{
			exit(-1);
		}

		if (dpidfrom == 0)
		{
			/* System message */
			msg = (DPMSG_GENERIC *)data;

			switch (msg->dwType)
			{
				case DPSYS_SESSIONLOST:
				{
					exit(-1); 			//not the best way to handle it...

					break;
				}
				case DPSYS_ADDPLAYER:
				{
					add = (DPMSG_ADDPLAYER *)msg;
					EnumPlayers(add->dpId, add->szLongName, add->szShortName, 0, NULL);

					break;
				}
				case DPSYS_DELETEPLAYER:
				{
					exit(-1); 			//not even close to the best way to handle this!!!

					break;
				}
			}
		}
		else
		{
			for (x=0;x<numplayers;x++)
			{
				if (player[x].dpid == dpidfrom)
				{
					(*messagecallback)(x, data, len);

					break;
				}
			}
		}

	//if we get here, the message was not from any player we know...
	}
}

void dp_Send(DWORD playnum, void *data, DWORD len)
{
	HRESULT ret;

	if (len > MAXBUFFERLEN)
	{
		len = MAXBUFFERLEN;
	}

	ret = lpdirplay->Send(dpid, DPID_ALLPLAYERS, DPSEND_GUARANTEE, data, len);

	if (ret != DP_OK)
	{
		exit(-1);
	}
}

void dp_CreatePlayer(char *friendlyname, char *formalname)
{
	HRESULT ret;

	ret = lpdirplay->CreatePlayer(&dpid, friendlyname,
																formalname, NULL);

	if (ret != DP_OK)
	{
		exit(-1);
	}
}

void dp_GetPlayerName(DWORD playnum, char **friendlyname, char **formalname)
{
	*friendlyname = player[playnum].friendly;
	*formalname 	= player[playnum].formal;
}

DWORD dp_GetNumPlayers(void)
{
	return (numplayers);
}


void dp_OpenSession(DWORD sessionnum)
{
	HRESULT ret;

	dpsdesc[sessionnum].dwFlags = DPOPEN_OPENSESSION;

	ret = lpdirplay->Open(&dpsdesc[sessionnum]);

	if (ret != DP_OK)
	{
		exit(-1);
	}

	ret = lpdirplay->EnumPlayers(sdesc.dwSession,
															 EnumPlayers, NULL, 0);

	if (ret != DP_OK)
	{
		exit(-1);
	}
}

void dp_CreateSession(void)
{
	HRESULT ret;

	sdesc.dwSize	= sizeof(sdesc);
	sdesc.dwFlags = DPOPEN_CREATESESSION;

	ret = lpdirplay->Open(&sdesc);

	if (ret != DP_OK)
	{
		exit(-1);
	}
}

char *dp_GetSessionName(DWORD sessionnum)
{
	return (dpsdesc[sessionnum].szSessionName);
}

DWORD dp_GetNumSessions(void)
{
	return (numsessions);
}

void dp_OpenDriver(DWORD drivernum)
{
	HRESULT ret;

	ret = DirectPlayCreate(&dpdriver[drivernum].guid, &lpdirplay, NULL);

	if (ret != DP_OK)
	{
		exit(-1);
	}

	sdesc.dwSize	= sizeof(sdesc);
	sdesc.dwFlags = DPENUMSESSIONS_ALL;

	ret = lpdirplay->EnumSessions(&sdesc, TIMEOUT,
																EnumSessions, NULL,
																DPENUMSESSIONS_AVAILABLE);

	if ((ret != DP_OK) && (ret != DPERR_NOSESSIONS))
	{
		exit(-1);
	}
}

char *dp_GetDriverName(DWORD drivernum)
{
	return (dpdriver[drivernum].name);
}

DWORD dp_GetNumDrivers(void)
{
	return (numdrivers);
}

void dp_Kill(void)
{
	DWORD x;

	for (x=0;x<numplayers;x++)
	{
		delete [] player[x].friendly;
		delete [] player[x].formal;
	}

	for (x=0;x<numdrivers;x++)
	{
		delete [] dpdriver[x].name;
	}

	DestroyPlayer();
	CloseSession();
	CloseDriver();
}

void dp_Init(dp_MESSAGECALLBACK *mcb)
{
	DWORD ret;

	messagecallback = mcb;

	numdrivers	= 0;
	numsessions = 0;
	numplayers	= 0;

	lpdirplay = NULL;

	ret = DirectPlayEnumerate(EnumDrivers, NULL);

	if (ret != DP_OK)
	{
		exit(-1);
	}
}
