/*
** Title:               dblogic.c
** SCCSid:              %W% %E% %U%
** CCid:                %W% %E% %U%
** Author:              
** Created:             Sep 16, 1999 07:04:34 PM
** Description:         Generated 'C' file.
** Comments:            Generated for project dblogic.4.0.
*/

/*
**  The following is placed here to insure
**  that name "mangling" does not occur.
*/
#ifdef __cplusplus

extern "C"
{

#endif

/* Standard library includes. */
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stddef.h>

/* Used by Informix GLS routines. */
#include <ifxgls.h>

/* Include when accessing the Informix API. */
#include <mi.h>

/* This is the project include file. */
#include "dblogic.h"

/****************************************************************
**
** Function name:
**
**	LocInput
**
** Description:
**
**	This function converts from the external representation of the
**	UDT type Loc to its internal representation.   The external
**	representation is a blank-separated list of values and the
**	internal representation is a 'C' structure of type Loc as
**	defined in the header file.
**
**	Data may be inserted into a table using an SQL insert statement:
**
**		insert into tablename values ( 'value-list' );
**
**	value-list is a space-delimited list of values.
**
** Special Comments:
**
**	Support routine for opaque type Loc returns Loc.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	Loc *                              The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    LocInput FunctionId: 4a21b823-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
Loc *
LocInput
(
mi_lvarchar *           Gen_param1,        /* Pointer to the input text.         */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	gl_mchar_t *    Gen_InData;        /* Pointer to the input data.         */
	Loc *           Gen_OutData;       /* Pointer to the output data.        */
	mi_integer      Gen_DataLen;       /* Length of the data in bytes.       */
	Loc *           Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in LocInput."
		*/
		DBDK_TRACE_ERROR( "LocInput", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that LocInput has been called.
	*/
	DBDK_TRACE_ENTER( "LocInput" );

	/* Allocate memory room to build the UDT in. */
	Gen_RetVal = (Loc *)mi_alloc( sizeof( Loc ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in LocInput."
		*/
		DBDK_TRACE_ERROR( "LocInput", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = (gl_mchar_t *)mi_get_vardata( Gen_param1 );


	/* Point to the output data. */
	Gen_OutData = (Loc *)Gen_RetVal;

	/* Get the length of the input string. */
	Gen_DataLen = mi_get_varlen( Gen_param1 );

	/* Get the data value for Gen_OutData->Xpos. */
	Gen_InData = Gen_sscanf( Gen_Con, "LocInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Xpos );

	/* Get the data value for Gen_OutData->Ypos. */
	Gen_InData = Gen_sscanf( Gen_Con, "LocInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Ypos );


	/*
	** Write to the trace file indicating
	** that LocInput has successfully exited.
	*/
	DBDK_TRACE_EXIT( "LocInput" );

	/* Close the connection. */
	mi_close( Gen_Con );

	/* Return the UDT value. */
	return Gen_RetVal;
}
/* Warning: Do not modify. LocInput checksum: 104145684  */

/****************************************************************
**
** Function name:
**
**	LocOutput
**
** Description:
**
**	This function converts from the internal representation of the
**	UDT type Loc to its external representation.   The external
**	representation is a blank-separated list of values and the
**	internal representation is a 'C' structure of type Loc as
**	defined in the header file.
**
**	Data may be retrieved from a table using an SQL select statement:
**
**		select * from tablename;
**
** Special Comments:
**
**	Support routine for opaque type Loc returns lvarchar.
**
** Parameters:
**
**	Loc *           Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    LocOutput FunctionId: 4a21b824-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_lvarchar *
LocOutput
(
Loc *                   Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_integer      Gen_CharLen;       /* Estimate maximum length.           */
	Loc *           Gen_InData;        /* Pointer to the input data.         */
	char *          Gen_OutData;       /* Pointer to the output data.        */
	mi_lvarchar *   Gen_RetVal;        /* The return result.                 */
	mi_integer      Gen_DataLen;       /* The data length.                   */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in LocOutput."
		*/
		DBDK_TRACE_ERROR( "LocOutput", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that LocOutput has been called.
	*/
	DBDK_TRACE_ENTER( "LocOutput" );

	/* Compute the maximum length of the text representation. */
	Gen_CharLen =    1;	/* Leave room for the NULL terminator. */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Xpos.                   */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Ypos.                   */

	/* Allocate room for the output string. */
	Gen_RetVal = mi_new_var( Gen_CharLen );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in LocOutput."
		*/
		DBDK_TRACE_ERROR( "LocOutput", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = Gen_param1;

	/* Point to the output data. */
	Gen_OutData = mi_get_vardata( Gen_RetVal );

	/* Format the attribute value into the output string. */

	/* Format the value for Gen_InData->Xpos. */
	sprintf( Gen_OutData, "(%d, ", Gen_InData->Xpos );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the value for Gen_InData->Ypos. */
	sprintf( Gen_OutData, "%d) ", Gen_InData->Ypos );
	Gen_OutData += strlen( Gen_OutData );


	/*
	** Compute the length of the data and
	** place it in the return structure.
	*/
	Gen_DataLen = (mi_integer)(Gen_OutData - mi_get_vardata( Gen_RetVal ));
	mi_set_varlen ( Gen_RetVal, Gen_DataLen );

	/*
	** Write to the trace file indicating
	** that LocOutput has successfully exited.
	*/
	DBDK_TRACE_EXIT( "LocOutput" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. LocOutput checksum: 491998720  */

/****************************************************************
**
** Function name:
**
**	LocSend
**
** Description:
**
**	The binary send function is used to convert an instance of a
**	data type between its internal representation on the server and
**	on the client.
**
** Special Comments:
**
**	Support routine for opaque type Loc returns sendrecv.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    LocSend FunctionId: 4a21b821-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_sendrecv *
LocSend
(
Loc *                   Gen_param1,        /* The UDT value                      */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	Loc *           Gen_InData;        /* Pointer to the UDT value.          */
	Loc *           Gen_OutData;       /* Pointer to the packet data.        */
	mi_sendrecv *   Gen_RetVal;        /* The return value.                  */
	mi_integer      Gen_tempval;       /* Used to transfer mi_smallint-s.    */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in LocSend."
		*/
		DBDK_TRACE_ERROR( "LocSend", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that LocSend has been called.
	*/
	DBDK_TRACE_ENTER( "LocSend" );

	/* Allocate a new return value. */
	Gen_RetVal = (mi_sendrecv *)mi_new_var( sizeof( Loc ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in LocSend."
		*/
		DBDK_TRACE_ERROR( "LocSend", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = Gen_param1;

	/* Point to the output data. */
	Gen_OutData = (Loc *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

	/* Prepare the value for Gen_OutData->Xpos. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Xpos, Gen_InData->Xpos );

	/* Prepare the value for Gen_OutData->Ypos. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Ypos, Gen_InData->Ypos );


	/*
	** Write to the trace file indicating
	** that LocSend has successfully exited.
	*/
	DBDK_TRACE_EXIT( "LocSend" );

	/* Close the connection. */
	mi_close( Gen_Con );

	/* Return the UDT for transmission. */
	return Gen_RetVal;
}
/* Warning: Do not modify. LocSend checksum: 429345015  */

/****************************************************************
**
** Function name:
**
**	LocReceive
**
** Description:
**
**	The binary receive function is used to convert an instance of a
**	data type between its internal representation on the server and
**	on the client.
**
** Special Comments:
**
**	Support routine for opaque type Loc returns Loc.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    LocReceive FunctionId: 4a21b822-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
Loc *
LocReceive
(
mi_sendrecv *           Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	Loc *           Gen_RetVal;        /* The return value.                  */
	Loc *           Gen_InData;        /* Packet data.                       */
	Loc *           Gen_OutData;       /* Output UDT value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in LocReceive."
		*/
		DBDK_TRACE_ERROR( "LocReceive", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that LocReceive has been called.
	*/
	DBDK_TRACE_ENTER( "LocReceive" );

	/* Allocate room for the UDT. */
	Gen_RetVal = (Loc *)mi_alloc( sizeof( Loc ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in LocReceive."
		*/
		DBDK_TRACE_ERROR( "LocReceive", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = (Loc *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

	/* Point to the output data. */
	Gen_OutData = (Loc *)Gen_RetVal;

	/* Copy the attribute value(s) from the transmission parcel. */
	/* Prepare the value for Gen_InData->Xpos. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Xpos, &Gen_OutData->Xpos );

	/* Prepare the value for Gen_InData->Ypos. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Ypos, &Gen_OutData->Ypos );


	/*
	** Write to the trace file indicating
	** that LocReceive has successfully exited.
	*/
	DBDK_TRACE_EXIT( "LocReceive" );

	/* Return the transmitted UDT value. */
	return Gen_RetVal;
}
/* Warning: Do not modify. LocReceive checksum: 229827494  */

/****************************************************************
**
** Function name:
**
**	LocImportText
**
** Description:
**
**	The import function enables bulk copy for user-defined types.
**	When the  LOAD statement is  used from  dbaccess to copy data
**	from a file  into the database, the  server calls the  import
**	function to convert the  incoming  value  to the data  type's
**	internal format.
**
** Special Comments:
**
**	Support routine for opaque type Loc returns Loc.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	Loc *                              The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    LocImportText FunctionId: 4a21b825-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
Loc *
LocImportText
(
mi_impexp *             Gen_param1,        /* The import text.                   */
MI_FPARAM *             Gen_fparam         /* Std info - see DBDK docs.          */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	gl_mchar_t *    Gen_InData;        /* Pointer to the data.               */
	Loc *           Gen_OutData;       /* Ptr to the output data.            */
	Loc *           Gen_RetVal;        /* The return value.                  */
	mi_integer      Gen_DataLen;       /* Length of the data in bytes.       */
	mi_integer      Gen_vl_nitems;     /* Number of items.                   */
	mi_integer      Gen_vl_itemno;     /* Dummy index.                       */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in LocImportText."
		*/
		DBDK_TRACE_ERROR( "LocImportText", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that LocImportText has been called.
	*/
	DBDK_TRACE_ENTER( "LocImportText" );

	/* Allocate memory for the return UDT. */
	Gen_RetVal = (Loc *)mi_alloc( sizeof( Loc ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in LocImportText."
		*/
		DBDK_TRACE_ERROR( "LocImportText", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData =  (gl_mchar_t *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );


	/* Point to the output data. */
	Gen_OutData = Gen_RetVal;

	/* Get the length of the input string. */
	Gen_DataLen = mi_get_varlen( (mi_lvarchar *)Gen_param1 );

	/* Fill the UDT with its value. */
	Gen_InData = Gen_sscanf( Gen_Con, "LocImportText", Gen_InData,
				mi_get_varlen( (mi_lvarchar *)Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Xpos );

	/* Fill the UDT with its value. */
	Gen_InData = Gen_sscanf( Gen_Con, "LocImportText", Gen_InData,
				mi_get_varlen( (mi_lvarchar *)Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Ypos );


	/*
	** Write to the trace file indicating
	** that LocImportText has successfully exited.
	*/
	DBDK_TRACE_EXIT( "LocImportText" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. LocImportText checksum: 916221857  */

/****************************************************************
**
** Function name:
**
**	LocExportText
**
** Description:
**
**	The export function enables bulk copy for user-defined types.
**	When the UNLOAD statement is used from  dbaccess to copy data
**	from  the  database to a  file, the  server calls the  export
**	function  to convert the outcoming  value to the data  type's
**	external format.
**
** Special Comments:
**
**	Support routine for opaque type Loc returns impexp.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	Loc *                              The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    LocExportText FunctionId: 4a21b826-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_impexp *
LocExportText
(
Loc *                   Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_integer      Gen_CharLen;       /* Maximum character length.          */
	mi_impexp *     Gen_RetVal;        /* The return result.                 */
	Loc *           Gen_InData;        /* Pointer to the input data.         */
	char *          Gen_OutData;       /* Pointer to the output data.        */
	mi_integer      Gen_DataLen;       /* The final length.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in LocExportText."
		*/
		DBDK_TRACE_ERROR( "LocExportText", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that LocExportText has been called.
	*/
	DBDK_TRACE_ENTER( "LocExportText" );

	/* Compute the maximum length of the text representation. */
	Gen_CharLen =    1;	/* Leave room for the NULL terminator. */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Xpos.                   */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Ypos.                   */

	Gen_RetVal = (mi_impexp *)mi_new_var( Gen_CharLen );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in LocExportText."
		*/
		DBDK_TRACE_ERROR( "LocExportText", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = Gen_param1;

	/* Get a pointer to where our data will be copied to. */
	Gen_OutData = mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

	/* Format the output value for Gen_InData->Xpos. */
	sprintf( Gen_OutData, "%d ", Gen_InData->Xpos );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the output value for Gen_InData->Ypos. */
	sprintf( Gen_OutData, "%d ", Gen_InData->Ypos );
	Gen_OutData += strlen( Gen_OutData );


	/*
	** Compute the length of the data and
	** place it in the return structure.
	*/
	Gen_DataLen = (mi_integer)(Gen_OutData - mi_get_vardata( (mi_lvarchar *)Gen_RetVal ));
	mi_set_varlen( (mi_lvarchar *)Gen_RetVal, Gen_DataLen );

	/*
	** Write to the trace file indicating
	** that LocExportText has successfully exited.
	*/
	DBDK_TRACE_EXIT( "LocExportText" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. LocExportText checksum: 494783447  */

/****************************************************************
**
** Function name:
**
**	LocImportBinary
**
** Description:
**
**	The  importbinary  function is  used to  support  bulk copy of
**	binary data. This function is the same as the import function,
**	except that it  operates  on internal  representations of  the
**	data type.  This function is  usually only  provided for large
**	object  data types and is called by the LOAD BINARY command of
**	dbaccess.
**
** Special Comments:
**
**	Support routine for opaque type Loc returns Loc.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	Loc *                              The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    LocImportBinary FunctionId: 4a21b827-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
Loc *
LocImportBinary
(
mi_bitvarying *         Gen_param1,        /* The input value.                   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	Loc *           Gen_RetVal;        /* The return result.                 */
	Loc *           Gen_InData;        /* The UDT input value.               */
	Loc *           Gen_OutData;       /* The transfer data.                 */

	/* Get the current connection. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in LocImportBinary."
		*/
		DBDK_TRACE_ERROR( "LocImportBinary", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that LocImportBinary has been called.
	*/
	DBDK_TRACE_ENTER( "LocImportBinary" );

	/* Allocate a new UDT for the return result. */
	Gen_RetVal = (Loc *)mi_alloc( sizeof( Loc ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in LocImportBinary."
		*/
		DBDK_TRACE_ERROR( "LocImportBinary", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the transfer data. */
	Gen_InData = (Loc *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

	/* Point to the output data. */
	Gen_OutData = (Loc *)Gen_RetVal;

	/* Transfer the data value for Gen_InData->Xpos. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Xpos, &Gen_OutData->Xpos );

	/* Transfer the data value for Gen_InData->Ypos. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Ypos, &Gen_OutData->Ypos );


	/*
	** Write to the trace file indicating
	** that LocImportBinary has successfully exited.
	*/
	DBDK_TRACE_EXIT( "LocImportBinary" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. LocImportBinary checksum: 962392238  */

/****************************************************************
**
** Function name:
**
**	LocExportBinary
**
** Description:
**
**	The  exportbinary  function  is  used  to  support  bulk  copy  of
**	binary  data.  This function is the same as  the export  function,
**	except that it  operates on  internal  representations of the data
**	type.  This  function is usually only  provided  for large  object
**	data types and is called by the UNLOAD BINARY command of dbaccess.
**
** Special Comments:
**
**	Support routine for opaque type Loc returns impexpbin.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	Loc *                              The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    LocExportBinary FunctionId: 4a21b828-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_bitvarying *
LocExportBinary
(
Loc *                   Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_bitvarying * Gen_RetVal;        /* The return value.                  */
	Loc *           Gen_InData;        /* The transfer data.                 */
	Loc *           Gen_OutData;       /* The output data.                   */

	/* Get the current connection. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in LocExportBinary."
		*/
		DBDK_TRACE_ERROR( "LocExportBinary", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that LocExportBinary has been called.
	*/
	DBDK_TRACE_ENTER( "LocExportBinary" );

	/* Allocate the output parcel. */
	Gen_RetVal = (mi_bitvarying *)mi_new_var( sizeof( Loc ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in LocExportBinary."
		*/
		DBDK_TRACE_ERROR( "LocExportBinary", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = Gen_param1;

	/* Point to the output data. */
	Gen_OutData = (Loc *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

	/* Transfer the data value for Gen_OutData->Xpos. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Xpos, Gen_InData->Xpos );

	/* Transfer the data value for Gen_OutData->Ypos. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Ypos, Gen_InData->Ypos );


	/*
	** Write to the trace file indicating
	** that LocExportBinary has successfully exited.
	*/
	DBDK_TRACE_EXIT( "LocExportBinary" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. LocExportBinary checksum: 557502200  */

/****************************************************************
**
** Function name:
**
**	LocCompare
**
** Description:
**
**	Perform the comparison operations required to compare two
**	UDT values.
**
** Special Comments:
**
**	Support routine for opaque type Loc returns integer.
**
** Parameters:
**
**	Loc *           Gen_param1;        The first UDT value to compare.
**	Loc *           Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_integer                         The comparison result.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    LocCompare FunctionId: 4a21b829-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_integer
LocCompare
(
Loc *                   Gen_param1,        /* The first UDT value to compare.    */
Loc *                   Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_integer      Gen_cc;            /* Numeric attribute difference.      */
	mi_integer      Gen_vl_lendif;     /* Data length difference.            */
	Loc *           Gen_Value1;        /* Pointer to the first value.        */
	Loc *           Gen_Value2;        /* Pointer to the second value.       */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in LocCompare."
		*/
		DBDK_TRACE_ERROR( "LocCompare", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that LocCompare has been called.
	*/
	DBDK_TRACE_ENTER( "LocCompare" );

	/* Point to the data values that are to be compared. */
	Gen_Value1 = Gen_param1;
	Gen_Value2 = Gen_param2;

	/* Compare the two values. */
	Gen_cc = Gen_Value1->Xpos - Gen_Value2->Xpos;
	if( Gen_cc )
	{
		return Gen_cc < 0 ? -1 : 1;
	}

	/* Compare the two values. */
	Gen_cc = Gen_Value1->Ypos - Gen_Value2->Ypos;
	if( Gen_cc )
	{
		return Gen_cc < 0 ? -1 : 1;
	}

	return 0;

}
/* Warning: Do not modify. LocCompare checksum: 219325160  */

/****************************************************************
**
** Function name:
**
**	LocEqual
**
** Description:
**
**	Determine if one UDT value is equal to another.
**
** Special Comments:
**
**	Support routine for opaque type Loc returns boolean.
**
** Parameters:
**
**	Loc *           Gen_param1;        The first UDT value to compare.
**	Loc *           Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                         The comparison result.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    LocEqual FunctionId: 4a21b82a-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_boolean
LocEqual
(
Loc *                   Gen_param1,        /* The first UDT value to compare.    */
Loc *                   Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(0 == LocCompare( Gen_param1,
			Gen_param2, Gen_fparam ));
}
/* Warning: Do not modify. LocEqual checksum: 29585436   */

/****************************************************************
**
** Function name:
**
**	LocNotEqual
**
** Description:
**
**	Determine if one UDT value is not equal to another.
**
** Special Comments:
**
**	Support routine for opaque type Loc returns boolean.
**
** Parameters:
**
**	Loc *           Gen_param1;        The first UDT value to compare.
**	Loc *           Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                         The comparison result.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    LocNotEqual FunctionId: 4a21b82b-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_boolean
LocNotEqual
(
Loc *                   Gen_param1,        /* The first UDT value to compare.    */
Loc *                   Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(0 != LocCompare( Gen_param1,
			Gen_param2, Gen_fparam ));
}
/* Warning: Do not modify. LocNotEqual checksum: 41121206   */

/****************************************************************
**
** Function name:
**
**	ComponentInput
**
** Description:
**
**	This function converts from the external representation of the
**	UDT type Component to its internal representation.   The external
**	representation is a blank-separated list of values and the
**	internal representation is a 'C' structure of type Component as
**	defined in the header file.
**
**	Data may be inserted into a table using an SQL insert statement:
**
**		insert into tablename values ( 'value-list' );
**
**	value-list is a space-delimited list of values.
**
** Special Comments:
**
**	Support routine for opaque type Component returns Component.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	Component *                        The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    ComponentInput FunctionId: 4a21b82e-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
Component *
ComponentInput
(
mi_lvarchar *           Gen_param1,        /* Pointer to the input text.         */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	gl_mchar_t *    Gen_InData;        /* Pointer to the input data.         */
	Component *     Gen_OutData;       /* Pointer to the output data.        */
	mi_integer      Gen_DataLen;       /* Length of the data in bytes.       */
	Component *     Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in ComponentInput."
		*/
		DBDK_TRACE_ERROR( "ComponentInput", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that ComponentInput has been called.
	*/
	DBDK_TRACE_ENTER( "ComponentInput" );

	/* Allocate memory room to build the UDT in. */
	Gen_RetVal = (Component *)mi_alloc( sizeof( Component ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in ComponentInput."
		*/
		DBDK_TRACE_ERROR( "ComponentInput", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = (gl_mchar_t *)mi_get_vardata( Gen_param1 );


	/* Point to the output data. */
	Gen_OutData = (Component *)Gen_RetVal;

	/* Get the length of the input string. */
	Gen_DataLen = mi_get_varlen( Gen_param1 );

	/* Get the data value for Gen_OutData->Component_id. */
	Gen_InData = Gen_sscanf( Gen_Con, "ComponentInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Component_id );

	/* Get the data value for Gen_OutData->Component_type. */
	Gen_InData = Gen_sscanf( Gen_Con, "ComponentInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Component_type );

	/* Get the data value for Gen_OutData->Component_loc.Xpos. */
	Gen_InData = Gen_sscanf( Gen_Con, "ComponentInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Component_loc.Xpos );

	/* Get the data value for Gen_OutData->Component_loc.Ypos. */
	Gen_InData = Gen_sscanf( Gen_Con, "ComponentInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Component_loc.Ypos );


	/*
	** Write to the trace file indicating
	** that ComponentInput has successfully exited.
	*/
	DBDK_TRACE_EXIT( "ComponentInput" );

	/* Close the connection. */
	mi_close( Gen_Con );

	/* Return the UDT value. */
	return Gen_RetVal;
}
/* Warning: Do not modify. ComponentInput checksum: 997206089  */

/****************************************************************
**
** Function name:
**
**	ComponentOutput
**
** Description:
**
**	This function converts from the internal representation of the
**	UDT type Component to its external representation.   The external
**	representation is a blank-separated list of values and the
**	internal representation is a 'C' structure of type Component as
**	defined in the header file.
**
**	Data may be retrieved from a table using an SQL select statement:
**
**		select * from tablename;
**
** Special Comments:
**
**	Support routine for opaque type Component returns lvarchar.
**
** Parameters:
**
**	Component *                        Gen_param1;   Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    ComponentOutput FunctionId: 4a21b82f-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_lvarchar *
ComponentOutput
(
Component *             Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_integer      Gen_CharLen;       /* Estimate maximum length.           */
	Component *     Gen_InData;        /* Pointer to the input data.         */
	char *          Gen_OutData;       /* Pointer to the output data.        */
	mi_lvarchar *   Gen_RetVal;        /* The return result.                 */
	mi_integer      Gen_DataLen;       /* The data length.                   */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in ComponentOutput."
		*/
		DBDK_TRACE_ERROR( "ComponentOutput", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that ComponentOutput has been called.
	*/
	DBDK_TRACE_ENTER( "ComponentOutput" );

	/* Compute the maximum length of the text representation. */
	Gen_CharLen =    1;	/* Leave room for the NULL terminator. */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Component_id.           */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Component_type.         */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Component_loc.Xpos.     */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Component_loc.Ypos.     */

	/* Allocate room for the output string. */
	Gen_RetVal = mi_new_var( Gen_CharLen );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in ComponentOutput."
		*/
		DBDK_TRACE_ERROR( "ComponentOutput", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = Gen_param1;

	/* Point to the output data. */
	Gen_OutData = mi_get_vardata( Gen_RetVal );

	/* Format the attribute value into the output string. */

	/* Format the value for Gen_InData->Component_id. */
	sprintf( Gen_OutData, "(%d, ", Gen_InData->Component_id );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the value for Gen_InData->Component_type. */
	sprintf( Gen_OutData, "%d, ", Gen_InData->Component_type );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the value for Gen_InData->Component_loc.Xpos. */
	sprintf( Gen_OutData, "(%d, ", Gen_InData->Component_loc.Xpos );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the value for Gen_InData->Component_loc.Ypos. */
	sprintf( Gen_OutData, "%d)) ", Gen_InData->Component_loc.Ypos );
	Gen_OutData += strlen( Gen_OutData );


	/*
	** Compute the length of the data and
	** place it in the return structure.
	*/
	Gen_DataLen = (mi_integer)(Gen_OutData - mi_get_vardata( Gen_RetVal ));
	mi_set_varlen ( Gen_RetVal, Gen_DataLen );

	/*
	** Write to the trace file indicating
	** that ComponentOutput has successfully exited.
	*/
	DBDK_TRACE_EXIT( "ComponentOutput" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. ComponentOutput checksum: 104555309  */

/****************************************************************
**
** Function name:
**
**	ComponentSend
**
** Description:
**
**	The binary send function is used to convert an instance of a
**	data type between its internal representation on the server and
**	on the client.
**
** Special Comments:
**
**	Support routine for opaque type Component returns sendrecv.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    ComponentSend FunctionId: 4a21b82c-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_sendrecv *
ComponentSend
(
Component *             Gen_param1,        /* The UDT value                      */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	Component *     Gen_InData;        /* Pointer to the UDT value.          */
	Component *     Gen_OutData;       /* Pointer to the packet data.        */
	mi_sendrecv *   Gen_RetVal;        /* The return value.                  */
	mi_integer      Gen_tempval;       /* Used to transfer mi_smallint-s.    */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in ComponentSend."
		*/
		DBDK_TRACE_ERROR( "ComponentSend", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that ComponentSend has been called.
	*/
	DBDK_TRACE_ENTER( "ComponentSend" );

	/* Allocate a new return value. */
	Gen_RetVal = (mi_sendrecv *)mi_new_var( sizeof( Component ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in ComponentSend."
		*/
		DBDK_TRACE_ERROR( "ComponentSend", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = Gen_param1;

	/* Point to the output data. */
	Gen_OutData = (Component *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

	/* Prepare the value for Gen_OutData->Component_id. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Component_id, Gen_InData->Component_id );

	/* Prepare the value for Gen_OutData->Component_type. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Component_type, Gen_InData->Component_type );

	/* Prepare the value for Gen_OutData->Component_loc.Xpos. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Component_loc.Xpos, Gen_InData->Component_loc.Xpos );

	/* Prepare the value for Gen_OutData->Component_loc.Ypos. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Component_loc.Ypos, Gen_InData->Component_loc.Ypos );


	/*
	** Write to the trace file indicating
	** that ComponentSend has successfully exited.
	*/
	DBDK_TRACE_EXIT( "ComponentSend" );

	/* Close the connection. */
	mi_close( Gen_Con );

	/* Return the UDT for transmission. */
	return Gen_RetVal;
}
/* Warning: Do not modify. ComponentSend checksum: 438958868  */

/****************************************************************
**
** Function name:
**
**	ComponentReceive
**
** Description:
**
**	The binary receive function is used to convert an instance of a
**	data type between its internal representation on the server and
**	on the client.
**
** Special Comments:
**
**	Support routine for opaque type Component returns Component.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    ComponentReceive FunctionId: 4a21b82d-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
Component *
ComponentReceive
(
mi_sendrecv *           Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	Component *     Gen_RetVal;        /* The return value.                  */
	Component *     Gen_InData;        /* Packet data.                       */
	Component *     Gen_OutData;       /* Output UDT value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in ComponentReceive."
		*/
		DBDK_TRACE_ERROR( "ComponentReceive", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that ComponentReceive has been called.
	*/
	DBDK_TRACE_ENTER( "ComponentReceive" );

	/* Allocate room for the UDT. */
	Gen_RetVal = (Component *)mi_alloc( sizeof( Component ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in ComponentReceive."
		*/
		DBDK_TRACE_ERROR( "ComponentReceive", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = (Component *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

	/* Point to the output data. */
	Gen_OutData = (Component *)Gen_RetVal;

	/* Copy the attribute value(s) from the transmission parcel. */
	/* Prepare the value for Gen_InData->Component_id. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Component_id, &Gen_OutData->Component_id );

	/* Prepare the value for Gen_InData->Component_type. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Component_type, &Gen_OutData->Component_type );

	/* Prepare the value for Gen_InData->Component_loc.Xpos. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Component_loc.Xpos, &Gen_OutData->Component_loc.Xpos );

	/* Prepare the value for Gen_InData->Component_loc.Ypos. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Component_loc.Ypos, &Gen_OutData->Component_loc.Ypos );


	/*
	** Write to the trace file indicating
	** that ComponentReceive has successfully exited.
	*/
	DBDK_TRACE_EXIT( "ComponentReceive" );

	/* Return the transmitted UDT value. */
	return Gen_RetVal;
}
/* Warning: Do not modify. ComponentReceive checksum: 745150743  */

/****************************************************************
**
** Function name:
**
**	ComponentImportText
**
** Description:
**
**	The import function enables bulk copy for user-defined types.
**	When the  LOAD statement is  used from  dbaccess to copy data
**	from a file  into the database, the  server calls the  import
**	function to convert the  incoming  value  to the data  type's
**	internal format.
**
** Special Comments:
**
**	Support routine for opaque type Component returns Component.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	Component *                        The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    ComponentImportText FunctionId: 4a21b830-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
Component *
ComponentImportText
(
mi_impexp *             Gen_param1,        /* The import text.                   */
MI_FPARAM *             Gen_fparam         /* Std info - see DBDK docs.          */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	gl_mchar_t *    Gen_InData;        /* Pointer to the data.               */
	Component *     Gen_OutData;       /* Ptr to the output data.            */
	Component *     Gen_RetVal;        /* The return value.                  */
	mi_integer      Gen_DataLen;       /* Length of the data in bytes.       */
	mi_integer      Gen_vl_nitems;     /* Number of items.                   */
	mi_integer      Gen_vl_itemno;     /* Dummy index.                       */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in ComponentImportText."
		*/
		DBDK_TRACE_ERROR( "ComponentImportText", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that ComponentImportText has been called.
	*/
	DBDK_TRACE_ENTER( "ComponentImportText" );

	/* Allocate memory for the return UDT. */
	Gen_RetVal = (Component *)mi_alloc( sizeof( Component ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in ComponentImportText."
		*/
		DBDK_TRACE_ERROR( "ComponentImportText", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData =  (gl_mchar_t *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );


	/* Point to the output data. */
	Gen_OutData = Gen_RetVal;

	/* Get the length of the input string. */
	Gen_DataLen = mi_get_varlen( (mi_lvarchar *)Gen_param1 );

	/* Fill the UDT with its value. */
	Gen_InData = Gen_sscanf( Gen_Con, "ComponentImportText", Gen_InData,
				mi_get_varlen( (mi_lvarchar *)Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Component_id );

	/* Fill the UDT with its value. */
	Gen_InData = Gen_sscanf( Gen_Con, "ComponentImportText", Gen_InData,
				mi_get_varlen( (mi_lvarchar *)Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Component_type );

	/* Fill the UDT with its value. */
	Gen_InData = Gen_sscanf( Gen_Con, "ComponentImportText", Gen_InData,
				mi_get_varlen( (mi_lvarchar *)Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Component_loc.Xpos );

	/* Fill the UDT with its value. */
	Gen_InData = Gen_sscanf( Gen_Con, "ComponentImportText", Gen_InData,
				mi_get_varlen( (mi_lvarchar *)Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Component_loc.Ypos );


	/*
	** Write to the trace file indicating
	** that ComponentImportText has successfully exited.
	*/
	DBDK_TRACE_EXIT( "ComponentImportText" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. ComponentImportText checksum: 584656710  */

/****************************************************************
**
** Function name:
**
**	ComponentExportText
**
** Description:
**
**	The export function enables bulk copy for user-defined types.
**	When the UNLOAD statement is used from  dbaccess to copy data
**	from  the  database to a  file, the  server calls the  export
**	function  to convert the outcoming  value to the data  type's
**	external format.
**
** Special Comments:
**
**	Support routine for opaque type Component returns impexp.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	Component *                        The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    ComponentExportText FunctionId: 4a21b831-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_impexp *
ComponentExportText
(
Component *             Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_integer      Gen_CharLen;       /* Maximum character length.          */
	mi_impexp *     Gen_RetVal;        /* The return result.                 */
	Component *     Gen_InData;        /* Pointer to the input data.         */
	char *          Gen_OutData;       /* Pointer to the output data.        */
	mi_integer      Gen_DataLen;       /* The final length.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in ComponentExportText."
		*/
		DBDK_TRACE_ERROR( "ComponentExportText", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that ComponentExportText has been called.
	*/
	DBDK_TRACE_ENTER( "ComponentExportText" );

	/* Compute the maximum length of the text representation. */
	Gen_CharLen =    1;	/* Leave room for the NULL terminator. */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Component_id.           */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Component_type.         */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Component_loc.Xpos.     */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Component_loc.Ypos.     */

	Gen_RetVal = (mi_impexp *)mi_new_var( Gen_CharLen );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in ComponentExportText."
		*/
		DBDK_TRACE_ERROR( "ComponentExportText", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = Gen_param1;

	/* Get a pointer to where our data will be copied to. */
	Gen_OutData = mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

	/* Format the output value for Gen_InData->Component_id. */
	sprintf( Gen_OutData, "%d ", Gen_InData->Component_id );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the output value for Gen_InData->Component_type. */
	sprintf( Gen_OutData, "%d ", Gen_InData->Component_type );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the output value for Gen_InData->Component_loc.Xpos. */
	sprintf( Gen_OutData, "%d ", Gen_InData->Component_loc.Xpos );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the output value for Gen_InData->Component_loc.Ypos. */
	sprintf( Gen_OutData, "%d ", Gen_InData->Component_loc.Ypos );
	Gen_OutData += strlen( Gen_OutData );


	/*
	** Compute the length of the data and
	** place it in the return structure.
	*/
	Gen_DataLen = (mi_integer)(Gen_OutData - mi_get_vardata( (mi_lvarchar *)Gen_RetVal ));
	mi_set_varlen( (mi_lvarchar *)Gen_RetVal, Gen_DataLen );

	/*
	** Write to the trace file indicating
	** that ComponentExportText has successfully exited.
	*/
	DBDK_TRACE_EXIT( "ComponentExportText" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. ComponentExportText checksum: 108654340  */

/****************************************************************
**
** Function name:
**
**	ComponentImportBinary
**
** Description:
**
**	The  importbinary  function is  used to  support  bulk copy of
**	binary data. This function is the same as the import function,
**	except that it  operates  on internal  representations of  the
**	data type.  This function is  usually only  provided for large
**	object  data types and is called by the LOAD BINARY command of
**	dbaccess.
**
** Special Comments:
**
**	Support routine for opaque type Component returns Component.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	Component *                        The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    ComponentImportBinary FunctionId: 4a21b832-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
Component *
ComponentImportBinary
(
mi_bitvarying *         Gen_param1,        /* The input value.                   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	Component *     Gen_RetVal;        /* The return result.                 */
	Component *     Gen_InData;        /* The UDT input value.               */
	Component *     Gen_OutData;       /* The transfer data.                 */

	/* Get the current connection. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in ComponentImportBinary."
		*/
		DBDK_TRACE_ERROR( "ComponentImportBinary", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that ComponentImportBinary has been called.
	*/
	DBDK_TRACE_ENTER( "ComponentImportBinary" );

	/* Allocate a new UDT for the return result. */
	Gen_RetVal = (Component *)mi_alloc( sizeof( Component ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in ComponentImportBinary."
		*/
		DBDK_TRACE_ERROR( "ComponentImportBinary", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the transfer data. */
	Gen_InData = (Component *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

	/* Point to the output data. */
	Gen_OutData = (Component *)Gen_RetVal;

	/* Transfer the data value for Gen_InData->Component_id. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Component_id, &Gen_OutData->Component_id );

	/* Transfer the data value for Gen_InData->Component_type. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Component_type, &Gen_OutData->Component_type );

	/* Transfer the data value for Gen_InData->Component_loc.Xpos. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Component_loc.Xpos, &Gen_OutData->Component_loc.Xpos );

	/* Transfer the data value for Gen_InData->Component_loc.Ypos. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Component_loc.Ypos, &Gen_OutData->Component_loc.Ypos );


	/*
	** Write to the trace file indicating
	** that ComponentImportBinary has successfully exited.
	*/
	DBDK_TRACE_EXIT( "ComponentImportBinary" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. ComponentImportBinary checksum: 194158177  */

/****************************************************************
**
** Function name:
**
**	ComponentExportBinary
**
** Description:
**
**	The  exportbinary  function  is  used  to  support  bulk  copy  of
**	binary  data.  This function is the same as  the export  function,
**	except that it  operates on  internal  representations of the data
**	type.  This  function is usually only  provided  for large  object
**	data types and is called by the UNLOAD BINARY command of dbaccess.
**
** Special Comments:
**
**	Support routine for opaque type Component returns impexpbin.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	Component *                        The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    ComponentExportBinary FunctionId: 4a21b833-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_bitvarying *
ComponentExportBinary
(
Component *             Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_bitvarying * Gen_RetVal;        /* The return value.                  */
	Component *     Gen_InData;        /* The transfer data.                 */
	Component *     Gen_OutData;       /* The output data.                   */

	/* Get the current connection. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in ComponentExportBinary."
		*/
		DBDK_TRACE_ERROR( "ComponentExportBinary", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that ComponentExportBinary has been called.
	*/
	DBDK_TRACE_ENTER( "ComponentExportBinary" );

	/* Allocate the output parcel. */
	Gen_RetVal = (mi_bitvarying *)mi_new_var( sizeof( Component ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in ComponentExportBinary."
		*/
		DBDK_TRACE_ERROR( "ComponentExportBinary", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = Gen_param1;

	/* Point to the output data. */
	Gen_OutData = (Component *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

	/* Transfer the data value for Gen_OutData->Component_id. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Component_id, Gen_InData->Component_id );

	/* Transfer the data value for Gen_OutData->Component_type. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Component_type, Gen_InData->Component_type );

	/* Transfer the data value for Gen_OutData->Component_loc.Xpos. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Component_loc.Xpos, Gen_InData->Component_loc.Xpos );

	/* Transfer the data value for Gen_OutData->Component_loc.Ypos. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Component_loc.Ypos, Gen_InData->Component_loc.Ypos );


	/*
	** Write to the trace file indicating
	** that ComponentExportBinary has successfully exited.
	*/
	DBDK_TRACE_EXIT( "ComponentExportBinary" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. ComponentExportBinary checksum: 182453946  */

/****************************************************************
**
** Function name:
**
**	ComponentCompare
**
** Description:
**
**	Perform the comparison operations required to compare two
**	UDT values.
**
** Special Comments:
**
**	Support routine for opaque type Component returns integer.
**
** Parameters:
**
**	Component *     Gen_param1;        The first UDT value to compare.
**	Component *     Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_integer                         The comparison result.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    ComponentCompare FunctionId: 4a21b834-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_integer
ComponentCompare
(
Component *             Gen_param1,        /* The first UDT value to compare.    */
Component *             Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_integer      Gen_cc;            /* Numeric attribute difference.      */
	mi_integer      Gen_vl_lendif;     /* Data length difference.            */
	Component *     Gen_Value1;        /* Pointer to the first value.        */
	Component *     Gen_Value2;        /* Pointer to the second value.       */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in ComponentCompare."
		*/
		DBDK_TRACE_ERROR( "ComponentCompare", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that ComponentCompare has been called.
	*/
	DBDK_TRACE_ENTER( "ComponentCompare" );

	/* Point to the data values that are to be compared. */
	Gen_Value1 = Gen_param1;
	Gen_Value2 = Gen_param2;

	/* Compare the two values. */
	Gen_cc = Gen_Value1->Component_id - Gen_Value2->Component_id;
	if( Gen_cc )
	{
		return Gen_cc < 0 ? -1 : 1;
	}

	return 0;

}
/* Warning: Do not modify. ComponentCompare checksum: 216360992  */

/****************************************************************
**
** Function name:
**
**	ComponentEqual
**
** Description:
**
**	Determine if one UDT value is equal to another.
**
** Special Comments:
**
**	Support routine for opaque type Component returns boolean.
**
** Parameters:
**
**	Component *     Gen_param1;        The first UDT value to compare.
**	Component *     Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                         The comparison result.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    ComponentEqual FunctionId: 4a21b835-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_boolean
ComponentEqual
(
Component *             Gen_param1,        /* The first UDT value to compare.    */
Component *             Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(0 == ComponentCompare( Gen_param1,
			Gen_param2, Gen_fparam ));
}
/* Warning: Do not modify. ComponentEqual checksum: 74871069   */

/****************************************************************
**
** Function name:
**
**	ComponentLessThan
**
** Description:
**
**	Determine if one UDT value is less than another.
**
** Special Comments:
**
**	Support routine for opaque type Component returns boolean.
**
** Parameters:
**
**	Component *     Gen_param1;        The first UDT value to compare.
**	Component *     Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                         The comparison result.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    ComponentLessThan FunctionId: 4a21b837-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_boolean
ComponentLessThan
(
Component *             Gen_param1,        /* The first UDT value to compare.    */
Component *             Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(-1 == ComponentCompare(
				Gen_param1, Gen_param2, Gen_fparam ));
}
/* Warning: Do not modify. ComponentLessThan checksum: 96134885   */

/****************************************************************
**
** Function name:
**
**	ComponentLessThanOrEqual
**
** Description:
**
**	Determine if one UDT value is less than or equal to another.
**
** Special Comments:
**
**	Support routine for opaque type Component returns boolean.
**
** Parameters:
**
**	Component *     Gen_param1;        The first UDT value to compare.
**	Component *     Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                         The comparison result.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    ComponentLessThanOrEqual FunctionId: 4a21b839-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_boolean
ComponentLessThanOrEqual
(
Component *             Gen_param1,        /* The first UDT value to compare.    */
Component *             Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(1 > ComponentCompare( Gen_param1,
				Gen_param2, Gen_fparam ));
}
/* Warning: Do not modify. ComponentLessThanOrEqual checksum: 61119839   */

/****************************************************************
**
** Function name:
**
**	ComponentGreaterThanOrEqual
**
** Description:
**
**	Determine if one UDT value is greater than or equal to another.
**
** Special Comments:
**
**	Support routine for opaque type Component returns boolean.
**
** Parameters:
**
**	Component *     Gen_param1;        The first UDT value to compare.
**	Component *     Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                         The comparison result.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    ComponentGreaterThanOrEqual FunctionId: 4a21b83a-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_boolean
ComponentGreaterThanOrEqual
(
Component *             Gen_param1,        /* The first UDT value to compare.    */
Component *             Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(-1 < ComponentCompare( Gen_param1,
			Gen_param2, Gen_fparam ) );
}
/* Warning: Do not modify. ComponentGreaterThanOrEqual checksum: 33459234   */

/****************************************************************
**
** Function name:
**
**	ComponentGreaterThan
**
** Description:
**
**	Determine if one UDT value is greater than another.
**
** Special Comments:
**
**	Support routine for opaque type Component returns boolean.
**
** Parameters:
**
**	Component *     Gen_param1;        The first UDT value to compare.
**	Component *     Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                         The comparison result.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    ComponentGreaterThan FunctionId: 4a21b838-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_boolean
ComponentGreaterThan
(
Component *             Gen_param1,        /* The first UDT value to compare.    */
Component *             Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(1 == ComponentCompare( Gen_param1,
				Gen_param2, Gen_fparam ));
}
/* Warning: Do not modify. ComponentGreaterThan checksum: 18479739   */

/****************************************************************
**
** Function name:
**
**	ComponentNotEqual
**
** Description:
**
**	Determine if one UDT value is not equal to another.
**
** Special Comments:
**
**	Support routine for opaque type Component returns boolean.
**
** Parameters:
**
**	Component *     Gen_param1;        The first UDT value to compare.
**	Component *     Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                         The comparison result.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    ComponentNotEqual FunctionId: 4a21b836-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_boolean
ComponentNotEqual
(
Component *             Gen_param1,        /* The first UDT value to compare.    */
Component *             Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(0 != ComponentCompare( Gen_param1,
			Gen_param2, Gen_fparam ));
}
/* Warning: Do not modify. ComponentNotEqual checksum: 36626163   */

/****************************************************************
**
** Function name:
**
**	PinInput
**
** Description:
**
**	This function converts from the external representation of the
**	UDT type Pin to its internal representation.   The external
**	representation is a blank-separated list of values and the
**	internal representation is a 'C' structure of type Pin as
**	defined in the header file.
**
**	Data may be inserted into a table using an SQL insert statement:
**
**		insert into tablename values ( 'value-list' );
**
**	value-list is a space-delimited list of values.
**
** Special Comments:
**
**	Support routine for opaque type Pin returns Pin.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	Pin *                              The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    PinInput FunctionId: 4a21b83d-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
Pin *
PinInput
(
mi_lvarchar *           Gen_param1,        /* Pointer to the input text.         */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	gl_mchar_t *    Gen_InData;        /* Pointer to the input data.         */
	Pin *           Gen_OutData;       /* Pointer to the output data.        */
	mi_integer      Gen_DataLen;       /* Length of the data in bytes.       */
	Pin *           Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in PinInput."
		*/
		DBDK_TRACE_ERROR( "PinInput", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that PinInput has been called.
	*/
	DBDK_TRACE_ENTER( "PinInput" );

	/* Allocate memory room to build the UDT in. */
	Gen_RetVal = (Pin *)mi_alloc( sizeof( Pin ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in PinInput."
		*/
		DBDK_TRACE_ERROR( "PinInput", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = (gl_mchar_t *)mi_get_vardata( Gen_param1 );


	/* Point to the output data. */
	Gen_OutData = (Pin *)Gen_RetVal;

	/* Get the length of the input string. */
	Gen_DataLen = mi_get_varlen( Gen_param1 );

	/* Get the data value for Gen_OutData->Pin_id. */
	Gen_InData = Gen_sscanf( Gen_Con, "PinInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Pin_id );

	/* Get the data value for Gen_OutData->Component_id. */
	Gen_InData = Gen_sscanf( Gen_Con, "PinInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Component_id );

	/* Get the data value for Gen_OutData->Pin_value. */
	Gen_InData = Gen_sscanf( Gen_Con, "PinInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Pin_value );

	/* Get the data value for Gen_OutData->pinio. */
	Gen_InData = Gen_sscanf( Gen_Con, "PinInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->pinio );

	/* Get the data value for Gen_OutData->isterminal. */
	Gen_InData = Gen_sscanf( Gen_Con, "PinInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->isterminal );


	/*
	** Write to the trace file indicating
	** that PinInput has successfully exited.
	*/
	DBDK_TRACE_EXIT( "PinInput" );

	/* Close the connection. */
	mi_close( Gen_Con );

	/* Return the UDT value. */
	return Gen_RetVal;
}
/* Warning: Do not modify. PinInput checksum: 463153485  */

/****************************************************************
**
** Function name:
**
**	PinOutput
**
** Description:
**
**	This function converts from the internal representation of the
**	UDT type Pin to its external representation.   The external
**	representation is a blank-separated list of values and the
**	internal representation is a 'C' structure of type Pin as
**	defined in the header file.
**
**	Data may be retrieved from a table using an SQL select statement:
**
**		select * from tablename;
**
** Special Comments:
**
**	Support routine for opaque type Pin returns lvarchar.
**
** Parameters:
**
**	Pin *           Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    PinOutput FunctionId: 4a21b83e-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_lvarchar *
PinOutput
(
Pin *                   Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_integer      Gen_CharLen;       /* Estimate maximum length.           */
	Pin *           Gen_InData;        /* Pointer to the input data.         */
	char *          Gen_OutData;       /* Pointer to the output data.        */
	mi_lvarchar *   Gen_RetVal;        /* The return result.                 */
	mi_integer      Gen_DataLen;       /* The data length.                   */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in PinOutput."
		*/
		DBDK_TRACE_ERROR( "PinOutput", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that PinOutput has been called.
	*/
	DBDK_TRACE_ENTER( "PinOutput" );

	/* Compute the maximum length of the text representation. */
	Gen_CharLen =    1;	/* Leave room for the NULL terminator. */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Pin_id.                 */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Component_id.           */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Pin_value.              */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->pinio.                  */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->isterminal.             */

	/* Allocate room for the output string. */
	Gen_RetVal = mi_new_var( Gen_CharLen );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in PinOutput."
		*/
		DBDK_TRACE_ERROR( "PinOutput", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = Gen_param1;

	/* Point to the output data. */
	Gen_OutData = mi_get_vardata( Gen_RetVal );

	/* Format the attribute value into the output string. */

	/* Format the value for Gen_InData->Pin_id. */
	sprintf( Gen_OutData, "(%d, ", Gen_InData->Pin_id );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the value for Gen_InData->Component_id. */
	sprintf( Gen_OutData, "%d, ", Gen_InData->Component_id );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the value for Gen_InData->Pin_value. */
	sprintf( Gen_OutData, "%d, ", Gen_InData->Pin_value );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the value for Gen_InData->pinio. */
	sprintf( Gen_OutData, "%d, ", Gen_InData->pinio );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the value for Gen_InData->isterminal. */
	sprintf( Gen_OutData, "%d) ", Gen_InData->isterminal );
	Gen_OutData += strlen( Gen_OutData );


	/*
	** Compute the length of the data and
	** place it in the return structure.
	*/
	Gen_DataLen = (mi_integer)(Gen_OutData - mi_get_vardata( Gen_RetVal ));
	mi_set_varlen ( Gen_RetVal, Gen_DataLen );

	/*
	** Write to the trace file indicating
	** that PinOutput has successfully exited.
	*/
	DBDK_TRACE_EXIT( "PinOutput" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. PinOutput checksum: 188402361  */

/****************************************************************
**
** Function name:
**
**	PinSend
**
** Description:
**
**	The binary send function is used to convert an instance of a
**	data type between its internal representation on the server and
**	on the client.
**
** Special Comments:
**
**	Support routine for opaque type Pin returns sendrecv.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    PinSend FunctionId: 4a21b83b-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_sendrecv *
PinSend
(
Pin *                   Gen_param1,        /* The UDT value                      */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	Pin *           Gen_InData;        /* Pointer to the UDT value.          */
	Pin *           Gen_OutData;       /* Pointer to the packet data.        */
	mi_sendrecv *   Gen_RetVal;        /* The return value.                  */
	mi_integer      Gen_tempval;       /* Used to transfer mi_smallint-s.    */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in PinSend."
		*/
		DBDK_TRACE_ERROR( "PinSend", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that PinSend has been called.
	*/
	DBDK_TRACE_ENTER( "PinSend" );

	/* Allocate a new return value. */
	Gen_RetVal = (mi_sendrecv *)mi_new_var( sizeof( Pin ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in PinSend."
		*/
		DBDK_TRACE_ERROR( "PinSend", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = Gen_param1;

	/* Point to the output data. */
	Gen_OutData = (Pin *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

	/* Prepare the value for Gen_OutData->Pin_id. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Pin_id, Gen_InData->Pin_id );

	/* Prepare the value for Gen_OutData->Component_id. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Component_id, Gen_InData->Component_id );

	/* Prepare the value for Gen_OutData->Pin_value. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Pin_value, Gen_InData->Pin_value );

	/* Prepare the value for Gen_OutData->pinio. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->pinio, Gen_InData->pinio );

	/* Prepare the value for Gen_OutData->isterminal. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->isterminal, Gen_InData->isterminal );


	/*
	** Write to the trace file indicating
	** that PinSend has successfully exited.
	*/
	DBDK_TRACE_EXIT( "PinSend" );

	/* Close the connection. */
	mi_close( Gen_Con );

	/* Return the UDT for transmission. */
	return Gen_RetVal;
}
/* Warning: Do not modify. PinSend checksum: 991049928  */

/****************************************************************
**
** Function name:
**
**	PinReceive
**
** Description:
**
**	The binary receive function is used to convert an instance of a
**	data type between its internal representation on the server and
**	on the client.
**
** Special Comments:
**
**	Support routine for opaque type Pin returns Pin.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    PinReceive FunctionId: 4a21b83c-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
Pin *
PinReceive
(
mi_sendrecv *           Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	Pin *           Gen_RetVal;        /* The return value.                  */
	Pin *           Gen_InData;        /* Packet data.                       */
	Pin *           Gen_OutData;       /* Output UDT value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in PinReceive."
		*/
		DBDK_TRACE_ERROR( "PinReceive", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that PinReceive has been called.
	*/
	DBDK_TRACE_ENTER( "PinReceive" );

	/* Allocate room for the UDT. */
	Gen_RetVal = (Pin *)mi_alloc( sizeof( Pin ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in PinReceive."
		*/
		DBDK_TRACE_ERROR( "PinReceive", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = (Pin *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

	/* Point to the output data. */
	Gen_OutData = (Pin *)Gen_RetVal;

	/* Copy the attribute value(s) from the transmission parcel. */
	/* Prepare the value for Gen_InData->Pin_id. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Pin_id, &Gen_OutData->Pin_id );

	/* Prepare the value for Gen_InData->Component_id. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Component_id, &Gen_OutData->Component_id );

	/* Prepare the value for Gen_InData->Pin_value. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Pin_value, &Gen_OutData->Pin_value );

	/* Prepare the value for Gen_InData->pinio. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->pinio, &Gen_OutData->pinio );

	/* Prepare the value for Gen_InData->isterminal. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->isterminal, &Gen_OutData->isterminal );


	/*
	** Write to the trace file indicating
	** that PinReceive has successfully exited.
	*/
	DBDK_TRACE_EXIT( "PinReceive" );

	/* Return the transmitted UDT value. */
	return Gen_RetVal;
}
/* Warning: Do not modify. PinReceive checksum: 791366879  */

/****************************************************************
**
** Function name:
**
**	PinImportText
**
** Description:
**
**	The import function enables bulk copy for user-defined types.
**	When the  LOAD statement is  used from  dbaccess to copy data
**	from a file  into the database, the  server calls the  import
**	function to convert the  incoming  value  to the data  type's
**	internal format.
**
** Special Comments:
**
**	Support routine for opaque type Pin returns Pin.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	Pin *                              The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    PinImportText FunctionId: 4a21b83f-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
Pin *
PinImportText
(
mi_impexp *             Gen_param1,        /* The import text.                   */
MI_FPARAM *             Gen_fparam         /* Std info - see DBDK docs.          */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	gl_mchar_t *    Gen_InData;        /* Pointer to the data.               */
	Pin *           Gen_OutData;       /* Ptr to the output data.            */
	Pin *           Gen_RetVal;        /* The return value.                  */
	mi_integer      Gen_DataLen;       /* Length of the data in bytes.       */
	mi_integer      Gen_vl_nitems;     /* Number of items.                   */
	mi_integer      Gen_vl_itemno;     /* Dummy index.                       */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in PinImportText."
		*/
		DBDK_TRACE_ERROR( "PinImportText", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that PinImportText has been called.
	*/
	DBDK_TRACE_ENTER( "PinImportText" );

	/* Allocate memory for the return UDT. */
	Gen_RetVal = (Pin *)mi_alloc( sizeof( Pin ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in PinImportText."
		*/
		DBDK_TRACE_ERROR( "PinImportText", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData =  (gl_mchar_t *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );


	/* Point to the output data. */
	Gen_OutData = Gen_RetVal;

	/* Get the length of the input string. */
	Gen_DataLen = mi_get_varlen( (mi_lvarchar *)Gen_param1 );

	/* Fill the UDT with its value. */
	Gen_InData = Gen_sscanf( Gen_Con, "PinImportText", Gen_InData,
				mi_get_varlen( (mi_lvarchar *)Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Pin_id );

	/* Fill the UDT with its value. */
	Gen_InData = Gen_sscanf( Gen_Con, "PinImportText", Gen_InData,
				mi_get_varlen( (mi_lvarchar *)Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Component_id );

	/* Fill the UDT with its value. */
	Gen_InData = Gen_sscanf( Gen_Con, "PinImportText", Gen_InData,
				mi_get_varlen( (mi_lvarchar *)Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Pin_value );

	/* Fill the UDT with its value. */
	Gen_InData = Gen_sscanf( Gen_Con, "PinImportText", Gen_InData,
				mi_get_varlen( (mi_lvarchar *)Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->pinio );

	/* Fill the UDT with its value. */
	Gen_InData = Gen_sscanf( Gen_Con, "PinImportText", Gen_InData,
				mi_get_varlen( (mi_lvarchar *)Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->isterminal );


	/*
	** Write to the trace file indicating
	** that PinImportText has successfully exited.
	*/
	DBDK_TRACE_EXIT( "PinImportText" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. PinImportText checksum: 171319047  */

/****************************************************************
**
** Function name:
**
**	PinExportText
**
** Description:
**
**	The export function enables bulk copy for user-defined types.
**	When the UNLOAD statement is used from  dbaccess to copy data
**	from  the  database to a  file, the  server calls the  export
**	function  to convert the outcoming  value to the data  type's
**	external format.
**
** Special Comments:
**
**	Support routine for opaque type Pin returns impexp.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	Pin *                              The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    PinExportText FunctionId: 4a21b840-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_impexp *
PinExportText
(
Pin *                   Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_integer      Gen_CharLen;       /* Maximum character length.          */
	mi_impexp *     Gen_RetVal;        /* The return result.                 */
	Pin *           Gen_InData;        /* Pointer to the input data.         */
	char *          Gen_OutData;       /* Pointer to the output data.        */
	mi_integer      Gen_DataLen;       /* The final length.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in PinExportText."
		*/
		DBDK_TRACE_ERROR( "PinExportText", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that PinExportText has been called.
	*/
	DBDK_TRACE_ENTER( "PinExportText" );

	/* Compute the maximum length of the text representation. */
	Gen_CharLen =    1;	/* Leave room for the NULL terminator. */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Pin_id.                 */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Component_id.           */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Pin_value.              */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->pinio.                  */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->isterminal.             */

	Gen_RetVal = (mi_impexp *)mi_new_var( Gen_CharLen );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in PinExportText."
		*/
		DBDK_TRACE_ERROR( "PinExportText", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = Gen_param1;

	/* Get a pointer to where our data will be copied to. */
	Gen_OutData = mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

	/* Format the output value for Gen_InData->Pin_id. */
	sprintf( Gen_OutData, "%d ", Gen_InData->Pin_id );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the output value for Gen_InData->Component_id. */
	sprintf( Gen_OutData, "%d ", Gen_InData->Component_id );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the output value for Gen_InData->Pin_value. */
	sprintf( Gen_OutData, "%d ", Gen_InData->Pin_value );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the output value for Gen_InData->pinio. */
	sprintf( Gen_OutData, "%d ", Gen_InData->pinio );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the output value for Gen_InData->isterminal. */
	sprintf( Gen_OutData, "%d ", Gen_InData->isterminal );
	Gen_OutData += strlen( Gen_OutData );


	/*
	** Compute the length of the data and
	** place it in the return structure.
	*/
	Gen_DataLen = (mi_integer)(Gen_OutData - mi_get_vardata( (mi_lvarchar *)Gen_RetVal ));
	mi_set_varlen( (mi_lvarchar *)Gen_RetVal, Gen_DataLen );

	/*
	** Write to the trace file indicating
	** that PinExportText has successfully exited.
	*/
	DBDK_TRACE_EXIT( "PinExportText" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. PinExportText checksum: 497680654  */

/****************************************************************
**
** Function name:
**
**	PinImportBinary
**
** Description:
**
**	The  importbinary  function is  used to  support  bulk copy of
**	binary data. This function is the same as the import function,
**	except that it  operates  on internal  representations of  the
**	data type.  This function is  usually only  provided for large
**	object  data types and is called by the LOAD BINARY command of
**	dbaccess.
**
** Special Comments:
**
**	Support routine for opaque type Pin returns Pin.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	Pin *                              The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    PinImportBinary FunctionId: 4a21b841-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
Pin *
PinImportBinary
(
mi_bitvarying *         Gen_param1,        /* The input value.                   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	Pin *           Gen_RetVal;        /* The return result.                 */
	Pin *           Gen_InData;        /* The UDT input value.               */
	Pin *           Gen_OutData;       /* The transfer data.                 */

	/* Get the current connection. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in PinImportBinary."
		*/
		DBDK_TRACE_ERROR( "PinImportBinary", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that PinImportBinary has been called.
	*/
	DBDK_TRACE_ENTER( "PinImportBinary" );

	/* Allocate a new UDT for the return result. */
	Gen_RetVal = (Pin *)mi_alloc( sizeof( Pin ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in PinImportBinary."
		*/
		DBDK_TRACE_ERROR( "PinImportBinary", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the transfer data. */
	Gen_InData = (Pin *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

	/* Point to the output data. */
	Gen_OutData = (Pin *)Gen_RetVal;

	/* Transfer the data value for Gen_InData->Pin_id. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Pin_id, &Gen_OutData->Pin_id );

	/* Transfer the data value for Gen_InData->Component_id. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Component_id, &Gen_OutData->Component_id );

	/* Transfer the data value for Gen_InData->Pin_value. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Pin_value, &Gen_OutData->Pin_value );

	/* Transfer the data value for Gen_InData->pinio. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->pinio, &Gen_OutData->pinio );

	/* Transfer the data value for Gen_InData->isterminal. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->isterminal, &Gen_OutData->isterminal );


	/*
	** Write to the trace file indicating
	** that PinImportBinary has successfully exited.
	*/
	DBDK_TRACE_EXIT( "PinImportBinary" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. PinImportBinary checksum: 936988466  */

/****************************************************************
**
** Function name:
**
**	PinExportBinary
**
** Description:
**
**	The  exportbinary  function  is  used  to  support  bulk  copy  of
**	binary  data.  This function is the same as  the export  function,
**	except that it  operates on  internal  representations of the data
**	type.  This  function is usually only  provided  for large  object
**	data types and is called by the UNLOAD BINARY command of dbaccess.
**
** Special Comments:
**
**	Support routine for opaque type Pin returns impexpbin.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	Pin *                              The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    PinExportBinary FunctionId: 4a21b842-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_bitvarying *
PinExportBinary
(
Pin *                   Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_bitvarying * Gen_RetVal;        /* The return value.                  */
	Pin *           Gen_InData;        /* The transfer data.                 */
	Pin *           Gen_OutData;       /* The output data.                   */

	/* Get the current connection. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in PinExportBinary."
		*/
		DBDK_TRACE_ERROR( "PinExportBinary", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that PinExportBinary has been called.
	*/
	DBDK_TRACE_ENTER( "PinExportBinary" );

	/* Allocate the output parcel. */
	Gen_RetVal = (mi_bitvarying *)mi_new_var( sizeof( Pin ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in PinExportBinary."
		*/
		DBDK_TRACE_ERROR( "PinExportBinary", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = Gen_param1;

	/* Point to the output data. */
	Gen_OutData = (Pin *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

	/* Transfer the data value for Gen_OutData->Pin_id. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Pin_id, Gen_InData->Pin_id );

	/* Transfer the data value for Gen_OutData->Component_id. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Component_id, Gen_InData->Component_id );

	/* Transfer the data value for Gen_OutData->Pin_value. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Pin_value, Gen_InData->Pin_value );

	/* Transfer the data value for Gen_OutData->pinio. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->pinio, Gen_InData->pinio );

	/* Transfer the data value for Gen_OutData->isterminal. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->isterminal, Gen_InData->isterminal );


	/*
	** Write to the trace file indicating
	** that PinExportBinary has successfully exited.
	*/
	DBDK_TRACE_EXIT( "PinExportBinary" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. PinExportBinary checksum: 330766121  */

/****************************************************************
**
** Function name:
**
**	PinCompare
**
** Description:
**
**	Perform the comparison operations required to compare two
**	UDT values.
**
** Special Comments:
**
**	Support routine for opaque type Pin returns integer.
**
** Parameters:
**
**	Pin *           Gen_param1;        The first UDT value to compare.
**	Pin *           Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_integer                         The comparison result.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    PinCompare FunctionId: 4a21b843-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_integer
PinCompare
(
Pin *                   Gen_param1,        /* The first UDT value to compare.    */
Pin *                   Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_integer      Gen_cc;            /* Numeric attribute difference.      */
	mi_integer      Gen_vl_lendif;     /* Data length difference.            */
	Pin *           Gen_Value1;        /* Pointer to the first value.        */
	Pin *           Gen_Value2;        /* Pointer to the second value.       */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in PinCompare."
		*/
		DBDK_TRACE_ERROR( "PinCompare", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that PinCompare has been called.
	*/
	DBDK_TRACE_ENTER( "PinCompare" );

	/* Point to the data values that are to be compared. */
	Gen_Value1 = Gen_param1;
	Gen_Value2 = Gen_param2;

	/* Compare the two values. */
	Gen_cc = Gen_Value1->Pin_id - Gen_Value2->Pin_id;
	if( Gen_cc )
	{
		return Gen_cc < 0 ? -1 : 1;
	}

	/* Compare the two values. */
	Gen_cc = Gen_Value1->Component_id - Gen_Value2->Component_id;
	if( Gen_cc )
	{
		return Gen_cc < 0 ? -1 : 1;
	}

	return 0;

}
/* Warning: Do not modify. PinCompare checksum: 994164379  */

/****************************************************************
**
** Function name:
**
**	PinEqual
**
** Description:
**
**	Determine if one UDT value is equal to another.
**
** Special Comments:
**
**	Support routine for opaque type Pin returns boolean.
**
** Parameters:
**
**	Pin *           Gen_param1;        The first UDT value to compare.
**	Pin *           Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                         The comparison result.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    PinEqual FunctionId: 4a21b844-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_boolean
PinEqual
(
Pin *                   Gen_param1,        /* The first UDT value to compare.    */
Pin *                   Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(0 == PinCompare( Gen_param1,
			Gen_param2, Gen_fparam ));
}
/* Warning: Do not modify. PinEqual checksum: 89572571   */

/****************************************************************
**
** Function name:
**
**	PinLessThan
**
** Description:
**
**	Determine if one UDT value is less than another.
**
** Special Comments:
**
**	Support routine for opaque type Pin returns boolean.
**
** Parameters:
**
**	Pin *           Gen_param1;        The first UDT value to compare.
**	Pin *           Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                         The comparison result.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    PinLessThan FunctionId: 4a21b846-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_boolean
PinLessThan
(
Pin *                   Gen_param1,        /* The first UDT value to compare.    */
Pin *                   Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(-1 == PinCompare(
				Gen_param1, Gen_param2, Gen_fparam ));
}
/* Warning: Do not modify. PinLessThan checksum: 80866897   */

/****************************************************************
**
** Function name:
**
**	PinLessThanOrEqual
**
** Description:
**
**	Determine if one UDT value is less than or equal to another.
**
** Special Comments:
**
**	Support routine for opaque type Pin returns boolean.
**
** Parameters:
**
**	Pin *           Gen_param1;        The first UDT value to compare.
**	Pin *           Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                         The comparison result.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    PinLessThanOrEqual FunctionId: 4a21b848-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_boolean
PinLessThanOrEqual
(
Pin *                   Gen_param1,        /* The first UDT value to compare.    */
Pin *                   Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(1 > PinCompare( Gen_param1,
				Gen_param2, Gen_fparam ));
}
/* Warning: Do not modify. PinLessThanOrEqual checksum: 75121573   */

/****************************************************************
**
** Function name:
**
**	PinGreaterThanOrEqual
**
** Description:
**
**	Determine if one UDT value is greater than or equal to another.
**
** Special Comments:
**
**	Support routine for opaque type Pin returns boolean.
**
** Parameters:
**
**	Pin *           Gen_param1;        The first UDT value to compare.
**	Pin *           Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                         The comparison result.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    PinGreaterThanOrEqual FunctionId: 4a21b849-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_boolean
PinGreaterThanOrEqual
(
Pin *                   Gen_param1,        /* The first UDT value to compare.    */
Pin *                   Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(-1 < PinCompare( Gen_param1,
			Gen_param2, Gen_fparam ) );
}
/* Warning: Do not modify. PinGreaterThanOrEqual checksum: 17138072   */

/****************************************************************
**
** Function name:
**
**	PinGreaterThan
**
** Description:
**
**	Determine if one UDT value is greater than another.
**
** Special Comments:
**
**	Support routine for opaque type Pin returns boolean.
**
** Parameters:
**
**	Pin *           Gen_param1;        The first UDT value to compare.
**	Pin *           Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                         The comparison result.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    PinGreaterThan FunctionId: 4a21b847-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_boolean
PinGreaterThan
(
Pin *                   Gen_param1,        /* The first UDT value to compare.    */
Pin *                   Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(1 == PinCompare( Gen_param1,
				Gen_param2, Gen_fparam ));
}
/* Warning: Do not modify. PinGreaterThan checksum: 52737805   */

/****************************************************************
**
** Function name:
**
**	PinNotEqual
**
** Description:
**
**	Determine if one UDT value is not equal to another.
**
** Special Comments:
**
**	Support routine for opaque type Pin returns boolean.
**
** Parameters:
**
**	Pin *           Gen_param1;        The first UDT value to compare.
**	Pin *           Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                         The comparison result.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    PinNotEqual FunctionId: 4a21b845-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_boolean
PinNotEqual
(
Pin *                   Gen_param1,        /* The first UDT value to compare.    */
Pin *                   Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(0 != PinCompare( Gen_param1,
			Gen_param2, Gen_fparam ));
}
/* Warning: Do not modify. PinNotEqual checksum: 41104213   */

/****************************************************************
**
** Function name:
**
**	WireInput
**
** Description:
**
**	This function converts from the external representation of the
**	UDT type Wire to its internal representation.   The external
**	representation is a blank-separated list of values and the
**	internal representation is a 'C' structure of type Wire as
**	defined in the header file.
**
**	Data may be inserted into a table using an SQL insert statement:
**
**		insert into tablename values ( 'value-list' );
**
**	value-list is a space-delimited list of values.
**
** Special Comments:
**
**	Support routine for opaque type Wire returns Wire.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	Wire *                             The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    WireInput FunctionId: 4a21b84c-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
Wire *
WireInput
(
mi_lvarchar *           Gen_param1,        /* Pointer to the input text.         */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	gl_mchar_t *    Gen_InData;        /* Pointer to the input data.         */
	Wire *          Gen_OutData;       /* Pointer to the output data.        */
	mi_integer      Gen_DataLen;       /* Length of the data in bytes.       */
	Wire *          Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in WireInput."
		*/
		DBDK_TRACE_ERROR( "WireInput", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that WireInput has been called.
	*/
	DBDK_TRACE_ENTER( "WireInput" );

	/* Allocate memory room to build the UDT in. */
	Gen_RetVal = (Wire *)mi_alloc( sizeof( Wire ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in WireInput."
		*/
		DBDK_TRACE_ERROR( "WireInput", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = (gl_mchar_t *)mi_get_vardata( Gen_param1 );


	/* Point to the output data. */
	Gen_OutData = (Wire *)Gen_RetVal;

	/* Get the length of the input string. */
	Gen_DataLen = mi_get_varlen( Gen_param1 );

	/* Get the data value for Gen_OutData->Wire_id. */
	Gen_InData = Gen_sscanf( Gen_Con, "WireInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Wire_id );

	/* Get the data value for Gen_OutData->First_comp_id. */
	Gen_InData = Gen_sscanf( Gen_Con, "WireInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->First_comp_id );

	/* Get the data value for Gen_OutData->First_pin_id. */
	Gen_InData = Gen_sscanf( Gen_Con, "WireInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->First_pin_id );

	/* Get the data value for Gen_OutData->Second_comp_id. */
	Gen_InData = Gen_sscanf( Gen_Con, "WireInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Second_comp_id );

	/* Get the data value for Gen_OutData->Second_pin_id. */
	Gen_InData = Gen_sscanf( Gen_Con, "WireInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Second_pin_id );

	/* Get the data value for Gen_OutData->Wire_value. */
	Gen_InData = Gen_sscanf( Gen_Con, "WireInput", Gen_InData,
				mi_get_varlen( Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Wire_value );


	/*
	** Write to the trace file indicating
	** that WireInput has successfully exited.
	*/
	DBDK_TRACE_EXIT( "WireInput" );

	/* Close the connection. */
	mi_close( Gen_Con );

	/* Return the UDT value. */
	return Gen_RetVal;
}
/* Warning: Do not modify. WireInput checksum: 948618444  */

/****************************************************************
**
** Function name:
**
**	WireOutput
**
** Description:
**
**	This function converts from the internal representation of the
**	UDT type Wire to its external representation.   The external
**	representation is a blank-separated list of values and the
**	internal representation is a 'C' structure of type Wire as
**	defined in the header file.
**
**	Data may be retrieved from a table using an SQL select statement:
**
**		select * from tablename;
**
** Special Comments:
**
**	Support routine for opaque type Wire returns lvarchar.
**
** Parameters:
**
**	Wire *          Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    WireOutput FunctionId: 4a21b84d-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_lvarchar *
WireOutput
(
Wire *                  Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_integer      Gen_CharLen;       /* Estimate maximum length.           */
	Wire *          Gen_InData;        /* Pointer to the input data.         */
	char *          Gen_OutData;       /* Pointer to the output data.        */
	mi_lvarchar *   Gen_RetVal;        /* The return result.                 */
	mi_integer      Gen_DataLen;       /* The data length.                   */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in WireOutput."
		*/
		DBDK_TRACE_ERROR( "WireOutput", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that WireOutput has been called.
	*/
	DBDK_TRACE_ENTER( "WireOutput" );

	/* Compute the maximum length of the text representation. */
	Gen_CharLen =    1;	/* Leave room for the NULL terminator. */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Wire_id.                */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->First_comp_id.          */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->First_pin_id.           */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Second_comp_id.         */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Second_pin_id.          */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Wire_value.             */

	/* Allocate room for the output string. */
	Gen_RetVal = mi_new_var( Gen_CharLen );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in WireOutput."
		*/
		DBDK_TRACE_ERROR( "WireOutput", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = Gen_param1;

	/* Point to the output data. */
	Gen_OutData = mi_get_vardata( Gen_RetVal );

	/* Format the attribute value into the output string. */

	/* Format the value for Gen_InData->Wire_id. */
	sprintf( Gen_OutData, "(%d, ", Gen_InData->Wire_id );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the value for Gen_InData->First_comp_id. */
	sprintf( Gen_OutData, "(%d, ", Gen_InData->First_comp_id );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the value for Gen_InData->First_pin_id. */
	sprintf( Gen_OutData, "%d), ", Gen_InData->First_pin_id );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the value for Gen_InData->Second_comp_id. */
	sprintf( Gen_OutData, "(%d, ", Gen_InData->Second_comp_id );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the value for Gen_InData->Second_pin_id. */
	sprintf( Gen_OutData, "%d), ", Gen_InData->Second_pin_id );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the value for Gen_InData->Wire_value. */
	sprintf( Gen_OutData, "%d) ", Gen_InData->Wire_value );
	Gen_OutData += strlen( Gen_OutData );


	/*
	** Compute the length of the data and
	** place it in the return structure.
	*/
	Gen_DataLen = (mi_integer)(Gen_OutData - mi_get_vardata( Gen_RetVal ));
	mi_set_varlen ( Gen_RetVal, Gen_DataLen );

	/*
	** Write to the trace file indicating
	** that WireOutput has successfully exited.
	*/
	DBDK_TRACE_EXIT( "WireOutput" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. WireOutput checksum: 988547745  */

/****************************************************************
**
** Function name:
**
**	WireSend
**
** Description:
**
**	The binary send function is used to convert an instance of a
**	data type between its internal representation on the server and
**	on the client.
**
** Special Comments:
**
**	Support routine for opaque type Wire returns sendrecv.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    WireSend FunctionId: 4a21b84a-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_sendrecv *
WireSend
(
Wire *                  Gen_param1,        /* The UDT value                      */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	Wire *          Gen_InData;        /* Pointer to the UDT value.          */
	Wire *          Gen_OutData;       /* Pointer to the packet data.        */
	mi_sendrecv *   Gen_RetVal;        /* The return value.                  */
	mi_integer      Gen_tempval;       /* Used to transfer mi_smallint-s.    */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in WireSend."
		*/
		DBDK_TRACE_ERROR( "WireSend", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that WireSend has been called.
	*/
	DBDK_TRACE_ENTER( "WireSend" );

	/* Allocate a new return value. */
	Gen_RetVal = (mi_sendrecv *)mi_new_var( sizeof( Wire ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in WireSend."
		*/
		DBDK_TRACE_ERROR( "WireSend", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = Gen_param1;

	/* Point to the output data. */
	Gen_OutData = (Wire *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

	/* Prepare the value for Gen_OutData->Wire_id. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Wire_id, Gen_InData->Wire_id );

	/* Prepare the value for Gen_OutData->First_comp_id. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->First_comp_id, Gen_InData->First_comp_id );

	/* Prepare the value for Gen_OutData->First_pin_id. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->First_pin_id, Gen_InData->First_pin_id );

	/* Prepare the value for Gen_OutData->Second_comp_id. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Second_comp_id, Gen_InData->Second_comp_id );

	/* Prepare the value for Gen_OutData->Second_pin_id. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Second_pin_id, Gen_InData->Second_pin_id );

	/* Prepare the value for Gen_OutData->Wire_value. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Wire_value, Gen_InData->Wire_value );


	/*
	** Write to the trace file indicating
	** that WireSend has successfully exited.
	*/
	DBDK_TRACE_EXIT( "WireSend" );

	/* Close the connection. */
	mi_close( Gen_Con );

	/* Return the UDT for transmission. */
	return Gen_RetVal;
}
/* Warning: Do not modify. WireSend checksum: 188450891  */

/****************************************************************
**
** Function name:
**
**	WireReceive
**
** Description:
**
**	The binary receive function is used to convert an instance of a
**	data type between its internal representation on the server and
**	on the client.
**
** Special Comments:
**
**	Support routine for opaque type Wire returns Wire.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_lvarchar *                      The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    WireReceive FunctionId: 4a21b84b-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
Wire *
WireReceive
(
mi_sendrecv *           Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	Wire *          Gen_RetVal;        /* The return value.                  */
	Wire *          Gen_InData;        /* Packet data.                       */
	Wire *          Gen_OutData;       /* Output UDT value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in WireReceive."
		*/
		DBDK_TRACE_ERROR( "WireReceive", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that WireReceive has been called.
	*/
	DBDK_TRACE_ENTER( "WireReceive" );

	/* Allocate room for the UDT. */
	Gen_RetVal = (Wire *)mi_alloc( sizeof( Wire ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in WireReceive."
		*/
		DBDK_TRACE_ERROR( "WireReceive", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = (Wire *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

	/* Point to the output data. */
	Gen_OutData = (Wire *)Gen_RetVal;

	/* Copy the attribute value(s) from the transmission parcel. */
	/* Prepare the value for Gen_InData->Wire_id. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Wire_id, &Gen_OutData->Wire_id );

	/* Prepare the value for Gen_InData->First_comp_id. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->First_comp_id, &Gen_OutData->First_comp_id );

	/* Prepare the value for Gen_InData->First_pin_id. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->First_pin_id, &Gen_OutData->First_pin_id );

	/* Prepare the value for Gen_InData->Second_comp_id. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Second_comp_id, &Gen_OutData->Second_comp_id );

	/* Prepare the value for Gen_InData->Second_pin_id. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Second_pin_id, &Gen_OutData->Second_pin_id );

	/* Prepare the value for Gen_InData->Wire_value. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Wire_value, &Gen_OutData->Wire_value );


	/*
	** Write to the trace file indicating
	** that WireReceive has successfully exited.
	*/
	DBDK_TRACE_EXIT( "WireReceive" );

	/* Return the transmitted UDT value. */
	return Gen_RetVal;
}
/* Warning: Do not modify. WireReceive checksum: 189655450  */

/****************************************************************
**
** Function name:
**
**	WireImportText
**
** Description:
**
**	The import function enables bulk copy for user-defined types.
**	When the  LOAD statement is  used from  dbaccess to copy data
**	from a file  into the database, the  server calls the  import
**	function to convert the  incoming  value  to the data  type's
**	internal format.
**
** Special Comments:
**
**	Support routine for opaque type Wire returns Wire.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	Wire *                             The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    WireImportText FunctionId: 4a21b84e-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
Wire *
WireImportText
(
mi_impexp *             Gen_param1,        /* The import text.                   */
MI_FPARAM *             Gen_fparam         /* Std info - see DBDK docs.          */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	gl_mchar_t *    Gen_InData;        /* Pointer to the data.               */
	Wire *          Gen_OutData;       /* Ptr to the output data.            */
	Wire *          Gen_RetVal;        /* The return value.                  */
	mi_integer      Gen_DataLen;       /* Length of the data in bytes.       */
	mi_integer      Gen_vl_nitems;     /* Number of items.                   */
	mi_integer      Gen_vl_itemno;     /* Dummy index.                       */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in WireImportText."
		*/
		DBDK_TRACE_ERROR( "WireImportText", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that WireImportText has been called.
	*/
	DBDK_TRACE_ENTER( "WireImportText" );

	/* Allocate memory for the return UDT. */
	Gen_RetVal = (Wire *)mi_alloc( sizeof( Wire ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in WireImportText."
		*/
		DBDK_TRACE_ERROR( "WireImportText", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData =  (gl_mchar_t *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );


	/* Point to the output data. */
	Gen_OutData = Gen_RetVal;

	/* Get the length of the input string. */
	Gen_DataLen = mi_get_varlen( (mi_lvarchar *)Gen_param1 );

	/* Fill the UDT with its value. */
	Gen_InData = Gen_sscanf( Gen_Con, "WireImportText", Gen_InData,
				mi_get_varlen( (mi_lvarchar *)Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Wire_id );

	/* Fill the UDT with its value. */
	Gen_InData = Gen_sscanf( Gen_Con, "WireImportText", Gen_InData,
				mi_get_varlen( (mi_lvarchar *)Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->First_comp_id );

	/* Fill the UDT with its value. */
	Gen_InData = Gen_sscanf( Gen_Con, "WireImportText", Gen_InData,
				mi_get_varlen( (mi_lvarchar *)Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->First_pin_id );

	/* Fill the UDT with its value. */
	Gen_InData = Gen_sscanf( Gen_Con, "WireImportText", Gen_InData,
				mi_get_varlen( (mi_lvarchar *)Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Second_comp_id );

	/* Fill the UDT with its value. */
	Gen_InData = Gen_sscanf( Gen_Con, "WireImportText", Gen_InData,
				mi_get_varlen( (mi_lvarchar *)Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Second_pin_id );

	/* Fill the UDT with its value. */
	Gen_InData = Gen_sscanf( Gen_Con, "WireImportText", Gen_InData,
				mi_get_varlen( (mi_lvarchar *)Gen_param1 ), 0,
				"%d %n",
				(char *)&Gen_OutData->Wire_value );


	/*
	** Write to the trace file indicating
	** that WireImportText has successfully exited.
	*/
	DBDK_TRACE_EXIT( "WireImportText" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. WireImportText checksum: 545237446  */

/****************************************************************
**
** Function name:
**
**	WireExportText
**
** Description:
**
**	The export function enables bulk copy for user-defined types.
**	When the UNLOAD statement is used from  dbaccess to copy data
**	from  the  database to a  file, the  server calls the  export
**	function  to convert the outcoming  value to the data  type's
**	external format.
**
** Special Comments:
**
**	Support routine for opaque type Wire returns impexp.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	Wire *                             The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    WireExportText FunctionId: 4a21b84f-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_impexp *
WireExportText
(
Wire *                  Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_integer      Gen_CharLen;       /* Maximum character length.          */
	mi_impexp *     Gen_RetVal;        /* The return result.                 */
	Wire *          Gen_InData;        /* Pointer to the input data.         */
	char *          Gen_OutData;       /* Pointer to the output data.        */
	mi_integer      Gen_DataLen;       /* The final length.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in WireExportText."
		*/
		DBDK_TRACE_ERROR( "WireExportText", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that WireExportText has been called.
	*/
	DBDK_TRACE_ENTER( "WireExportText" );

	/* Compute the maximum length of the text representation. */
	Gen_CharLen =    1;	/* Leave room for the NULL terminator. */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Wire_id.                */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->First_comp_id.          */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->First_pin_id.           */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Second_comp_id.         */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Second_pin_id.          */
	Gen_CharLen +=  12;	/* Add the length for Gen_OutData->Wire_value.             */

	Gen_RetVal = (mi_impexp *)mi_new_var( Gen_CharLen );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in WireExportText."
		*/
		DBDK_TRACE_ERROR( "WireExportText", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = Gen_param1;

	/* Get a pointer to where our data will be copied to. */
	Gen_OutData = mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

	/* Format the output value for Gen_InData->Wire_id. */
	sprintf( Gen_OutData, "%d ", Gen_InData->Wire_id );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the output value for Gen_InData->First_comp_id. */
	sprintf( Gen_OutData, "%d ", Gen_InData->First_comp_id );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the output value for Gen_InData->First_pin_id. */
	sprintf( Gen_OutData, "%d ", Gen_InData->First_pin_id );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the output value for Gen_InData->Second_comp_id. */
	sprintf( Gen_OutData, "%d ", Gen_InData->Second_comp_id );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the output value for Gen_InData->Second_pin_id. */
	sprintf( Gen_OutData, "%d ", Gen_InData->Second_pin_id );
	Gen_OutData += strlen( Gen_OutData );

	/* Format the output value for Gen_InData->Wire_value. */
	sprintf( Gen_OutData, "%d ", Gen_InData->Wire_value );
	Gen_OutData += strlen( Gen_OutData );


	/*
	** Compute the length of the data and
	** place it in the return structure.
	*/
	Gen_DataLen = (mi_integer)(Gen_OutData - mi_get_vardata( (mi_lvarchar *)Gen_RetVal ));
	mi_set_varlen( (mi_lvarchar *)Gen_RetVal, Gen_DataLen );

	/*
	** Write to the trace file indicating
	** that WireExportText has successfully exited.
	*/
	DBDK_TRACE_EXIT( "WireExportText" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. WireExportText checksum: 500256280  */

/****************************************************************
**
** Function name:
**
**	WireImportBinary
**
** Description:
**
**	The  importbinary  function is  used to  support  bulk copy of
**	binary data. This function is the same as the import function,
**	except that it  operates  on internal  representations of  the
**	data type.  This function is  usually only  provided for large
**	object  data types and is called by the LOAD BINARY command of
**	dbaccess.
**
** Special Comments:
**
**	Support routine for opaque type Wire returns Wire.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	Wire *                             The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    WireImportBinary FunctionId: 4a21b850-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
Wire *
WireImportBinary
(
mi_bitvarying *         Gen_param1,        /* The input value.                   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	Wire *          Gen_RetVal;        /* The return result.                 */
	Wire *          Gen_InData;        /* The UDT input value.               */
	Wire *          Gen_OutData;       /* The transfer data.                 */

	/* Get the current connection. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in WireImportBinary."
		*/
		DBDK_TRACE_ERROR( "WireImportBinary", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that WireImportBinary has been called.
	*/
	DBDK_TRACE_ENTER( "WireImportBinary" );

	/* Allocate a new UDT for the return result. */
	Gen_RetVal = (Wire *)mi_alloc( sizeof( Wire ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in WireImportBinary."
		*/
		DBDK_TRACE_ERROR( "WireImportBinary", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the transfer data. */
	Gen_InData = (Wire *)mi_get_vardata( (mi_lvarchar *)Gen_param1 );

	/* Point to the output data. */
	Gen_OutData = (Wire *)Gen_RetVal;

	/* Transfer the data value for Gen_InData->Wire_id. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Wire_id, &Gen_OutData->Wire_id );

	/* Transfer the data value for Gen_InData->First_comp_id. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->First_comp_id, &Gen_OutData->First_comp_id );

	/* Transfer the data value for Gen_InData->First_pin_id. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->First_pin_id, &Gen_OutData->First_pin_id );

	/* Transfer the data value for Gen_InData->Second_comp_id. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Second_comp_id, &Gen_OutData->Second_comp_id );

	/* Transfer the data value for Gen_InData->Second_pin_id. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Second_pin_id, &Gen_OutData->Second_pin_id );

	/* Transfer the data value for Gen_InData->Wire_value. */
	mi_get_integer( (mi_unsigned_char1 *)&Gen_InData->Wire_value, &Gen_OutData->Wire_value );


	/*
	** Write to the trace file indicating
	** that WireImportBinary has successfully exited.
	*/
	DBDK_TRACE_EXIT( "WireImportBinary" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. WireImportBinary checksum: 342203517  */

/****************************************************************
**
** Function name:
**
**	WireExportBinary
**
** Description:
**
**	The  exportbinary  function  is  used  to  support  bulk  copy  of
**	binary  data.  This function is the same as  the export  function,
**	except that it  operates on  internal  representations of the data
**	type.  This  function is usually only  provided  for large  object
**	data types and is called by the UNLOAD BINARY command of dbaccess.
**
** Special Comments:
**
**	Support routine for opaque type Wire returns impexpbin.
**
** Parameters:
**
**	mi_lvarchar *   Gen_param1;        Pointer to the input text.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	Wire *                             The constructed UDT value.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    WireExportBinary FunctionId: 4a21b851-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_bitvarying *
WireExportBinary
(
Wire *                  Gen_param1,        /* The UDT value.                     */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_bitvarying * Gen_RetVal;        /* The return value.                  */
	Wire *          Gen_InData;        /* The transfer data.                 */
	Wire *          Gen_OutData;       /* The output data.                   */

	/* Get the current connection. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in WireExportBinary."
		*/
		DBDK_TRACE_ERROR( "WireExportBinary", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that WireExportBinary has been called.
	*/
	DBDK_TRACE_ENTER( "WireExportBinary" );

	/* Allocate the output parcel. */
	Gen_RetVal = (mi_bitvarying *)mi_new_var( sizeof( Wire ) );
	if( Gen_RetVal == 0 )
	{
		/*
		** Memory allocation has failed so issue
		** the following message and quit.
		**
		** 	"Memory allocation has failed in WireExportBinary."
		*/
		DBDK_TRACE_ERROR( "WireExportBinary", ERRORMESG2, 10 );

		/* not reached */
	}

	/* Point to the input data. */
	Gen_InData = Gen_param1;

	/* Point to the output data. */
	Gen_OutData = (Wire *)mi_get_vardata( (mi_lvarchar *)Gen_RetVal );

	/* Transfer the data value for Gen_OutData->Wire_id. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Wire_id, Gen_InData->Wire_id );

	/* Transfer the data value for Gen_OutData->First_comp_id. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->First_comp_id, Gen_InData->First_comp_id );

	/* Transfer the data value for Gen_OutData->First_pin_id. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->First_pin_id, Gen_InData->First_pin_id );

	/* Transfer the data value for Gen_OutData->Second_comp_id. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Second_comp_id, Gen_InData->Second_comp_id );

	/* Transfer the data value for Gen_OutData->Second_pin_id. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Second_pin_id, Gen_InData->Second_pin_id );

	/* Transfer the data value for Gen_OutData->Wire_value. */
	mi_put_integer( (mi_unsigned_char1 *)&Gen_OutData->Wire_value, Gen_InData->Wire_value );


	/*
	** Write to the trace file indicating
	** that WireExportBinary has successfully exited.
	*/
	DBDK_TRACE_EXIT( "WireExportBinary" );

	/* Close the connection. */
	mi_close( Gen_Con );

	return Gen_RetVal;
}
/* Warning: Do not modify. WireExportBinary checksum: 134369466  */

/****************************************************************
**
** Function name:
**
**	WireCompare
**
** Description:
**
**	Perform the comparison operations required to compare two
**	UDT values.
**
** Special Comments:
**
**	Support routine for opaque type Wire returns integer.
**
** Parameters:
**
**	Wire *          Gen_param1;        The first UDT value to compare.
**	Wire *          Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_integer                         The comparison result.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    WireCompare FunctionId: 4a21b852-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_integer
WireCompare
(
Wire *                  Gen_param1,        /* The first UDT value to compare.    */
Wire *                  Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	MI_CONNECTION * Gen_Con;           /* The current connection.            */
	mi_integer      Gen_cc;            /* Numeric attribute difference.      */
	mi_integer      Gen_vl_lendif;     /* Data length difference.            */
	Wire *          Gen_Value1;        /* Pointer to the first value.        */
	Wire *          Gen_Value2;        /* Pointer to the second value.       */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in WireCompare."
		*/
		DBDK_TRACE_ERROR( "WireCompare", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that WireCompare has been called.
	*/
	DBDK_TRACE_ENTER( "WireCompare" );

	/* Point to the data values that are to be compared. */
	Gen_Value1 = Gen_param1;
	Gen_Value2 = Gen_param2;

	/* Compare the two values. */
	Gen_cc = Gen_Value1->Wire_id - Gen_Value2->Wire_id;
	if( Gen_cc )
	{
		return Gen_cc < 0 ? -1 : 1;
	}

	
	return 0;

}
/* Warning: Do not modify. WireCompare checksum: 441863348  */

/****************************************************************
**
** Function name:
**
**	WireEqual
**
** Description:
**
**	Determine if one UDT value is equal to another.
**
** Special Comments:
**
**	Support routine for opaque type Wire returns boolean.
**
** Parameters:
**
**	Wire *          Gen_param1;        The first UDT value to compare.
**	Wire *          Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                         The comparison result.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    WireEqual FunctionId: 4a21b853-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_boolean
WireEqual
(
Wire *                  Gen_param1,        /* The first UDT value to compare.    */
Wire *                  Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(0 == WireCompare( Gen_param1,
			Gen_param2, Gen_fparam ));
}
/* Warning: Do not modify. WireEqual checksum: 10389772   */

/****************************************************************
**
** Function name:
**
**	WireLessThan
**
** Description:
**
**	Determine if one UDT value is less than another.
**
** Special Comments:
**
**	Support routine for opaque type Wire returns boolean.
**
** Parameters:
**
**	Wire *          Gen_param1;        The first UDT value to compare.
**	Wire *          Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                         The comparison result.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    WireLessThan FunctionId: 4a21b855-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_boolean
WireLessThan
(
Wire *                  Gen_param1,        /* The first UDT value to compare.    */
Wire *                  Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(-1 == WireCompare(
				Gen_param1, Gen_param2, Gen_fparam ));
}
/* Warning: Do not modify. WireLessThan checksum: 61679163   */

/****************************************************************
**
** Function name:
**
**	WireLessThanOrEqual
**
** Description:
**
**	Determine if one UDT value is less than or equal to another.
**
** Special Comments:
**
**	Support routine for opaque type Wire returns boolean.
**
** Parameters:
**
**	Wire *          Gen_param1;        The first UDT value to compare.
**	Wire *          Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                         The comparison result.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    WireLessThanOrEqual FunctionId: 4a21b857-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_boolean
WireLessThanOrEqual
(
Wire *                  Gen_param1,        /* The first UDT value to compare.    */
Wire *                  Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(1 > WireCompare( Gen_param1,
				Gen_param2, Gen_fparam ));
}
/* Warning: Do not modify. WireLessThanOrEqual checksum: 96055252   */

/****************************************************************
**
** Function name:
**
**	WireGreaterThanOrEqual
**
** Description:
**
**	Determine if one UDT value is greater than or equal to another.
**
** Special Comments:
**
**	Support routine for opaque type Wire returns boolean.
**
** Parameters:
**
**	Wire *          Gen_param1;        The first UDT value to compare.
**	Wire *          Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                         The comparison result.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    WireGreaterThanOrEqual FunctionId: 4a21b858-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_boolean
WireGreaterThanOrEqual
(
Wire *                  Gen_param1,        /* The first UDT value to compare.    */
Wire *                  Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(-1 < WireCompare( Gen_param1,
			Gen_param2, Gen_fparam ) );
}
/* Warning: Do not modify. WireGreaterThanOrEqual checksum: 48114277   */

/****************************************************************
**
** Function name:
**
**	WireGreaterThan
**
** Description:
**
**	Determine if one UDT value is greater than another.
**
** Special Comments:
**
**	Support routine for opaque type Wire returns boolean.
**
** Parameters:
**
**	Wire *          Gen_param1;        The first UDT value to compare.
**	Wire *          Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                         The comparison result.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    WireGreaterThan FunctionId: 4a21b856-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_boolean
WireGreaterThan
(
Wire *                  Gen_param1,        /* The first UDT value to compare.    */
Wire *                  Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(1 == WireCompare( Gen_param1,
				Gen_param2, Gen_fparam ));
}
/* Warning: Do not modify. WireGreaterThan checksum: 43628912   */

/****************************************************************
**
** Function name:
**
**	WireNotEqual
**
** Description:
**
**	Determine if one UDT value is not equal to another.
**
** Special Comments:
**
**	Support routine for opaque type Wire returns boolean.
**
** Parameters:
**
**	Wire *          Gen_param1;        The first UDT value to compare.
**	Wire *          Gen_param2;        The second UDT value to compare.
**	MI_FPARAM *     Gen_fparam;        Standard info - see DBDK docs.
**
** Return value:
**
**	mi_boolean                         The comparison result.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    WireNotEqual FunctionId: 4a21b854-5e10-11d3-a6da-008048ed75bd
**
*****************************************************************
*/
mi_boolean
WireNotEqual
(
Wire *                  Gen_param1,        /* The first UDT value to compare.    */
Wire *                  Gen_param2,        /* The second UDT value to compare.   */
MI_FPARAM *             Gen_fparam         /* Standard info - see DBDK docs.     */
)
{
	/* Call Compare to perform the comparison. */
	return (mi_boolean)(0 != WireCompare( Gen_param1,
			Gen_param2, Gen_fparam ));
}
/* Warning: Do not modify. WireNotEqual checksum: 41958656   */


/****************************************************************
**
** Function name:
**
**	compgetid
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine getid (Component) returns integer.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    compgetid FunctionId: 5510bfa1-6c28-11d3-a6fa-008048ed75bd
**
*****************************************************************
*/
mi_integer
compgetid
(
Component *	comp,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle.             */
	mi_integer      Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in compgetid."
		*/
		DBDK_TRACE_ERROR( "compgetid", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that compgetid has been called.
	*/
	DBDK_TRACE_ENTER( "compgetid" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this function.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Function compgetid has not been implemented." );

	/*
	** TO DO: Compute and store your value into Gen_RetVal.
	**        The call to mi_fp_setreturnisnull informs the
	**        server that the return value is NULL.
	*/
	//mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );

	Gen_RetVal = comp->Component_id;

	/*
	** Write to the trace file indicating
	** that compgetid has successfully exited.
	*/
	DBDK_TRACE_EXIT( "compgetid" );

	return Gen_RetVal;
}
/* Warning: Do not modify. compgetid checksum: 371185836  */


/****************************************************************
**
** Function name:
**
**	compgetxpos
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine getxpos (Component) returns integer.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    compgetxpos FunctionId: 5510bfa3-6c28-11d3-a6fa-008048ed75bd
**
*****************************************************************
*/
mi_integer
compgetxpos
(
Component *	comp,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle.             */
	mi_integer      Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in compgetxpos."
		*/
		DBDK_TRACE_ERROR( "compgetxpos", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that compgetxpos has been called.
	*/
	DBDK_TRACE_ENTER( "compgetxpos" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this function.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Function compgetxpos has not been implemented." );

	/*
	** TO DO: Compute and store your value into Gen_RetVal.
	**        The call to mi_fp_setreturnisnull informs the
	**        server that the return value is NULL.
	*/
	//mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
	Gen_RetVal = comp->Component_loc.Xpos;

	/*
	** Write to the trace file indicating
	** that compgetxpos has successfully exited.
	*/
	DBDK_TRACE_EXIT( "compgetxpos" );

	return Gen_RetVal;
}
/* Warning: Do not modify. compgetxpos checksum: 977023348  */


/****************************************************************
**
** Function name:
**
**	compgetypos
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine getypos (Component) returns integer.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    compgetypos FunctionId: 5510bfa9-6c28-11d3-a6fa-008048ed75bd
**
*****************************************************************
*/
mi_integer
compgetypos
(
Component *	comp,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle.             */
	mi_integer      Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in compgetypos."
		*/
		DBDK_TRACE_ERROR( "compgetypos", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that compgetypos has been called.
	*/
	DBDK_TRACE_ENTER( "compgetypos" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this function.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Function compgetypos has not been implemented." );

	/*
	** TO DO: Compute and store your value into Gen_RetVal.
	**        The call to mi_fp_setreturnisnull informs the
	**        server that the return value is NULL.
	*/
	//mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
	Gen_RetVal = comp->Component_loc.Ypos;

	/*
	** Write to the trace file indicating
	** that compgetypos has successfully exited.
	*/
	DBDK_TRACE_EXIT( "compgetypos" );

	return Gen_RetVal;
}
/* Warning: Do not modify. compgetypos checksum: 377063771  */


/****************************************************************
**
** Function name:
**
**	compgettype
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine gettype (Component) returns integer.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    compgettype FunctionId: 5510bfa2-6c28-11d3-a6fa-008048ed75bd
**
*****************************************************************
*/
mi_integer
compgettype
(
Component *	comp,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle.             */
	mi_integer      Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in compgettype."
		*/
		DBDK_TRACE_ERROR( "compgettype", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that compgettype has been called.
	*/
	DBDK_TRACE_ENTER( "compgettype" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this function.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Function compgettype has not been implemented." );

	/*
	** TO DO: Compute and store your value into Gen_RetVal.
	**        The call to mi_fp_setreturnisnull informs the
	**        server that the return value is NULL.
	*/
	//mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
	Gen_RetVal = comp->Component_type;

	/*
	** Write to the trace file indicating
	** that compgettype has successfully exited.
	*/
	DBDK_TRACE_EXIT( "compgettype" );

	return Gen_RetVal;
}
/* Warning: Do not modify. compgettype checksum: 876851053  */

/*****************************************************************
**
** Function name:
**
**	Gen_sscanf
**
** Description:
**
**	This function converts formatted values.  The types converted are:
**
**		Type                    Format
**		==============================
**		gl_mchar_t                %C
**		mi_boolean                %b
**		mi_char                   %c
**		mi_date                   %D
**		mi_datetime               %T
**		mi_decimal/mi_numeric     %N
**		mi_double_precision       %lf
**		mi_int8                   %8
**		mi_integer                %d
**		mi_interval               %I
**		mi_long                   %ld
**		mi_money                  %m
**		mi_real                   %f
**		mi_unsigned_integer       %x
**
**	Conversion is performed from GLS text to the corresponding binary
**	representation.  The GLS text is assumed to be in the server locale.
**
**	Addition information about these data types may be found in
**	The Informix Guide to SQL: Syntax - Version 9.01.
**
** Parameters:
**
**	MI_CONNECTION * Gen_Con            The database connection.
**	char *          Gen_Caller         Name of the calling function.
**	gl_mchar_t *    Gen_InData         The input string data.
**	mi_integer      Gen_InDataLen      The length of Gen_InData.
**	mi_integer      Gen_Width          Max length if data is text.
**	char *          Gen_Format         The data's format.
**	char *          Gen_Result         Place the result here.
**
** Return value:
**
**	gl_mchar_t *                       The new scan position.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    Gen_sscanf FunctionId: 3AC0E360-5A81-11d0-A2E7-00AA0009BF87
**
******************************************************************
*/
gl_mchar_t *
Gen_sscanf
(
MI_CONNECTION *         Gen_Con,           /* The database connection.           */
char *                  Gen_Caller,        /* Name of the calling function.      */
gl_mchar_t *            Gen_InData,        /* The input string data.             */
mi_integer              Gen_InDataLen,     /* The length of Gen_InData.          */
mi_integer              Gen_Width,         /* Max length if data is text.        */
char *                  Gen_Format,        /* The data's format.                 */
char *                  Gen_Result         /* Place the result here.             */
)
{
	gl_mchar_t *    Gen_In;            /* Scanning ptr.                      */
	gl_mchar_t *    Gen_SaveIn;        /* Save Gen_In here.                  */
	gl_mchar_t      Gen_NextChar;      /* Get the next char here.            */
	char *          Gen_InStart;       /* Gen_In before advancement.         */
	gl_mchar_t *    Gen_Out;           /* Place the GLS result here.         */
	mi_integer      Gen_ByteCount;     /* The number of bytes.               */

	Gen_In        = Gen_InData;
	Gen_Out       = (gl_mchar_t *)Gen_Result;
	Gen_ByteCount = 0;

	/* Scan past non-format characters. */
	while( *Gen_Format && *Gen_In )
	{
		/* Scan past and ignore white space in the data. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-blank. */
			if( !ifx_gl_ismblank( Gen_In, 4 ) )
			{
				break;
			}

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );
		}

		/* Check for the format character. */
		if( *Gen_Format == '%' )
		{
			break;
		}

		/*
		**	The format character and the input string
		**	must match up to the format character.
		**	If not, issue a message.
		*/
		if( *(char *)Gen_In != *Gen_Format )
		{
			goto parse_error;
		}

		/* Keep track of how far we've advanced. */
		Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

		/* Advance to the next character. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/* Advance to the next character. */
		++Gen_Format;
	}

	/*	Check for no input data string. */
	if( *(char *)Gen_In == '\0' )
	{
		goto parse_error;
	}

	/* The following code now handles the various format types. */

	if( !strncmp( Gen_Format, "%s %n", 5 ) && Gen_Width )
	{
		if( '"' != *Gen_In )
		{
			/*
			** Input parsing has failed so issue
			** the following message and quit.
			**
			** 	"Double-quoted string expected
			**	 in input in <Gen_Caller>."
			*/
			DBDK_TRACE_ERROR( Gen_Caller, ERRORMESG7, 10 );

			/* not reached */
		}

		/* Advance past the leading quote. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/* Copy while there's sufficient room. */
		while( Gen_Width )
		{
			Gen_InStart = (char *)Gen_In;

			switch( *Gen_In )
			{
				/*
				** If '"' is seen, check to see
				** if the next character is also
				** a '"'. If so, '"' is embedded.
				** Otherwise, it is EOS.
				*/
				case '"':
					Gen_SaveIn = Gen_In;
					Gen_NextChar = *ifx_gl_mbsnext( Gen_In, 4 );
					Gen_In = Gen_SaveIn;
					if( Gen_NextChar == '"' )
					{
						*Gen_Out++ = '"';

						/* Advance past the first quote. */
						Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

						/* Advance past the second space. */
						Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

						break;
					}

					*Gen_Out = (char)'\0';

					/* Advance past the trailing quote. */
					Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

					/* Advance past the trailing space. */
					Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

					return Gen_In;

				case '\0':
					/*
					** Input parsing has failed so issue
					** the following message and quit.
					**
					** 	"Input string is not terminated with double-quote
					**	 in <Gen_Caller>."
					*/
					DBDK_TRACE_ERROR( Gen_Caller, ERRORMESG9, 10 );

					/* not reached */

				default:
					*Gen_Out++ = *Gen_In;
					Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
					Gen_Width -= (char *)Gen_In - Gen_InStart;

					break;
			}
		}

		/*
		** Input parsing has failed so issue
		** the following message and quit.
		**
		** 	"Input string is too long in <Gen_Caller>."
		*/
		DBDK_TRACE_ERROR( Gen_Caller, ERRORMESG10, 10 );

		/* not reached */
	}

	/* Check for an mi_integer. */
	else if( !strncmp( Gen_Format, "%d %n", 5 ) )
	{
		mi_decimal   Gen_dec_number;  /* Store an mi_decimal value here. */

		/* Convert the GLS string to a decimal value. */
		if( ifx_gl_convert_number( &Gen_dec_number, (char *)Gen_In, "%d" ) == -1 )
		{
			goto parse_error;
		}

		/* Convert the decimal to a 'C' integer. */
		if( dectoint( &Gen_dec_number, (int *)Gen_Result ) != 0 )
		{
			goto parse_error;
		}

		/* Scan past the mi_integer value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'                ||
				 *Gen_In == 'E'                ||
				 *Gen_In == '.'                ||
				 *Gen_In == '+'                ||
				 *Gen_In == '-')               )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for a double value. */
	else if( !strncmp( Gen_Format, "%lf %n", 6 ) )
	{
		mi_decimal   Gen_dec_number;  /* Store an mi_decimal value here. */

		/* Convert the GLS string to a decimal value. */
		if( ifx_gl_convert_number( &Gen_dec_number, (char *)Gen_In, "%e" ) == -1 )
		{
			goto parse_error;
		}

		/* Convert the decimal to a 'C' double. */
		if( dectodbl( &Gen_dec_number, (double *)Gen_Result ) != 0 )
		{
			goto parse_error;
		}

		/* Scan past the number. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'                ||
				 *Gen_In == 'E'                ||
				 *Gen_In == '.'                ||
				 *Gen_In == '+'                ||
				 *Gen_In == '-')               )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 6;
	}

	/* Check for a float value. */
	else if( !strncmp( Gen_Format, "%f %n", 5 ) )
	{
		mi_double_precision Gen_dbl_number; /* Store an mi_float value here.   */
		mi_decimal          Gen_dec_number; /* Store an mi_decimal value here. */

		/* Convert the GLS string to a decimal value. */
		if( ifx_gl_convert_number( &Gen_dec_number, (char *)Gen_In, "%e" ) == -1 )
		{
			goto parse_error;
		}

		/* Convert the decimal to a 'C' float. */
		if( dectodbl( &Gen_dec_number, &Gen_dbl_number ) != 0 )
		{
			goto parse_error;
		}
		*(float *)Gen_Result = (float)Gen_dbl_number;

		/* Scan past the float value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'                ||
				 *Gen_In == 'E'                ||
				 *Gen_In == '.'                ||
				 *Gen_In == '+'                ||
				 *Gen_In == '-')               )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for a long value. */
	else if( !strncmp( Gen_Format, "%ld %n", 6 ) )
	{
		mi_decimal   Gen_dec_number;  /* Store an mi_decimal value here. */

		/* Convert the GLS string to a decimal value. */
		if( ifx_gl_convert_number( &Gen_dec_number, (char *)Gen_In, "%d" ) == -1 )
		{
			goto parse_error;
		}

		/* Convert the decimal to a 'C' long. */
		if( dectolong( &Gen_dec_number, (long *)Gen_Result ) != 0 )
		{
			goto parse_error;
		}

		/* Scan past the long value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'                ||
				 *Gen_In == 'E'                ||
				 *Gen_In == '.'                ||
				 *Gen_In == '+'                ||
				 *Gen_In == '-')               )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 6;
	}

	/* Check for an int8 value. */
	else if( !strncmp( Gen_Format, "%8 %n", 5 ) )
	{
		gl_mchar_t * Gen_Int8Ptr;     /* Scanning pointer.             */
		gl_mchar_t * Gen_Int8Ptr2;    /* Scanning pointer.             */
		mi_integer   Gen_Int8Index;   /* Keep track of the length.     */
		mi_integer   Gen_Int8Ret;     /* ifx_int8cvasc return value.   */
		char         Gen_Int8Str[80]; /* Hold the mi_int8 string here. */

		/*
		** Transfer the data value to a NULL terminated
		** buffer for conversion by ifx_int8cvasc.
		*/
		for( Gen_Int8Ptr   = (gl_mchar_t *)Gen_Int8Str,
			 Gen_Int8Ptr2  = Gen_In,
			 Gen_Int8Index = 0;
				Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_Int8Index;
			++Gen_ByteCount;
		}

		/* Copy the string and terminate. */
		ifx_gl_mbscpy( (gl_mchar_t *)Gen_Int8Str, Gen_Int8Ptr2,
				(int)(Gen_InData - Gen_Int8Ptr2) );
		Gen_Int8Str[Gen_InData - Gen_Int8Ptr2] = (char)'\0';

		/* Check for an empty string. */
		if( Gen_Int8Index == 0 )
		{
			goto parse_error;
		}

		/* Convert the mi_int8 value from text to internal format. */
		Gen_Int8Ret = ifx_int8cvasc( Gen_Int8Str, strlen( Gen_Int8Str ),
		                             (ifx_int8_t *)&Gen_Result );
		if( Gen_Int8Ret )
		{
			goto parse_error;
		}

		/* Scan past the int8 value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'                ||
				 *Gen_In == 'E'                ||
				 *Gen_In == '.'                ||
				 *Gen_In == '+'                ||
				 *Gen_In == '-')               )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/*
	** Check for a boolean value.  Only 'T' or 't'
	** (for True) and  'F' or 'f' (for False)  are
	** accepted.
	*/
	else if( !strncmp( Gen_Format, "%b %n", 5 ) )
	{
		if( *(char *)Gen_In == 'T' || *(char *)Gen_In == 't' )
		{
			*(char *)Gen_Result = 1;
		}
		else if( *(char *)Gen_In == 'F' || *(char *)Gen_In == 'f' )
		{
			*(char *)Gen_Result = 0;
		}
		else
		{
			goto parse_error;
		}

		Gen_ByteCount += sizeof(char);

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an unsigned int value. */
	else if( !strncmp( Gen_Format, "%x %n", 5 ) )
	{
		mi_decimal Gen_dec_number; /* Store an mi_decimal value here. */

		/* Convert the GLS string to a decimal value. */
		if( ifx_gl_convert_number( &Gen_dec_number, (char *)Gen_In, "%u" ) == -1 )
		{
			goto parse_error;
		}

		/* Convert the decimal to a 'C' unsigned integer. */
		if( dectoint( &Gen_dec_number, (int *)Gen_Result ) != 0 )
		{
			goto parse_error;
		}

		/* Scan past the unsigned int value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'                ||
				 *Gen_In == 'E'                ||
				 *Gen_In == '.'                ||
				 *Gen_In == '+'                ||
				 *Gen_In == '-')               )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for a multibyte character. */
	else if( !strncmp( Gen_Format, "%C %n", 5 ) )
	{
		/* Copy the entire multibyte character. */
		Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );
		memcpy( Gen_Result, Gen_In, Gen_ByteCount );

		/* Scan to trailing white space. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-blank. */
			if( !ifx_gl_ismblank( Gen_In, 4 ) )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_money value. */
	else if( !strncmp( Gen_Format, "%m %n", 5 ) )
	{
		gl_mchar_t *   Gen_MoneyPtr;     /* Scanning pointer.                */
		gl_mchar_t *   Gen_MoneyPtr2;    /* Scanning pointer.                */
		mi_lvarchar *  Gen_MoneyLV;      /* mi_lvarchar ptr to Gen_MoneyStr. */
		mi_money *     Gen_MoneyVal;     /* The binary money value.          */
		mi_integer     Gen_MoneyIndex;   /* Keep track of the length.        */
		char           Gen_MoneyStr[80]; /* Hold the mi_money string here.   */

		/*
		** Transfer the data value to a NULL terminated
		** buffer for conversion by mi_money_to_binary.
		*/
		for( Gen_MoneyPtr   = (gl_mchar_t *)Gen_MoneyStr,
			 Gen_MoneyPtr2  = Gen_In,
			 Gen_MoneyIndex = 0;
				Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_MoneyIndex;
			++Gen_ByteCount;
		}

		/* Copy the string and terminate. */
		ifx_gl_mbscpy( (gl_mchar_t *)Gen_MoneyStr, Gen_MoneyPtr2,
					(int)(Gen_In - Gen_MoneyPtr2) );
		Gen_MoneyStr[Gen_In - Gen_MoneyPtr2] = (char)'\0';

		/* Check for an empty string. */
		if( Gen_MoneyIndex == 0 )
		{
			goto parse_error;
		}

		/* Convert the money string to mi_lvarchar. */
		Gen_MoneyLV = mi_string_to_lvarchar( Gen_MoneyStr );

		/* Check for an error in conversion. */
		if( Gen_MoneyLV == 0 )
		{
			goto parse_error;
		}

		/* Convert the money string to internal format. */
		Gen_MoneyVal = mi_money_to_binary( Gen_MoneyLV );

		/* Check for an error in conversion. */
		if( Gen_MoneyVal == NULL )
		{
			goto parse_error;
		}

		/* Copy to the UDT data area. */
		memcpy( Gen_Result, Gen_MoneyVal, sizeof(mi_money) );

		/* ... and free the temporary money data values. */
		mi_free( Gen_MoneyLV );
		mi_free( Gen_MoneyVal );

		/* Scan past the money value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'                ||
				 *Gen_In == 'E'                ||
				 *Gen_In == '.'                ||
				 *Gen_In == '+'                ||
				 *Gen_In == '-')               )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_numeric/mi_decimal value. */
	else if( !strncmp( Gen_Format, "%N %n", 5 ) )
	{
		gl_mchar_t * Gen_DecPtr;     /* Scanning pointer.                */
		gl_mchar_t * Gen_DecPtr2;    /* Scanning pointer.                */
		mi_decimal   Gen_DecVal;     /* The binary decimal value.        */
		mi_integer   Gen_DecIndex;   /* Keep track of the length.        */
		mi_integer   Gen_DecRet;     /* deccvasc return value.           */
		char         Gen_DecStr[80]; /* Hold the mi_decimal string here. */

		/*
		** Transfer the data value to a NULL terminated
		** buffer for conversion by deccvasc.
		*/
		for( Gen_DecPtr   = (gl_mchar_t *)Gen_DecStr,
			 Gen_DecPtr2  = Gen_In,
			 Gen_DecIndex = 0;
				Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_DecIndex;
			++Gen_ByteCount;
		}

		/* Copy the string and terminate. */
		ifx_gl_mbscpy( (gl_mchar_t *)Gen_DecStr, Gen_DecPtr2,
					(int)(Gen_In - Gen_DecPtr2) );
		Gen_DecStr[Gen_In - Gen_DecPtr2] = (char)'\0';

		/* Check for an empty string. */
		if( Gen_DecIndex == 0 )
		{
			goto parse_error;
		}

		/* Convert the mi_decimal value from text to internal format. */
		Gen_DecRet = deccvasc( Gen_DecStr, strlen( Gen_DecStr ), &Gen_DecVal );

		/* Check for an error in conversion. */
		if( Gen_DecRet )
		{
			goto parse_error;
		}

		/* Copy to the UDT data area. */
		memcpy( Gen_Result, &Gen_DecVal, sizeof(mi_decimal) );

		/* Scan past the decimal value. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !(ifx_gl_ismdigit( Gen_In, 4 ) ||
				 *Gen_In == 'e'                ||
				 *Gen_In == 'E'                ||
				 *Gen_In == '.'                ||
				 *Gen_In == '+'                ||
				 *Gen_In == '-')               )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_date value. */
	else if( !strncmp( Gen_Format, "%D %n", 5 ) )
	{
		gl_mchar_t * Gen_DatePtr;     /* Scanning pointer.             */
		gl_mchar_t * Gen_DatePtr2;    /* Scanning pointer.             */
		long         Gen_DateVal;     /* The binary date value.        */
		mi_integer   Gen_DateIndex;   /* Keep track of the length.     */
		mi_integer   Gen_RstrdateRet; /* rstrdate return value.        */
		char         Gen_DateStr[80]; /* Hold the mi_date string here. */

		/*
		** Transfer the data value to a NULL terminated
		** buffer for conversion by rstrdate.
		*/
		for( Gen_DatePtr   = (gl_mchar_t *)Gen_DateStr,
			 Gen_DatePtr2  = Gen_In,
			 Gen_DateIndex = 0;
				Gen_In < Gen_InData + Gen_InDataLen &&
				!ifx_gl_ismblank( Gen_In, 4 ); )
		{
			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_DateIndex;
			++Gen_ByteCount;
		}

		/* Copy the string and terminate. */
		ifx_gl_mbscpy( (gl_mchar_t *)Gen_DateStr, Gen_DatePtr2,
					(int)(Gen_In - Gen_DatePtr2) );
		Gen_DateStr[Gen_In - Gen_DatePtr2] = (char)'\0';

		/* Check for an empty string. */
		if( Gen_DateIndex == 0 )
		{
			goto parse_error;
		}

		/* Convert the date string to internal format. */
		Gen_RstrdateRet = rstrdate( Gen_DateStr, &Gen_DateVal );

		/* Check for an error in conversion. */
		if( Gen_RstrdateRet )
		{
			goto parse_error;
		}

		/* Copy to the UDT data area. */
		memcpy( Gen_Result, &Gen_DateVal, sizeof(mi_date) );

		/* Scan past the date string. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !ifx_gl_ismdigit( Gen_In, 4 ) )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Check for an mi_datetime value. */
	else if( !strncmp( Gen_Format, "%T %n", 5 ) )
	{
		gl_mchar_t * Gen_DTPtr;      /* Scanning pointer.             */
		gl_mchar_t * Gen_DTPtr2;     /* Scanning pointer.             */
		mi_datetime  Gen_DTVal;      /* The binary date value.        */
		mi_integer   Gen_DTIndex;    /* Keep track of the length.     */
		int          Gen_Blanks;     /* Number of blanks scanned.     */
		int          Gen_DtcvascRet; /* dtcvasc return value.         */
		char         Gen_DTStr[80];  /* Hold the mi_date string here. */

		/*
		** Transfer the data value to a NULL terminated
		** buffer for conversion by dtcvasc.
		*/
		for( Gen_DTPtr   = (gl_mchar_t *)Gen_DTStr,
			 Gen_DTPtr2  = Gen_In,
			 Gen_Blanks  = 0,
			 Gen_DTIndex = 0;
				Gen_In < Gen_InData + Gen_InDataLen; )
		{
			/* Stop at the second blank. */
			if( ifx_gl_ismblank( Gen_In, 4 ) && ++Gen_Blanks == 2 )
			{
				break;
			}

			/* Advance the input pointer. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

			/* Keep track of the length. */
			++Gen_DTIndex;
			++Gen_ByteCount;
		}

		/* Copy the string and terminate. */
		ifx_gl_mbscpy( (gl_mchar_t *)Gen_DTStr, Gen_DTPtr2,
					(int)(Gen_In - Gen_DTPtr2) );
		Gen_DTStr[Gen_In - Gen_DTPtr2] = (char)'\0';

		/* Check for an empty string. */
		if( Gen_DTIndex == 0 )
		{
			goto parse_error;
		}

		/*
		** Set the  mi_datetime  qualifier.   It is
		** copied from the return value's qualifier.
		*/
		Gen_DTVal.dt_qual = ((mi_datetime *)Gen_Result)->dt_qual;

		/* Convert the mi_datetime value to internal format. */
		Gen_DtcvascRet = dtcvasc( Gen_DTStr, &Gen_DTVal );

		/* Check to insure that the conversion was successful. */
		if( Gen_DtcvascRet )
		{
			goto parse_error;
		}

		/* Copy to the UDT data area. */
		memcpy( Gen_Result, &Gen_DTVal, sizeof(mi_datetime) );

		/* Scan past the datetime string. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-number. */
			if( !ifx_gl_ismdigit( Gen_In, 4 ) )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Advance the format string. */
		Gen_Format += 5;
	}

	/* Handle all other types using sscanf. */
	else if( 1 != sscanf( (char *)Gen_In, Gen_Format, Gen_Out, &Gen_ByteCount ) )
	{
		goto parse_error;
	}

	/* Satisfy any remaining non-format characters in the format string. */
	while( *Gen_Format && *Gen_In )
	{
		/* Scan past trailing white space in the data. */
		while( Gen_In < Gen_InData + Gen_InDataLen )
		{
			/* Stop at the first non-blank. */
			if( !ifx_gl_ismblank( Gen_In, 4 ) )
			{
				break;
			}

			/* Keep track of how far we've advanced. */
			Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

			/* Advance to the next character. */
			Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
		}

		/* Check for the format character. */
		if( *Gen_Format != *(char *)Gen_In )
		{
			break;
		}

		/*
		**	The non-format character and the input data
		**	must match. If not, issue a message.
		*/
		if( *(char *)Gen_In != *Gen_Format )
		{
			goto parse_error;
		}

		/* Keep track of how far we've advanced. */
		Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

		/* Advance to the next character. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );

		/* Advance to the next character. */
		++Gen_Format;
	}

	/*	** Finally, scan past trailing spaces
	** and non-format characters.
	*/

	/* Scan past trailing white space in the data. */
	while( Gen_In < Gen_InData + Gen_InDataLen )
	{
		/* Stop at the first non-blank. */
		if( !ifx_gl_ismblank( Gen_In, 4 ) )
		{
			break;
		}

		/* Keep track of how far we've advanced. */
		Gen_ByteCount += ifx_gl_mblen( Gen_In, 4 );

		/* Advance to the next character. */
		Gen_In = ifx_gl_mbsnext( Gen_In, 4 );
	}

	return Gen_InData + Gen_ByteCount;

parse_error:

	/*
	** Input parsing has failed so issue
	** the following message and quit.
	**
	** 	"Input data format error in <Gen_Caller>."
	*/
	DBDK_TRACE_ERROR( Gen_Caller, ERRORMESG11, 10 );

	/* not reached */
}
/* Warning: Do not modify. Gen_sscanf checksum: 90906602   */

/*************************************************************************
**
** Function name:
**
**	Gen_Trace
**
** Description:
**
**	This function writes trace information to the trace file.
**
**	Complete information about tracing may be found in
**	the INFORMIX-DataBlade API, User's Guide, Version 9.0.
**
**	To enable tracing, you must first create a trace class
**	by inserting a record into the systraceclasses system
**	catalog:
**
**		insert into informix.systraceclasses(name)
**		values('dblogic');
**
**	The name of the trace file must be set. If the file name
**	is not set, the server uses a default file name:
**	the session id followed by ".trc" in the /tmp directory.
**	Use "onstat -g ses" to get the session id.
**
**	The following code snippet may be used to set the name
**	of the output trace file from within your code.
**
**		mi_tracefile_set( "/yourpath/yourfile.trc" );
**
**	Alternately, the TraceSet_dblogic procedure may be
**	used from SQL to set the trace file name and trace threshold
**	level.  See this procedure for more details.
**
**	To insure that tracing text  actually  appears in the
**	output trace file, SERVER_LOCALE, CLIENT_LOCALE,  and
**	DB_LOCALE must be set in the environment to the
**	appropriate locale (e.g., "en_us.1252").
**
** Parameters:
**
**	MI_CONNECTION * Gen_Con            The database connection.
**	char *          Gen_Caller         Call originated from this routine.
**	char *          Gen_FileName       Call originated in this file.
**	mi_integer      Gen_LineNo         Call originated on this line.
**	char *          Gen_MsgNo          ERRORMESG number.
**	char *          Gen_Class          Tracing class.
**	mi_integer      Gen_Threshold      Tracing threshold.
**	mi_integer      Gen_MsgType        MI_SQL | MI_MESSAGE | DBDK_TRACE.
**
** Return value:
**
**	None.
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    Gen_Trace FunctionId: 59DEDB71-760B-11d0-A2EC-00AA0009BF87
**
*************************************************************************
*/
void
Gen_Trace
(
MI_CONNECTION *         Gen_Con,           /* The database connection.           */
char *                  Gen_Caller,        /* Call originated from this routine. */
char *                  Gen_FileName,      /* Call originated in this file.      */
mi_integer              Gen_LineNo,        /* Call originated on this line.      */
char *                  Gen_MsgNo,         /* ERRORMESG number.                  */
char *                  Gen_Class,         /* Tracing class.                     */
mi_integer              Gen_Threshold,     /* Tracing threshold.                 */
mi_integer              Gen_MsgType        /* MI_SQL | MI_MESSAGE | DBDK_TRACE.  */
)
{
	/* Route the message to the trace file? */
	if( Gen_MsgType & DBDK_TRACE )
	{
		/* Write the message to the trace file. */
		GL_DPRINTF( Gen_Class,
		            Gen_Threshold,
		            (
		                Gen_MsgNo,
		                "FUNCTION%s", Gen_Caller,      /* Substitute the caller here.    */
		                "FILENAME%s", Gen_FileName,    /* Substitute the file name here. */
		                "LINENO%d",   Gen_LineNo,      /* Substitute the line info here. */
		                MI_LIST_END                    /* Terminate the list!!           */
		            )
		          );
	}

	/* Mask off the mi_db_error_raise flags. */
	Gen_MsgType &= 0xffff;

	/* Route the message back to the user? */
	if( Gen_MsgType )
	{
		/* If requested, also write the message to the user. */
		mi_db_error_raise( Gen_Con,                    /* This is the connection handle. */
		                   Gen_MsgType,                /* Route to the user.             */
		                   Gen_MsgNo,                  /* Print this message.            */
		                   "FUNCTION%s", Gen_Caller,   /* Substitute the caller here.    */
		                   (char *)NULL );             /* Terminator.                    */

		/*
		** mi_db_error_raise may not return
		** and this line may not be reached.
		*/
	}
}
/* Warning: Do not modify. Gen_Trace checksum: 185750136  */

/****************************************************************
**
** Function name:
**
**	wiregetseccomp
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine getseccomp (Wire) returns integer.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    wiregetseccomp FunctionId: 5510bfb3-6c28-11d3-a6fa-008048ed75bd
**
*****************************************************************
*/
mi_integer
wiregetseccomp
(
Wire *	awire,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle.             */
	mi_integer      Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in wiregetseccomp."
		*/
		DBDK_TRACE_ERROR( "wiregetseccomp", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that wiregetseccomp has been called.
	*/
	DBDK_TRACE_ENTER( "wiregetseccomp" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this function.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Function wiregetseccomp has not been implemented." );

	/*
	** TO DO: Compute and store your value into Gen_RetVal.
	**        The call to mi_fp_setreturnisnull informs the
	**        server that the return value is NULL.
	*/
	//mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
	Gen_RetVal = awire->Second_comp_id;

	/*
	** Write to the trace file indicating
	** that wiregetseccomp has successfully exited.
	*/
	DBDK_TRACE_EXIT( "wiregetseccomp" );

	return Gen_RetVal;
}
/* Warning: Do not modify. wiregetseccomp checksum: 484367165  */

/****************************************************************
**
** Function name:
**
**	locgetypos
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine getypos (Loc) returns integer.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    locgetypos FunctionId: 5510bfaf-6c28-11d3-a6fa-008048ed75bd
**
*****************************************************************
*/
mi_integer
locgetypos
(
Loc *	aloc,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle.             */
	mi_integer      Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in locgetypos."
		*/
		DBDK_TRACE_ERROR( "locgetypos", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that locgetypos has been called.
	*/
	DBDK_TRACE_ENTER( "locgetypos" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this function.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Function locgetypos has not been implemented." );

	/*
	** TO DO: Compute and store your value into Gen_RetVal.
	**        The call to mi_fp_setreturnisnull informs the
	**        server that the return value is NULL.
	*/
	//mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
	Gen_RetVal = aloc->Ypos;

	/*
	** Write to the trace file indicating
	** that locgetypos has successfully exited.
	*/
	DBDK_TRACE_EXIT( "locgetypos" );

	return Gen_RetVal;
}
/* Warning: Do not modify. locgetypos checksum: 873679714  */

/****************************************************************
**
** Function name:
**
**	pingetid
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine getid (Pin) returns integer.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    pingetid FunctionId: 5510bfaa-6c28-11d3-a6fa-008048ed75bd
**
*****************************************************************
*/
mi_integer
pingetid
(
Pin *	apin,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle.             */
	mi_integer      Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in pingetid."
		*/
		DBDK_TRACE_ERROR( "pingetid", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that pingetid has been called.
	*/
	DBDK_TRACE_ENTER( "pingetid" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this function.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Function pingetid has not been implemented." );

	/*
	** TO DO: Compute and store your value into Gen_RetVal.
	**        The call to mi_fp_setreturnisnull informs the
	**        server that the return value is NULL.
	*/
	//mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
	Gen_RetVal = apin->Pin_id;

	/*
	** Write to the trace file indicating
	** that pingetid has successfully exited.
	*/
	DBDK_TRACE_EXIT( "pingetid" );

	return Gen_RetVal;
}
/* Warning: Do not modify. pingetid checksum: 668073199  */

/****************************************************************
**
** Function name:
**
**	pingetvalue
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine getvalue (Pin) returns integer.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    pingetvalue FunctionId: 5510bfac-6c28-11d3-a6fa-008048ed75bd
**
*****************************************************************
*/
mi_integer
pingetvalue
(
Pin *	apin,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle.             */
	mi_integer      Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in pingetvalue."
		*/
		DBDK_TRACE_ERROR( "pingetvalue", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that pingetvalue has been called.
	*/
	DBDK_TRACE_ENTER( "pingetvalue" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this function.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Function pingetvalue has not been implemented." );

	/*
	** TO DO: Compute and store your value into Gen_RetVal.
	**        The call to mi_fp_setreturnisnull informs the
	**        server that the return value is NULL.
	*/
	/*mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );  */

	Gen_RetVal =apin->Pin_value;

	/*
	** Write to the trace file indicating
	** that pingetvalue has successfully exited.
	*/
	DBDK_TRACE_EXIT( "pingetvalue" );

	return Gen_RetVal;
}
/* Warning: Do not modify. pingetvalue checksum: 176091554  */

/****************************************************************
**
** Function name:
**
**	wiregetfirstpin
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine getfirstpin (Wire) returns integer.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    wiregetfirstpin FunctionId: 5510bfb2-6c28-11d3-a6fa-008048ed75bd
**
*****************************************************************
*/
mi_integer
wiregetfirstpin
(
Wire *	awire,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle.             */
	mi_integer      Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in wiregetfirstpin."
		*/
		DBDK_TRACE_ERROR( "wiregetfirstpin", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that wiregetfirstpin has been called.
	*/
	DBDK_TRACE_ENTER( "wiregetfirstpin" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this function.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Function wiregetfirstpin has not been implemented." );

	/*
	** TO DO: Compute and store your value into Gen_RetVal.
	**        The call to mi_fp_setreturnisnull informs the
	**        server that the return value is NULL.
	*/
	/*mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE ); */
	Gen_RetVal = awire->First_pin_id;

	/*
	** Write to the trace file indicating
	** that wiregetfirstpin has successfully exited.
	*/
	DBDK_TRACE_EXIT( "wiregetfirstpin" );

	return Gen_RetVal;
}
/* Warning: Do not modify. wiregetfirstpin checksum: 187754284  */

/****************************************************************
**
** Function name:
**
**	wiregetid
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine getid (Wire) returns integer.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    wiregetid FunctionId: 5510bfb0-6c28-11d3-a6fa-008048ed75bd
**
*****************************************************************
*/
mi_integer
wiregetid
(
Wire *	awire,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle.             */
	mi_integer      Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in wiregetid."
		*/
		DBDK_TRACE_ERROR( "wiregetid", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that wiregetid has been called.
	*/
	DBDK_TRACE_ENTER( "wiregetid" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this function.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Function wiregetid has not been implemented." );

	/*
	** TO DO: Compute and store your value into Gen_RetVal.
	**        The call to mi_fp_setreturnisnull informs the
	**        server that the return value is NULL.
	*/
	//mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
	Gen_RetVal = awire->Wire_id;

	/*
	** Write to the trace file indicating
	** that wiregetid has successfully exited.
	*/
	DBDK_TRACE_EXIT( "wiregetid" );

	return Gen_RetVal;
}
/* Warning: Do not modify. wiregetid checksum: 670729926  */

/****************************************************************
**
** Function name:
**
**	pincheckterm
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine checkterm (Pin) returns integer.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    pincheckterm FunctionId: 5510bfad-6c28-11d3-a6fa-008048ed75bd
**
*****************************************************************
*/
mi_integer
pincheckterm
(
Pin *	apin,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle.             */
	mi_integer      Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in pincheckterm."
		*/
		DBDK_TRACE_ERROR( "pincheckterm", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that pincheckterm has been called.
	*/
	DBDK_TRACE_ENTER( "pincheckterm" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this function.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Function pincheckterm has not been implemented." );

	/*
	** TO DO: Compute and store your value into Gen_RetVal.
	**        The call to mi_fp_setreturnisnull informs the
	**        server that the return value is NULL.
	*/

	/*mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );*/
	Gen_RetVal = apin->isterminal;

	/*
	** Write to the trace file indicating
	** that pincheckterm has successfully exited.
	*/
	DBDK_TRACE_EXIT( "pincheckterm" );

	return Gen_RetVal;
}
/* Warning: Do not modify. pincheckterm checksum: 578630404  */

/****************************************************************
**
** Function name:
**
**	pingetcomp
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine getcomp (Pin) returns integer.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    pingetcomp FunctionId: 5510bfab-6c28-11d3-a6fa-008048ed75bd
**
*****************************************************************
*/
mi_integer
pingetcomp
(
Pin *	apin,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle.             */
	mi_integer      Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in pingetcomp."
		*/
		DBDK_TRACE_ERROR( "pingetcomp", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that pingetcomp has been called.
	*/
	DBDK_TRACE_ENTER( "pingetcomp" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this function.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Function pingetcomp has not been implemented." );

	/*
	** TO DO: Compute and store your value into Gen_RetVal.
	**        The call to mi_fp_setreturnisnull informs the
	**        server that the return value is NULL.
	*/
	//mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
	Gen_RetVal = apin->Component_id;

	/*
	** Write to the trace file indicating
	** that pingetcomp has successfully exited.
	*/
	DBDK_TRACE_EXIT( "pingetcomp" );

	return Gen_RetVal;
}
/* Warning: Do not modify. pingetcomp checksum: 873366783  */

/****************************************************************
**
** Function name:
**
**	wiregetvalue
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine getvalue (Wire) returns integer.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    wiregetvalue FunctionId: 5510bfb5-6c28-11d3-a6fa-008048ed75bd
**
*****************************************************************
*/
mi_integer
wiregetvalue
(
Wire *	awire,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle.             */
	mi_integer      Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in wiregetvalue."
		*/
		DBDK_TRACE_ERROR( "wiregetvalue", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that wiregetvalue has been called.
	*/
	DBDK_TRACE_ENTER( "wiregetvalue" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this function.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Function wiregetvalue has not been implemented." );

	/*
	** TO DO: Compute and store your value into Gen_RetVal.
	**        The call to mi_fp_setreturnisnull informs the
	**        server that the return value is NULL.
	*/

	//mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
	Gen_RetVal = awire->Wire_value;

	/*
	** Write to the trace file indicating
	** that wiregetvalue has successfully exited.
	*/
	DBDK_TRACE_EXIT( "wiregetvalue" );

	return Gen_RetVal;
}
/* Warning: Do not modify. wiregetvalue checksum: 978913198  */

/****************************************************************
**
** Function name:
**
**	wiregetsecpin
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine getsecpin (Wire) returns integer.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    wiregetsecpin FunctionId: 5510bfb4-6c28-11d3-a6fa-008048ed75bd
**
*****************************************************************
*/
mi_integer
wiregetsecpin
(
Wire *	awire,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle.             */
	mi_integer      Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in wiregetsecpin."
		*/
		DBDK_TRACE_ERROR( "wiregetsecpin", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that wiregetsecpin has been called.
	*/
	DBDK_TRACE_ENTER( "wiregetsecpin" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this function.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Function wiregetsecpin has not been implemented." );

	/*
	** TO DO: Compute and store your value into Gen_RetVal.
	**        The call to mi_fp_setreturnisnull informs the
	**        server that the return value is NULL.
	*/
	//mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
	Gen_RetVal = awire->Second_pin_id;

	/*
	** Write to the trace file indicating
	** that wiregetsecpin has successfully exited.
	*/
	DBDK_TRACE_EXIT( "wiregetsecpin" );

	return Gen_RetVal;
}
/* Warning: Do not modify. wiregetsecpin checksum: 481607494  */

/****************************************************************
**
** Function name:
**
**	wiregetfirstcomp
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine getfirstcomp (Wire) returns integer.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    wiregetfirstcomp FunctionId: 5510bfb1-6c28-11d3-a6fa-008048ed75bd
**
*****************************************************************
*/
mi_integer
wiregetfirstcomp
(
Wire *	awire,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle.             */
	mi_integer      Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in wiregetfirstcomp."
		*/
		DBDK_TRACE_ERROR( "wiregetfirstcomp", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that wiregetfirstcomp has been called.
	*/
	DBDK_TRACE_ENTER( "wiregetfirstcomp" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this function.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Function wiregetfirstcomp has not been implemented." );

	/*
	** TO DO: Compute and store your value into Gen_RetVal.
	**        The call to mi_fp_setreturnisnull informs the
	**        server that the return value is NULL.
	*/
	//mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
	Gen_RetVal = awire->First_comp_id;

	/*
	** Write to the trace file indicating
	** that wiregetfirstcomp has successfully exited.
	*/
	DBDK_TRACE_EXIT( "wiregetfirstcomp" );

	return Gen_RetVal;
}
/* Warning: Do not modify. wiregetfirstcomp checksum: 190714590  */

/****************************************************************
**
** Function name:
**
**	locgetxpos
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine getxpos (Loc) returns integer.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    locgetxpos FunctionId: 5510bfae-6c28-11d3-a6fa-008048ed75bd
**
*****************************************************************
*/
mi_integer
locgetxpos
(
Loc *	aloc,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle.             */
	mi_integer      Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in locgetxpos."
		*/
		DBDK_TRACE_ERROR( "locgetxpos", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that locgetxpos has been called.
	*/
	DBDK_TRACE_ENTER( "locgetxpos" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this function.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Function locgetxpos has not been implemented." );

	/*
	** TO DO: Compute and store your value into Gen_RetVal.
	**        The call to mi_fp_setreturnisnull informs the
	**        server that the return value is NULL.
	*/
	//mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
	Gen_RetVal = aloc->Xpos;

	/*
	** Write to the trace file indicating
	** that locgetxpos has successfully exited.
	*/
	DBDK_TRACE_EXIT( "locgetxpos" );

	return Gen_RetVal;
}
/* Warning: Do not modify. locgetxpos checksum: 873734514  */

/****************************************************************
**
** Procedure name:
**	PinSetall
**
** Description:
**
** Special Comments:
**	Entrypoint for the SQL routine Setall (Pin,integer,integer,integer,integer,integer) returns void.
**
** Parameters:
**
** History:
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**	Warning: Do not remove or modify this comment:
**	    PinSetall FunctionId: 22a4f680-9855-11d3-a74a-008048ed75bd
**
*****************************************************************
*/
void
PinSetall
(
Pin *	PinOpaque,
mi_integer	Pin_id,
mi_integer	Comp_id,
mi_integer	Pin_value,
mi_integer	pio,
mi_integer	isterm,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle. */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in PinSetall."
		*/
		DBDK_TRACE_ERROR( "PinSetall", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that PinSetall has been called.
	*/
	DBDK_TRACE_ENTER( "PinSetall" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this procedure.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Procedure PinSetall has not been implemented." );

	/* TO DO: Place your procedure code here. */
	PinOpaque->Pin_id=Pin_id;
	PinOpaque->Component_id=Comp_id;
	PinOpaque->Pin_value=Pin_value;
	PinOpaque->pinio=pio;
	PinOpaque->isterminal=isterm;
	/*
	** Write to the trace file indicating
	** that PinSetall has successfully exited.
	*/
	DBDK_TRACE_EXIT( "PinSetall" );

}
/* Warning: Do not modify. PinSetall checksum: 720035004  */

/****************************************************************
**
** Procedure name:
**	compSettype
**
** Description:
**
** Special Comments:
**	Entrypoint for the SQL routine Settype (Component,integer) returns void.
**
** Parameters:
**
** History:
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**	Warning: Do not remove or modify this comment:
**	    compSettype FunctionId: 201e0253-a209-11d3-a757-008048ed75bd
**
*****************************************************************
*/
void
compSettype
(
Component *	aComp,
mi_integer	comptype,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle. */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in compSettype."
		*/
		DBDK_TRACE_ERROR( "compSettype", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that compSettype has been called.
	*/
	DBDK_TRACE_ENTER( "compSettype" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this procedure.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Procedure compSettype has not been implemented." );

	/* TO DO: Place your procedure code here. */
	aComp->Component_type=comptype;
	/*
	** Write to the trace file indicating
	** that compSettype has successfully exited.
	*/
	DBDK_TRACE_EXIT( "compSettype" );

}
/* Warning: Do not modify. compSettype checksum: 913402042  */

/****************************************************************
**
** Procedure name:
**	wireSetvalue
**
** Description:
**
** Special Comments:
**	Entrypoint for the SQL routine Setvalue (Wire,integer) returns void.
**
** Parameters:
**
** History:
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**	Warning: Do not remove or modify this comment:
**	    wireSetvalue FunctionId: 201e0260-a209-11d3-a757-008048ed75bd
**
*****************************************************************
*/
void
wireSetvalue
(
Wire *	aWire,
mi_integer	wirevalue,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle. */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in wireSetvalue."
		*/
		DBDK_TRACE_ERROR( "wireSetvalue", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that wireSetvalue has been called.
	*/
	DBDK_TRACE_ENTER( "wireSetvalue" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this procedure.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Procedure wireSetvalue has not been implemented." );

	/* TO DO: Place your procedure code here. */
	aWire->Wire_value=wirevalue;
	/*
	** Write to the trace file indicating
	** that wireSetvalue has successfully exited.
	*/
	DBDK_TRACE_EXIT( "wireSetvalue" );

}
/* Warning: Do not modify. wireSetvalue checksum: 815089361  */

/****************************************************************
**
** Procedure name:
**	compSetypos
**
** Description:
**
** Special Comments:
**	Entrypoint for the SQL routine Setypos (Component,integer) returns void.
**
** Parameters:
**
** History:
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**	Warning: Do not remove or modify this comment:
**	    compSetypos FunctionId: 201e0255-a209-11d3-a757-008048ed75bd
**
*****************************************************************
*/
void
compSetypos
(
Component *	aComp,
mi_integer	ypos,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle. */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in compSetypos."
		*/
		DBDK_TRACE_ERROR( "compSetypos", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that compSetypos has been called.
	*/
	DBDK_TRACE_ENTER( "compSetypos" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this procedure.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Procedure compSetypos has not been implemented." );

	/* TO DO: Place your procedure code here. */
	aComp->Component_loc.Ypos=ypos;
	/*
	** Write to the trace file indicating
	** that compSetypos has successfully exited.
	*/
	DBDK_TRACE_EXIT( "compSetypos" );

}
/* Warning: Do not modify. compSetypos checksum: 113346783  */

/****************************************************************
**
** Procedure name:
**	wireSetall
**
** Description:
**
** Special Comments:
**	Entrypoint for the SQL routine Setall (Wire,integer,integer,integer,integer,integer,integer) returns void.
**
** Parameters:
**
** History:
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**	Warning: Do not remove or modify this comment:
**	    wireSetall FunctionId: 201e025a-a209-11d3-a757-008048ed75bd
**
*****************************************************************
*/
void
wireSetall
(
Wire *	aWire,
mi_integer	wireid,
mi_integer	comp1,
mi_integer	pin1,
mi_integer	comp2,
mi_integer	pin2,
mi_integer	wirevalue,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle. */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in wireSetall."
		*/
		DBDK_TRACE_ERROR( "wireSetall", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that wireSetall has been called.
	*/
	DBDK_TRACE_ENTER( "wireSetall" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this procedure.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Procedure wireSetall has not been implemented." );

	/* TO DO: Place your procedure code here. */
	aWire->Wire_id=wireid;
	aWire->First_comp_id=comp1;
	aWire->First_pin_id=pin1;
	aWire->Second_comp_id=comp2;
	aWire->Second_pin_id=pin2;
	aWire->Wire_value=wirevalue;
	/*
	** Write to the trace file indicating
	** that wireSetall has successfully exited.
	*/
	DBDK_TRACE_EXIT( "wireSetall" );

}
/* Warning: Do not modify. wireSetall checksum: 325649625  */

/****************************************************************
**
** Procedure name:
**	wireSetseccomp
**
** Description:
**
** Special Comments:
**	Entrypoint for the SQL routine Setseccomp (Wire,integer) returns void.
**
** Parameters:
**
** History:
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**	Warning: Do not remove or modify this comment:
**	    wireSetseccomp FunctionId: 201e025e-a209-11d3-a757-008048ed75bd
**
*****************************************************************
*/
void
wireSetseccomp
(
Wire *	aWire,
mi_integer	compid,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle. */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in wireSetseccomp."
		*/
		DBDK_TRACE_ERROR( "wireSetseccomp", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that wireSetseccomp has been called.
	*/
	DBDK_TRACE_ENTER( "wireSetseccomp" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this procedure.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Procedure wireSetseccomp has not been implemented." );

	/* TO DO: Place your procedure code here. */
	aWire->Second_comp_id=compid;
	/*
	** Write to the trace file indicating
	** that wireSetseccomp has successfully exited.
	*/
	DBDK_TRACE_EXIT( "wireSetseccomp" );

}
/* Warning: Do not modify. wireSetseccomp checksum: 719593662  */

/****************************************************************
**
** Procedure name:
**	pinSetvalue
**
** Description:
**
** Special Comments:
**	Entrypoint for the SQL routine Setvalue (Pin,integer) returns void.
**
** Parameters:
**
** History:
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**	Warning: Do not remove or modify this comment:
**	    pinSetvalue FunctionId: 201e0258-a209-11d3-a757-008048ed75bd
**
*****************************************************************
*/
void
pinSetvalue
(
Pin *	aPin,
mi_integer	pinvalue,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle. */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in pinSetvalue."
		*/
		DBDK_TRACE_ERROR( "pinSetvalue", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that pinSetvalue has been called.
	*/
	DBDK_TRACE_ENTER( "pinSetvalue" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this procedure.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Procedure pinSetvalue has not been implemented." );

	/* TO DO: Place your procedure code here. */
	aPin->Pin_value=pinvalue;
	/*
	** Write to the trace file indicating
	** that pinSetvalue has successfully exited.
	*/
	DBDK_TRACE_EXIT( "pinSetvalue" );

}
/* Warning: Do not modify. pinSetvalue checksum: 212617011  */

/****************************************************************
**
** Procedure name:
**	wireSetfirstcomp
**
** Description:
**
** Special Comments:
**	Entrypoint for the SQL routine Setfirstcomp (Wire,integer) returns void.
**
** Parameters:
**
** History:
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**	Warning: Do not remove or modify this comment:
**	    wireSetfirstcomp FunctionId: 201e025c-a209-11d3-a757-008048ed75bd
**
*****************************************************************
*/
void
wireSetfirstcomp
(
Wire *	aWire,
mi_integer	compid,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle. */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in wireSetfirstcomp."
		*/
		DBDK_TRACE_ERROR( "wireSetfirstcomp", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that wireSetfirstcomp has been called.
	*/
	DBDK_TRACE_ENTER( "wireSetfirstcomp" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this procedure.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Procedure wireSetfirstcomp has not been implemented." );

	/* TO DO: Place your procedure code here. */
	aWire->First_comp_id=compid;
	/*
	** Write to the trace file indicating
	** that wireSetfirstcomp has successfully exited.
	*/
	DBDK_TRACE_EXIT( "wireSetfirstcomp" );

}
/* Warning: Do not modify. wireSetfirstcomp checksum: 624847871  */

/****************************************************************
**
** Procedure name:
**	pinSetid
**
** Description:
**
** Special Comments:
**	Entrypoint for the SQL routine Setid (Pin,integer) returns void.
**
** Parameters:
**
** History:
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**	Warning: Do not remove or modify this comment:
**	    pinSetid FunctionId: 201e0256-a209-11d3-a757-008048ed75bd
**
*****************************************************************
*/
void
pinSetid
(
Pin *	aPin,
mi_integer	pinid,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle. */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in pinSetid."
		*/
		DBDK_TRACE_ERROR( "pinSetid", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that pinSetid has been called.
	*/
	DBDK_TRACE_ENTER( "pinSetid" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this procedure.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Procedure pinSetid has not been implemented." );

	/* TO DO: Place your procedure code here. */
	aPin->Pin_id=pinid;
	/*
	** Write to the trace file indicating
	** that pinSetid has successfully exited.
	*/
	DBDK_TRACE_EXIT( "pinSetid" );

}
/* Warning: Do not modify. pinSetid checksum: 105794722  */

/****************************************************************
**
** Procedure name:
**	compSetall
**
** Description:
**
** Special Comments:
**	Entrypoint for the SQL routine Setall (Component,integer,integer,integer,integer) returns void.
**
** Parameters:
**
** History:
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**	Warning: Do not remove or modify this comment:
**	    compSetall FunctionId: 201e0251-a209-11d3-a757-008048ed75bd
**
*****************************************************************
*/
void
compSetall
(
Component *	aComp,
mi_integer	compid,
mi_integer	comptype,
mi_integer	xpos,
mi_integer	ypos,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle. */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in compSetall."
		*/
		DBDK_TRACE_ERROR( "compSetall", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that compSetall has been called.
	*/
	DBDK_TRACE_ENTER( "compSetall" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this procedure.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Procedure compSetall has not been implemented." );

	/* TO DO: Place your procedure code here. */
	aComp->Component_id=compid;
	aComp->Component_type=comptype;
	aComp->Component_loc.Xpos=xpos;
	aComp->Component_loc.Ypos=ypos;
	/*
	** Write to the trace file indicating
	** that compSetall has successfully exited.
	*/
	DBDK_TRACE_EXIT( "compSetall" );

}
/* Warning: Do not modify. compSetall checksum: 419860268  */

/****************************************************************
**
** Procedure name:
**	wireSetsecpin
**
** Description:
**
** Special Comments:
**	Entrypoint for the SQL routine Setsecpin (Wire,integer) returns void.
**
** Parameters:
**
** History:
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**	Warning: Do not remove or modify this comment:
**	    wireSetsecpin FunctionId: 201e025f-a209-11d3-a757-008048ed75bd
**
*****************************************************************
*/
void
wireSetsecpin
(
Wire *	aWire,
mi_integer	pinid,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle. */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in wireSetsecpin."
		*/
		DBDK_TRACE_ERROR( "wireSetsecpin", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that wireSetsecpin has been called.
	*/
	DBDK_TRACE_ENTER( "wireSetsecpin" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this procedure.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Procedure wireSetsecpin has not been implemented." );

	/* TO DO: Place your procedure code here. */
	aWire->Second_pin_id=pinid;
	/*
	** Write to the trace file indicating
	** that wireSetsecpin has successfully exited.
	*/
	DBDK_TRACE_EXIT( "wireSetsecpin" );

}
/* Warning: Do not modify. wireSetsecpin checksum: 817199645  */

/****************************************************************
**
** Procedure name:
**	wireSetid
**
** Description:
**
** Special Comments:
**	Entrypoint for the SQL routine Setid (Wire,integer) returns void.
**
** Parameters:
**
** History:
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**	Warning: Do not remove or modify this comment:
**	    wireSetid FunctionId: 201e025b-a209-11d3-a757-008048ed75bd
**
*****************************************************************
*/
void
wireSetid
(
Wire *	aWire,
mi_integer	wireid,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle. */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in wireSetid."
		*/
		DBDK_TRACE_ERROR( "wireSetid", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that wireSetid has been called.
	*/
	DBDK_TRACE_ENTER( "wireSetid" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this procedure.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Procedure wireSetid has not been implemented." );

	/* TO DO: Place your procedure code here. */
	aWire->Wire_id=wireid;
	/*
	** Write to the trace file indicating
	** that wireSetid has successfully exited.
	*/
	DBDK_TRACE_EXIT( "wireSetid" );

}
/* Warning: Do not modify. wireSetid checksum: 108056430  */

/****************************************************************
**
** Procedure name:
**	compSetxpos
**
** Description:
**
** Special Comments:
**	Entrypoint for the SQL routine Setxpos (Component,integer) returns void.
**
** Parameters:
**
** History:
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**	Warning: Do not remove or modify this comment:
**	    compSetxpos FunctionId: 201e0254-a209-11d3-a757-008048ed75bd
**
*****************************************************************
*/
void
compSetxpos
(
Component *	aComp,
mi_integer	xpos,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle. */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in compSetxpos."
		*/
		DBDK_TRACE_ERROR( "compSetxpos", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that compSetxpos has been called.
	*/
	DBDK_TRACE_ENTER( "compSetxpos" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this procedure.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Procedure compSetxpos has not been implemented." );

	/* TO DO: Place your procedure code here. */
	aComp->Component_loc.Xpos=xpos;
	/*
	** Write to the trace file indicating
	** that compSetxpos has successfully exited.
	*/
	DBDK_TRACE_EXIT( "compSetxpos" );

}
/* Warning: Do not modify. compSetxpos checksum: 413359315  */

/****************************************************************
**
** Procedure name:
**	pinSetterm
**
** Description:
**
** Special Comments:
**	Entrypoint for the SQL routine Setterm (Pin,integer) returns void.
**
** Parameters:
**
** History:
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**	Warning: Do not remove or modify this comment:
**	    pinSetterm FunctionId: 201e0259-a209-11d3-a757-008048ed75bd
**
*****************************************************************
*/
void
pinSetterm
(
Pin *	aPin,
mi_integer	pinterm,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle. */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in pinSetterm."
		*/
		DBDK_TRACE_ERROR( "pinSetterm", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that pinSetterm has been called.
	*/
	DBDK_TRACE_ENTER( "pinSetterm" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this procedure.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Procedure pinSetterm has not been implemented." );

	/* TO DO: Place your procedure code here. */
	aPin->isterminal=pinterm;
	/*
	** Write to the trace file indicating
	** that pinSetterm has successfully exited.
	*/
	DBDK_TRACE_EXIT( "pinSetterm" );

}
/* Warning: Do not modify. pinSetterm checksum: 110505140  */

/****************************************************************
**
** Procedure name:
**	compSetid
**
** Description:
**
** Special Comments:
**	Entrypoint for the SQL routine Setid (Component,integer) returns void.
**
** Parameters:
**
** History:
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**	Warning: Do not remove or modify this comment:
**	    compSetid FunctionId: 201e0252-a209-11d3-a757-008048ed75bd
**
*****************************************************************
*/
void
compSetid
(
Component *	aComp,
mi_integer	compid,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle. */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in compSetid."
		*/
		DBDK_TRACE_ERROR( "compSetid", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that compSetid has been called.
	*/
	DBDK_TRACE_ENTER( "compSetid" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this procedure.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Procedure compSetid has not been implemented." );

	/* TO DO: Place your procedure code here. */
	aComp->Component_id=compid;
	/*
	** Write to the trace file indicating
	** that compSetid has successfully exited.
	*/
	DBDK_TRACE_EXIT( "compSetid" );

}
/* Warning: Do not modify. compSetid checksum: 208525980  */

/****************************************************************
**
** Procedure name:
**	wireSetfirstpin
**
** Description:
**
** Special Comments:
**	Entrypoint for the SQL routine Setfirstpin (Wire,integer) returns void.
**
** Parameters:
**
** History:
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**	Warning: Do not remove or modify this comment:
**	    wireSetfirstpin FunctionId: 201e025d-a209-11d3-a757-008048ed75bd
**
*****************************************************************
*/
void
wireSetfirstpin
(
Wire *	aWire,
mi_integer	pinid,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle. */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in wireSetfirstpin."
		*/
		DBDK_TRACE_ERROR( "wireSetfirstpin", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that wireSetfirstpin has been called.
	*/
	DBDK_TRACE_ENTER( "wireSetfirstpin" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this procedure.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Procedure wireSetfirstpin has not been implemented." );

	/* TO DO: Place your procedure code here. */
	aWire->First_pin_id=pinid;
	/*
	** Write to the trace file indicating
	** that wireSetfirstpin has successfully exited.
	*/
	DBDK_TRACE_EXIT( "wireSetfirstpin" );

}
/* Warning: Do not modify. wireSetfirstpin checksum: 822345854  */

/****************************************************************
**
** Procedure name:
**	pinSetcomp
**
** Description:
**
** Special Comments:
**	Entrypoint for the SQL routine Setcomp (Pin,integer) returns void.
**
** Parameters:
**
** History:
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**	Warning: Do not remove or modify this comment:
**	    pinSetcomp FunctionId: 201e0257-a209-11d3-a757-008048ed75bd
**
*****************************************************************
*/
void
pinSetcomp
(
Pin *	aPin,
mi_integer	compid,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle. */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in pinSetcomp."
		*/
		DBDK_TRACE_ERROR( "pinSetcomp", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that pinSetcomp has been called.
	*/
	DBDK_TRACE_ENTER( "pinSetcomp" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this procedure.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Procedure pinSetcomp has not been implemented." );

	/* TO DO: Place your procedure code here. */
	aPin->Component_id=compid;
	/*
	** Write to the trace file indicating
	** that pinSetcomp has successfully exited.
	*/
	DBDK_TRACE_EXIT( "pinSetcomp" );

}
/* Warning: Do not modify. pinSetcomp checksum: 110322883  */

/****************************************************************
**
** Function name:
**
**	pingetio
**
** Description:
**
** Special Comments:
**
**	Entrypoint for the SQL routine getio (Pin) returns integer.
**
** Parameters:
**
** Return value:
**
**	mi_integer
**
** History:
**
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**
**	Warning: Do not remove or modify this comment:
**	    pingetio FunctionId: 1f5d3041-c406-11d3-a785-008048ed75bd
**
*****************************************************************
*/
mi_integer
pingetio
(
Pin *	apin,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle.             */
	mi_integer      Gen_RetVal;        /* The return value.                  */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in pingetio."
		*/
		DBDK_TRACE_ERROR( "pingetio", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that pingetio has been called.
	*/
	DBDK_TRACE_ENTER( "pingetio" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this function.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Function pingetio has not been implemented." );

	/*
	** TO DO: Compute and store your value into Gen_RetVal.
	**        The call to mi_fp_setreturnisnull informs the
	**        server that the return value is NULL.
	*/
	//	mi_fp_setreturnisnull( Gen_fparam, 0, MI_TRUE );
	Gen_RetVal = apin->pinio;
	/*
	** Write to the trace file indicating
	** that pingetio has successfully exited.
	*/
	DBDK_TRACE_EXIT( "pingetio" );

	return Gen_RetVal;
}
/* Warning: Do not modify. pingetio checksum: 167984309  */

/****************************************************************
**
** Procedure name:
**	pinsetio
**
** Description:
**
** Special Comments:
**	Entrypoint for the SQL routine setio (Pin,integer) returns void.
**
** Parameters:
**
** History:
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**	Warning: Do not remove or modify this comment:
**	    pinsetio FunctionId: 1f5d3042-c406-11d3-a785-008048ed75bd
**
*****************************************************************
*/
void
pinsetio
(
Pin *	apin,
mi_integer	aio,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle. */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in pinsetio."
		*/
		DBDK_TRACE_ERROR( "pinsetio", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that pinsetio has been called.
	*/
	DBDK_TRACE_ENTER( "pinsetio" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this procedure.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Procedure pinsetio has not been implemented." );

	/* TO DO: Place your procedure code here. */
	apin->pinio=aio;
	/*
	** Write to the trace file indicating
	** that pinsetio has successfully exited.
	*/
	DBDK_TRACE_EXIT( "pinsetio" );

}
/* Warning: Do not modify. pinsetio checksum: 606228833  */

/****************************************************************
**
** Procedure name:
**	locSetxpos
**
** Description:
**
** Special Comments:
**	Entrypoint for the SQL routine Setxpos (Loc,integer) returns void.
**
** Parameters:
**
** History:
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**	Warning: Do not remove or modify this comment:
**	    locSetxpos FunctionId: 8c13c9e0-ca93-11d3-a795-008048ed75bd
**
*****************************************************************
*/
void
locSetxpos
(
Loc *	aloc,
mi_integer	xval,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle. */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in locSetxpos."
		*/
		DBDK_TRACE_ERROR( "locSetxpos", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that locSetxpos has been called.
	*/
	DBDK_TRACE_ENTER( "locSetxpos" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this procedure.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Procedure locSetxpos has not been implemented." );

	/* TO DO: Place your procedure code here. */
	aloc->Xpos=xval;
	/*
	** Write to the trace file indicating
	** that locSetxpos has successfully exited.
	*/
	DBDK_TRACE_EXIT( "locSetxpos" );

}
/* Warning: Do not modify. locSetxpos checksum: 109866880  */

/****************************************************************
**
** Procedure name:
**	locSetypos
**
** Description:
**
** Special Comments:
**	Entrypoint for the SQL routine Setypos (Loc,integer) returns void.
**
** Parameters:
**
** History:
**	Jan 14, 2000 - Generated by BladeSmith Version 3.40.TXXXXX.
**
** Identification:
**	Warning: Do not remove or modify this comment:
**	    locSetypos FunctionId: 8c13c9e1-ca93-11d3-a795-008048ed75bd
**
*****************************************************************
*/
void
locSetypos
(
Loc *	aloc,
mi_integer	yval,
MI_FPARAM *	Gen_fparam  /* Standard info - see DBDK docs. */
)
{
	MI_CONNECTION * Gen_Con;           /* The connection handle. */

	/* Get the current connection handle. */
	Gen_Con = mi_open( NULL, NULL, NULL );

	/* Verify that the connection has been established. */
	if( Gen_Con == 0 )
	{
		/*
		** Opening the current connection has failed
		** so issue the following message and quit.
		**
		** 	"Connection has failed in locSetypos."
		*/
		DBDK_TRACE_ERROR( "locSetypos", ERRORMESG1, 10 );

		/* not reached */
	}

	/*
	** Write to the trace file indicating
	** that locSetypos has been called.
	*/
	DBDK_TRACE_ENTER( "locSetypos" );

	/*
	** TO DO: Remove this comment and call to
	**        mi_db_error_raise after implementing
	**        this procedure.
	*/
	mi_db_error_raise( Gen_Con, MI_MESSAGE,
		"Procedure locSetypos has not been implemented." );

	/* TO DO: Place your procedure code here. */
	aloc->Ypos=yval;
	/*
	** Write to the trace file indicating
	** that locSetypos has successfully exited.
	*/
	DBDK_TRACE_EXIT( "locSetypos" );

}
/* Warning: Do not modify. locSetypos checksum: 509880322  */

#ifdef __cplusplus

}

#endif
